---
title: Symbole
slug: Glossaire/Symbole
tags:
  - Glossaire
  - JavaScript
  - Partage
translation_of: Glossary/Symbol
---
<p><span id="result_box" lang="fr"><span>Cette page de glossaire décrit à la fois un type de données, appelé "symbole", et la fonction de classe, appelée "{{jsxref ("Symbol","symbole")}}()", qui (entre autres) crée des instances du type de données symbole</span> <span>.</span></span></p>

<p><span id="result_box" lang="fr"><span>Le type de données "symbol" est un type de données primitif dont la qualité est d'avoir des valeurs utilisables pour rendre les propriétés d'objets anonymes.</span> <span>Ce type de données est utilisé comme clé pour une propriété d'objet lorsque la propriété est destinée à être privée, pour l'utilisation interne d'une classe ou d'un type d'objet.</span> <span>Par exemple, les clés du symbole de type existent dans divers objets JavaScript intégrés.</span> <span>De même, les classes personnalisées peuvent créer des membres privés de cette façon.</span> <span>Le type de données de symbole est hautement spécialisé dans ce but, et remarquable pour son manque de polyvalence ;</span> <span>une instance de symbole peut être assignée à une valeur L, elle peut être contrôlée pour l'identité, et c'est tout;</span> <span>aucun autre opérateur ne s'applique.</span> <span>(Comparez ceci avec une instance de "Number", par exemple l'entier "42", qui a une panoplie d'opérateurs qui comparent ou combinent la valeur avec d'autres de son type.)</span></span></p>

<p><span id="result_box" lang="fr"><span>Une valeur ayant le type de données "symbole" peut être appelée "valeur de symbole".</span> <span>Dans l'environnement d'exécution JavaScript, une valeur de symbole est créée en appelant la fonction Symbol (), qui produit de façon dynamique une valeur unique anonyme.</span> <span>La seule utilisation judicieuse est de stocker le symbole, puis d'utiliser la valeur stockée pour créer une propriété d'objet.</span> <span>L'exemple suivant stocke le symbole dans un "var".</span></span></p>

<pre class="brush: js line-numbers  language-js"><code class="language-js"><span class="keyword token">var</span>  myPrivateMethod  <span class="operator token">=</span> <span class="function token">Symbol</span><span class="punctuation token">(</span><span class="punctuation token">)</span><span class="punctuation token">;</span>
<span class="keyword token">this</span><span class="punctuation token">[</span>myPrivateMethod<span class="punctuation token">]</span> <span class="operator token">=</span> <span class="keyword token">function</span><span class="punctuation token">(</span><span class="punctuation token">)</span> <span class="punctuation token">{</span><span class="punctuation token">.</span><span class="punctuation token">.</span><span class="punctuation token">.</span><span class="punctuation token">}</span><span class="punctuation token">;</span></code></pre>

<p><span id="result_box" lang="fr"><span>Lorsqu'une valeur de symbole est utilisée comme identifiant dans une affectation de propriété, la propriété (comme le symbole) est anonyme;</span> <span>et est également non dénombrable.</span> <span>Comme la propriété n'est pas énumérable, elle n'apparaîtra pas en tant que membre dans la construction de la boucle "<code>for (... in ...)</code>", et parce que la propriété est anonyme, elle n'apparaîtra pas dans le tableau des résultats de</span> <span>"<code>Object.getOwnPropertyNames()</code>".</span> <span>Vous pouvez accéder à la propriété en utilisant la valeur de symbole d'origine qui l'a créée ou en itérant sur le tableau de résultats de "<code>Object.getOwnPropertySymbols()</code>".</span> <span>Dans l'exemple de code précédent, l'accès à la propriété se fera via la valeur qui a été stockée dans la variable <code>myPrivateMethod</code>.</span></span></p>

<p>La fonction intégrée "{{jsxref("Symbol")}}<code>()</code>" est une classe incomplète qui renvoie une valeur de symbole lorsqu'elle est appelée en tant que fonction, qui génère une erreur lors de tentatives d'utilisation en tant que constructeur avec la syntaxe "<code>new </code><span title="Symbol()&quot;, that has static methods for accessing JavaScript's global symbol table, and that has static properties for addressing certain symbols that are present in commonly used objects."><code>Symbol()</code> ", qui a des méthodes statiques pour accéder à la table globale de symboles de JavaScript, et qui a des propriétés statiques pour adresser certains symboles qui sont présents dans les objets couramment utilisés. </span><span title="The creation of symbol values by the Symbol() function was explained above.">La création de valeurs de symboles par la fonction <code>Symbol()</code> a été expliquée ci-dessus. </span><span title="The throwing of an error upon attempts to use Symbol() as a constructor is explained as a precaution against the accidental creation of an object that might cause confusion.">Le lancement d'une erreur sur les tentatives d'utilisation de <code>Symbol()</code> en tant que constructeur est expliqué comme une précaution contre la création accidentelle d'un objet qui pourrait provoquer une confusion. </span><span title='The methods that access the global symbol registry are "Symbol.for()" and "Symbol.keyFor()";'>Les méthodes qui accèdent au registre global de symboles sont "<code>Symbol.for()</code>" et "<code>Symbol.keyFor()</code>" ; </span><span title='these mediate between the global symbol table (or "registry") and the run-time environment.'>celles-ci servent de médiateur entre la table globale de symboles (ou "registre") et l'environnement d'exécution. </span><span title="The symbol registry is mostly built by JavaScript's compiler infrastructure, and the symbol registry's content is not available to JavaScript's run-time infrastructure, except through these reflective methods.">Le registre de symboles est principalement construit par l'infrastructure du compilateur JavaScript, et le contenu du registre de symboles n'est pas disponible pour l'infrastructure d'exécution de JavaScript, à l'exception de ces méthodes de réflexion. </span><span title='The method Symbol.for("tokenString") returns a symbol value from the registry, and Symbol.keyFor(symbolValue) returns a token string from the registry;'>La méthode <code>Symbol.for("tokenString")</code> retourne une valeur de symbole du registre et <code>Symbol.keyFor(symbolValue)</code> renvoie une chaîne de signes du registre ; </span><span title="each is the other's inverse, so the following is true:">chacun est l'inverse de l'autre, donc ce qui suit est vrai :</span></p>

<pre class="brush: js line-numbers  language-js"><code class="language-js">Symbol<span class="punctuation token">.</span><span class="function token">keyFor</span><span class="punctuation token">(</span>Symbol<span class="punctuation token">.</span><span class="keyword token">for</span><span class="punctuation token">(</span><span class="string token">"tokenString"</span><span class="punctuation token">)</span><span class="punctuation token">)</span><span class="operator token">==</span><span class="string token">"tokenString"</span><span class="punctuation token">;</span>  <span class="comment token">// vrai</span></code></pre>

<p><span id="result_box" lang="fr"><span>La classe <strong>Symbol</strong> a certaines propriétés statiques qui, paradoxalement, nomment l'anonyme.</span> <span>Il n'y en a que quelques unes ;</span> elle<span>s sont pour certaines soi-disant "bien connues" des symboles.</span> <span>Ce sont des symboles, pour certaines propriétés de méthode sélectionnées, qui se trouvent dans certains objets intégrés.</span> <span>L'exposition de ces symboles permet d'avoir un accès direct à ces comportements ;</span> <span>cet accès peut être utile, par exemple, dans la définition d'une classe personnalisée.</span> <span>Des exemples de symboles connus sont : "<code>Symbol.iterator</code>" pour les objets de type tableau, et "<code>Symbol.search</code>" pour les objets de type chaîne.</span></span></p>

<p><span id="result_box" lang="fr"><span>La fonction <code>Symbol()</code> et les valeurs de symbole qu'elle crée peuvent être utiles aux programmeurs qui conçoivent une classe personnalisée.</span> <span>Les valeurs de symboles fournissent un moyen par lequel les classes personnalisées peuvent créer des membres privés et gérer un registre de symboles propre à cette classe.</span> <span>Une classe personnalisée peut utiliser des valeurs de symbole pour créer des propriétés "propres" qui sont protégées contre les découvertes accidentelles.</span> <span>Dans la définition de classe, la valeur de symbole créée dynamiquement est enregistrée dans une variable étendue, disponible uniquement en privé dans la définition de classe.</span> <span>Il n'y a pas de chaîne symbolique ;</span> <span>la variable portée joue le rôle équivalent d'un signe.</span></span></p>

<p><span lang="fr"><span>Dans quelques langages de programmation, le type de donnée symbole est appelé un "atome".</span></span></p>

<p><span lang="fr"><span>Symbol peut avoir une description facultative, mais à des fins de débogage uniquement.</span></span></p>

<p>Le type symbole est une nouvelle fonctionnalité dans ECMAScript 2015 et il n'y a pas d'équivalent en ECMAScript 5.</p>

<pre class="brush: js line-numbers  language-js"><code class="language-js"><span class="function token">Symbol</span><span class="punctuation token">(</span><span class="string token">"foo"</span><span class="punctuation token">)</span> <span class="operator token">!==</span> <span class="function token">Symbol</span><span class="punctuation token">(</span><span class="string token">"foo"</span><span class="punctuation token">)</span>
<span class="keyword token">const</span> foo <span class="operator token">=</span> <span class="function token">Symbol</span><span class="punctuation token">(</span><span class="punctuation token">)</span>
<span class="keyword token">const</span> bar <span class="operator token">=</span> <span class="function token">Symbol</span><span class="punctuation token">(</span><span class="punctuation token">)</span>
<span class="keyword token">typeof</span> foo <span class="operator token">===</span> <span class="string token">"symbol"</span>
<span class="keyword token">typeof</span> bar <span class="operator token">===</span> <span class="string token">"symbol"</span>
<span class="keyword token">let</span> obj <span class="operator token">=</span> <span class="punctuation token">{</span><span class="punctuation token">}</span>
obj<span class="punctuation token">[</span>foo<span class="punctuation token">]</span> <span class="operator token">=</span> <span class="string token">"foo"</span>
obj<span class="punctuation token">[</span>bar<span class="punctuation token">]</span> <span class="operator token">=</span> <span class="string token">"bar"</span>
JSON<span class="punctuation token">.</span><span class="function token">stringify</span><span class="punctuation token">(</span>obj<span class="punctuation token">)</span> <span class="comment token">// {}</span>
Object<span class="punctuation token">.</span><span class="function token">keys</span><span class="punctuation token">(</span>obj<span class="punctuation token">)</span> <span class="comment token">// []</span>
Object<span class="punctuation token">.</span><span class="function token">getOwnPropertyNames</span><span class="punctuation token">(</span>obj<span class="punctuation token">)</span> <span class="comment token">// []</span>
Object<span class="punctuation token">.</span><span class="function token">getOwnPropertySymbols</span><span class="punctuation token">(</span>obj<span class="punctuation token">)</span> <span class="comment token">// [ Symbol(), Symbol() ]</span></code></pre>

<h2 id="Pour_approfondir">Pour approfondir</h2>

<h3 id="Culture_générale">Culture générale</h3>

<ul>
 <li>{{Interwiki("wikipedia", "Symbole (informatique)")}} sur Wikipédia</li>
 <li><a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Structures_de_donn%C3%A9es">Structures et types de données</a> en JavaScript</li>
</ul>
