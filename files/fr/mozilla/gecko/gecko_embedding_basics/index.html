---
title: Les bases de Gecko embarqués
slug: Mozilla/Gecko/Gecko_Embedding_Basics
translation_of: Mozilla/Gecko/Gecko_Embedding_Basics
---
<p>{{ Outdated("It was last updated a very long time ago.") }}</p>

<div class="almost_half_cell" id="gt-res-content">
<div dir="ltr" style="zoom: 1;"><span id="result_box" lang="fr"><span class="atn hps">Compte tenu de l'</span><span>importance croissante</span> <span class="hps">du Web</span> <span class="atn hps">comme source d'</span><span>information, de divertissement</span><span>,</span> <span class="alt-edited hps">et la connectivité</span> <span class="alt-edited hps">individuelle</span><span>,</span> <span class="hps">la possibilité d'accéder</span> <span class="hps">et</span> <span class="hps">d'afficher des données</span> <span class="alt-edited hps">enregistrées</span> <span class="hps">au format</span> <span class="hps">HTML</span> <span class="hps">devient de plus en</span> <span class="hps">plus</span> <span class="hps">important pour</span> <span class="hps">une grande variété</span> <span class="hps">d'applications logicielles par</span> <span class="hps">ailleurs très</span> <span class="hps">diverses</span><span>.</span> <span class="hps">Que ce soit</span> pour un simple visualiseur HTML <span class="hps">ou</span> pour<span class="hps"> créer un navigateur</span> <span class="hps">web</span> <span class="hps">à part entière</span><span>,</span> <span class="hps">la capacité</span> <span class="hps">d'analyser et d'afficher des documents</span> <span class="hps">de type HTML</span> <span class="hps">est une fonction</span> <span class="hps">de plus en plus</span> <span class="hps">importante</span> <span class="hps">dans</span> <span class="hps">de nombreuses</span> <span class="hps">situations</span><span>.</span> <span class="hps">Pour le</span> <span class="alt-edited hps">développeur d'applications</span><span>,</span> <span class="hps">le problème</span> <span class="hps">est de savoir comment</span> <span class="hps">mettre en œuvre</span> <span class="hps">cette fonctionnalité</span> <span class="hps">cruciale</span> <span class="hps">d'une manière qui</span> <span class="hps">minimise</span> <span class="hps">encore</span> <span class="hps">le temps de développement</span> qui <span class="hps">va permettre de créer</span> <span class="hps">un produit</span> <span class="hps">agile et robuste</span><span>.</span> <span class="alt-edited hps">Intégrer</span> <span class="alt-edited hps">Gecko</span><span>,</span> <span class="hps">le moteur de rendu</span> <span class="hps">au cœur</span> <span class="hps">des navigateurs</span> <span class="hps">Netscape et Mozilla</span><span>,</span> <span class="hps">est</span> <span class="hps">une solution </span></span>pour ce problème.</div>

<div dir="ltr" style="zoom: 1;"> </div>
</div>

<h2 id="Why_Gecko" name="Why_Gecko">Pourquoi Gecko</h2>

<p>Intégrer Gecko est un choix pertinent. Il est rapide, robuste, et respecte les standards du web. Chez Mozilla et Netscape, il a été largement diffusé et abondamment testé.</p>

<p><span style="line-height: 1.5;">Il est Open-Source. Contrairement à d'autres choix d'int</span>égration<span style="line-height: 1.5;">, tout le code source de Gecko est librement disponible et personnalisable. Vous pouvez le bricoler </span><span style="line-height: 1.5;">autant que vous le voulez sans limite. Pourtant, selon la licence choisie, il est possible d'utiliser Gecko comme un composant dans un produit commercial et propriétaire.</span></p>

<p>Comme Gecko est associé avec le projet Mozilla, il y a beaucoup de ressources disponibles pour aider à son intégration. <a href="http://www.mozilla.org/">Le site officiel de Mozilla</a> a un espace dédié aux <a href="http://mozilla.org/projects/embedding/">projets d'intégration.</a> <span id="result_box" lang="fr"><span class="hps">Il y a un</span> <span class="hps">groupe de discussion,</span> <span class="hps">mozilla.dev.embedding</span><span>,</span> <span class="hps">qui met l'accent sur</span> <span class="hps">l'échange d'informations</span> <span class="hps">entre les</span> <span class="hps">intégrateurs</span><span>,</span> <span class="hps">ainsi qu'à un</span> <span class="hps">certain nombre d'autres</span> <span class="hps">groupes de discussion</span> <span class="hps">connexes</span></span>. On peut accéder à un index croisé complet de la<span id="result_box" lang="fr"><a href="http://lxr.mozilla.org/seamonkey"> <span class="hps">base de code</span></a> et il est simple d'ajouter du code, de suivre ses progrès ou d'aider à corriger des bogues via la<span class="hps"> <a href="http://bugzilla.mozilla.org/">base de données</a></span><a href="http://bugzilla.mozilla.org/"> <span class="hps">de bugs</span> <span class="hps">Bugzilla</span><span>.</span></a></span></p>

<p>De plus, Gecko a été architecturé dès le commencement pour être multi-plateforme. La version de mozilla.org, tourne aussi bien sur  Wintel, Mac OS 9.0, OS X et Linux et il existe des portages faits par des tiers sur nombre d'autres plateformes.</p>

<p>Enfin, la license Gecko is gratuite, même si l'application finale est un produit commercial propriétaire. La plupart du temps, toute modification apportée au code originellement fourni par Mozilla (mais pas le code dans lequel il est intégré) doit revenir à la communauté, ce même code originel doit être rendu disponible aux utilisateurs de l'application (souvent via un lien sur le site web de mozilla.org), et l'application doit indiquer de manière évidente (Par exemple un logo sur la boîte ou sur la page APropos) que le produit intègre Gecko. La description exacte des licenses possibles est visible sur <a class="external" href="http://www.mozilla.org/MPL/">Mozilla &amp; Netscape Public Licenses</a>, qui est la seule source légale des information de license.</p>

<h2 id="What_You_Need_to_Embed" name="What_You_Need_to_Embed">Ce dont vous avez besoin pour embarquer</h2>

<p>Une fois que vous avez décidé d'intégrer, il y a trois étapes à suivre. Premierement, vous devez vous procurer le code. Ensuite, vous devez comprendre les quelques technologies spécifiques qui sont utilisées pour manipuler le code de base de Gecko. Enfin, vous devez décider quelles fonctionalités vous pouriez ajouter. Cette section vous guidera dans ces étapes.</p>

<h3 id="Getting_the_Code" name="Getting_the_Code">Vous procurer le code</h3>

<p>Actuellement, le meilleur moyen d'obtenir les fichiers dont vous avez besoin pour intégrer Gecko consiste à télécharcher et compiler les source de Mozilla dans leur totalité. C'est en fait un processu assez simple. Les liens vers les instructions completes sont disponibles dans la section Télécharger le Code source de Mozilla. Une seconde méthode, composant par composant, est en cours de développement, mais est encore au niveau béta. Vous pouvez trouver des informations sur ce projet dans la section Compilation. De plus, nous développons un Environnement d'exécution Gecko (Gecko Runtime Environment ou GRE), de maniere à supporter plusieurs outils batis sur des composants Mozilla tout en n'utilisant qu'un seul ensemble de bibliotheque. (Si vous avez l'intention de travailler composant par composant, soyez particulierement attentifs aux probleme de versions et de compatibilité des binaires. Pour vous aidez sur ce point, regardez la section Réutilisation des composants XPCOM.)</p>

<p>Déjà, vous devz vous procurer quelques outils (en bref, un compilateur, une distribution Perl, et quelaues utilitaires génériques). Ensuite, vous devez les installer sur votre ordinateur. Apres quoi, vous devez télécharger la source. En supposant que vous allez télécharger l'ensemble de l'arborescence, il y a deux manieres de procéder: vous pouvez télécharger en FTP une archive contenant l'ensemble de l'arborescence (c'est la maniere la plus simple, et la plus sure de compiler, mais elle peut contenir une version dépourvue des modifications les plus récentes) ou vous pouvez utiliser CVS pour etre certain que vous téléchargezla version la plus récente. Une fois que vous avez l'arborescence et les outils, et que votre environement est corectement installé, il ne vous reste qu'à exécuter le makefile. Vous pouvew trouver des instructions détaillées pour chacune des plateformes supportées. </p>

<p>Une fois la source compilée, rendez-vous dans le dossier mozilla/embedding/config. Vous y trouverez des fichiers de démonstration (chacun d'entre eux porte un nom commencant par "basebrowser") intégrables sur chacune des plateformes. Ce sont uniquement des exemples, peut-etre inadaptés à votre besoin particulier, mais ce sont un bon moyen de débuter. Il y a aussi des exemples de projets d'intégration pour chacune des plateforme que vous pouvez utiliser en tant que modele. Voir Intégration : Exemples de Mozilla et projets externes. </p>

<h3 id="Understanding_the_Coding_Environment" name="Understanding_the_Coding_Environment">Understanding the Coding Environment</h3>

<p>Mozilla was set up from the beginning to support design and development across multiple platforms and programming languages. To this end, a number of in-house programming technologies were developed, all based around an ideal of object encapsulation. Embedding Gecko necessarily implies acquiring a working knowledge of these technologies, including XPCOM, XPIDL, XPConnect, special string classes, and, optionally, XUL. The following provides a brief introduction to them. More information can be found at the mozilla.org site.</p>

<h4 id="XPCOM" name="XPCOM">XPCOM</h4>

<p>The most important of the Mozilla technologies is <a href="/en/XPCOM" title="en/XPCOM">XPCOM</a>, the Cross-Platform Component Object Model. XPCOM provides a framework which manages the creation, ownership, and deletion of objects and other data throughout Mozilla. If you have used MSCOM, you will recognize certain basic similarities. But there are also significant differences -- XPCOM is cross-platform and designed to run largely in a single thread -- and the two are not at this time compatible.</p>

<h5 id="The_interface" name="The_interface">The interface</h5>

<p>At the core of XPCOM is the concept of the interface. An interface is simply a description of a set of methods, attributes, and related constants all associated with a particular functionality: it is completely distinct from the class that implements those things. The interface serves as a kind of contract: any object that supports a particular interface guarantees that it will perform the services described in it. To keep the interface as language neutral as possible, it is written in a special language, the Interface Definition Language, or IDL. Interface files are often referred to as .idl files. In addition to specifying the functionality of the interface, these files also carry the interface's IID, its globally unique identifying number.</p>

<p>Much of the communication within Gecko takes place in terms of these abstract structures (by convention, their names follow the form <code>nsISomething</code>).</p>

<pre>//this
void ProcessSample(nsISample* aSample) {
	aSample-&gt;Poke("Hello");
//not this
void ProcessSample(nsSampleImpl* aSample) {
	aSample-&gt;Poke("hello");
</pre>

<h5 id=".40status_FROZEN" name=".40status_FROZEN">@status FROZEN</h5>

<p>XPCOM's level of abstraction produces great flexibility in the system. Implementations are free to change as needed. But, to work, the interfaces themselves must remain fixed. Throughout Mozilla's initial design and development period, interfaces have been somewhat fluid, but as the project has matured, more and more of the interfaces have been marked FROZEN. Any interface so marked is guaranteed not to change in the future.</p>

<p>Most of the main interfaces key to the embedding effort are now frozen, but it's always a good idea to check before using any interface. An interface's status is listed in the .idl file's comments. A frozen interface is marked <code>@status FROZEN</code>. You can <a class="external" href="http://lxr.mozilla.org/seamonkey/search?string=%40status+FROZEN">search for frozen interfaces</a> by using the Mozilla cross referencing tool. Until it is frozen, an interface may change at any time. For more information on the freezing process, see the <a class="external" href="http://mozilla.org/projects/embedding/">embedding project page</a>.</p>

<p>Once an interface has been frozen, it is added to the <a class="external" href="http://mozilla.org/projects/embedding/embedapiref/embedapi.html">Gecko Embedding API Reference</a>.</p>

<h5 id="nsISupports" name="nsISupports">nsISupports</h5>

<p>A single object can support more than one interface. In fact, essentially all objects support at least two interfaces -- a minimum of one that does something specifically useful and one, <code>nsISupports</code>, that serves a more general purpose. In a sense, <code>nsISupports</code> is the progenitor of all XPCOM interfaces. All interfaces inherit from it, most directly so. It serves two main functions: runtime type discovery and object lifetime management. It is functionally identical to IUnknown in MSCOM.</p>

<p>Since an object can support multiple interfaces, it's possible to have a pointer to one interface and want to know whether that same object also supports a different interface whose functionality you might also need. The first <code>nsISupports</code> method, <code>QueryInterface()</code>, does exactly that: it asks, in effect, "I know that this object is of type A (supports interface A) but is it also of type B (supports interface B)?"</p>

<p>If it is (or does), <code>QueryInterface()</code> returns to the caller a pointer bound to the newly requested interface.</p>

<pre>void ProcessSample(nsISample* aSample) {
	nsIExample *example;
	nsresult rv;
	rv = aSample-&gt;QueryInterface(NS_GET_IID(nsIExample),(void **)&amp;example);
	if (NS_SUCCEEDED(rv)) {
		example-&gt;DoSomeOperation();
		NS_RELEASE(example); // using a macro to call Release
	}
}
</pre>

<p>Because XPCOM uses an indirect method, the Component Manager, to actually instantiate objects, and because multiple pointers to the same object -- often bound to different interfaces -- can exist, it can quickly become very difficult for callers to keep accurate track of all of the objects to which those pointers point. Objects could be kept around in memory longer than they need to be, causing leaks, or objects could be deleted prematurely, causing dangling pointers. The other two methods in <code>nsISupports</code>, <code>AddRef()</code> and <code>Release()</code>, are designed to deal with this issue. Every time a pointer is given out <code>AddRef()</code> must be called on the object, incrementing an internal counter. Every time a pointer is released, <code>Release()</code> must be called, which decrements that same counter. When the counter reaches zero, there are no pointers to the object remaining and the object can safely delete itself. Control of the object's lifetime stays within the object itself. See below for information on XPCOM's "smart" pointer, <a href="#nsCOMPtr">nsCOMPtr</a>, a utility which helps automate this process.</p>

<h5 id="Object_creation" name="Object_creation">Object creation</h5>

<p>The instantiation of objects is also an indirect process in XPCOM. Just as interfaces have a globally unique ID number (the IID), XPCOM classes are assigned their own GUIDs, the CID. In addition, they are also often given a text-based ID, called a contract ID. One or the other of these IDs is passed to a method on a persistent XPCOM component, the Component Manager, which actually creates the object. When a new library of classes (called a module in XPCOM) is first introduced into the system, it must register itself with the Component Manager, which maintains a registry that maps classes (with their IDs) to the libraries in which they reside.</p>

<p>A limited number of persistent services, supplied by singleton objects, are created and controlled by a companion to the Component Manager, the Service Manager. The Component Manager itself is an example of such a persistent service.</p>

<h5 id="Summing_up" name="Summing_up">Summing up</h5>

<p>Functionality in XPCOM is described by abstract interfaces, and most communication among parts of the system takes place in terms of those interfaces. The underlying objects that implement the interfaces, on the other hand, are created indirectly by the Component Manager based on a cross-indexed registry that it maintains.</p>

<p>One functionality shared by all interfaces is the ability to query the underlying object at runtime to see if also implements other interfaces. In theory an interface is fixed and unchangeable, but at this stage in the Mozilla codebase, only interfaces that have been declared <code>FROZEN</code> are guaranteed not to change significantly. Object lifetime management takes place inside the object itself through an internal counter that keeps track of the number of pointers to the object that have been added or released. The client's only responsibility is to increment and decrement the counter. When the internal counter reaches zero, the object deletes itself.</p>

<h5 id="nsCOMPtr" name="nsCOMPtr">nsCOMPtr</h5>

<p>Sometimes, however, even remembering to call <code>AddRef()</code> and <code>Release()</code> at the right times can be difficult. To make this process easier and more reliable, XPCOM has a built-in "smart" pointer, <code>nsCOMPtr</code>. This pointer takes care of calling <code>AddRef()</code> and <code>Release()</code> for you. Using <code>nsCOMPtr</code> whenever possible will make your code cleaner and more efficient. For more information on the smart pointer, see "<a class="external" href="http://www.mozilla.org/projects/xpcom/nsCOMPtr.html">The Complete nsCOMPtr User's Manual</a>".</p>

<p>Mozilla actually provides a large number of built-in macros (by convention, written in all caps in the code) and utilities like <code>nsCOMPtr</code> that can make the entire process of coding with XPCOM easier. Many of these can be found in the following files: <code>nsCom.h</code>, <code>nsDebug.h</code>, <code>nsError.h</code>, <code>nsIServiceManager.h</code>, and <code>nsISupportsUtils.h</code>. Mozilla also supplies other development tools for tracking memory usage and the like. More information on these can be found at <a class="external" href="http://www.mozilla.org/performance/" rel="freelink">http://www.mozilla.org/performance/</a></p>

<h5 id="For_more_information" name="For_more_information">For more information</h5>

<p>More information on XPCOM in general can be found at <a href="/en/XPCOM" title="en/XPCOM">XPCOM</a>. For an overview of creating XPCOM components, see Chapter 8 of O'Reilly's <em><a class="external" href="http://books.mozdev.org/chapters/ch08.html">Creating Applications with Mozilla</a></em>. There is also a new book completely devoted to this topic, <em><a href="/en/Creating_XPCOM_Components" title="en/Creating_XPCOM_Components">Creating XPCOM Components</a></em>. A fuller explanation of some of the underlying logic to COM systems can be found in the early chapters of <em>Essential COM</em> by Don Box. While it focuses on MSCOM in particular, the book does provide an excellent background on some of the core rationales for using such an object model.</p>

<h4 id="XPIDL" name="XPIDL">XPIDL</h4>

<p>Interfaces are abstract classes written in XPIDL, the Cross Platform Interface Definition Language. Yet to be useful the functionality promised in those interfaces must be implemented in some regular programming language. Facilitating this is the job of the XPIDL compiler. Once an interface is defined in an .idl file, it can be processed by the XPIDL compiler.</p>

<p>The compiler can be set to output a number of things, but generally the output is two-fold: a C++ .h file that includes a commented out template for a full C++ implementation of the interface and an XPT file that contains type library information which works with XPConnect to make the interface available to JavaScript. More information on the syntax of <a href="/en/XPIDL" title="en/XPIDL">XPIDL</a> (a simple C-like language) and the use of the <a href="/en/XPIDL/xpidl" title="en/XPIDL/xpidl">compiler</a> is available.</p>

<h4 id="XPConnect_and_XPT_files" name="XPConnect_and_XPT_files"><a href="/en/XPConnect" title="en/XPConnect">XPConnect</a> and XPT files</h4>

<p><a href="/en/XPConnect" title="en/XPConnect">XPConnect</a> is an <a href="/en/XPCOM" title="en/XPCOM">XPCOM</a> module that allows code written in <a href="/en/JavaScript" title="en/JavaScript">JavaScript</a> to access and manipulate XPCOM components written in C++ and vice versa. By means of XPConnect, components on either side of an XPCOM interface do not, in general, need to know or care about which of these languages the object on the other side is implemented in.</p>

<p>When an interface is run through the XPIDL compiler, it produces an XPT or type library file. Because XPconnect uses the information in this file to implement transparent communication between C++ objects and JavaScript objects across XPCOM interfaces, it is important to make sure they are generated and included with your code even if you are developing exclusively in C++. Not only is a substantial part of the browser, in fact, implemented in JS, it is possible that in the future someone may wish to use JS-based code to interact with whatever components you create .</p>

<p>As is from Mozilla, XPConnect currently facilitates interoperability between C++ and JS. Modules to extend it to allow access from other languages (including Python) are under independent development.</p>

<h4 id="String_classes" name="String_classes">String classes</h4>

<p>Web browsing typically involves a large amount of string manipulation. Mozilla has developed a hierarchy of C++ classes to facilitate such manipulation and to render it efficient and quick. To make communication among objects simpler and more error free, Mozilla uses interfaces, which are, in essence, abstract classes. The string hierarchy is also headed up by a set of abstract classes, <code>nsAString</code>, <code>nsASingleFragmentString</code>, and <code>nsAFlatString</code>, and for the same reasons. (These refer to double-byte strings. There is a parallel hierarchy topped with <code>nsACString</code>, etc., that refers to single-byte strings.) <code>nsAString</code> guarantees only a string of characters. <code>nsASingleFragmentString</code> guarantees that the characters will be stored in a single buffer. <code>nsAFlatString</code> guarantees that the characters will be stored in a single null-terminated buffer. While there are underlying concrete classes, in general it is best to use the most abstract type possible in a given situation. For example, concantenation can be done virtually, through the use of pointers, resulting in an nsAString that can be used like any other string. This saves the allocating and copying that would otherwise have to be done. For more information, see "<a href="/En/Mozilla_internal_string_guide" title="En/Mozilla_internal_string_guide">XPCOM string guide</a>".</p>

<h4 id="XUL.2FXBL" name="XUL.2FXBL">XUL/XBL</h4>

<p>Use of this final Mozilla technology is optional, depending on how you decide to create the user interface for your application. <a href="/en/XUL" title="en/XUL">XUL</a> is Mozilla's highly flexible XML UI Language. It provides a number of largely platform independent widgets from which to construct a UI. Netscape and Mozilla both use XUL for their interfaces, but not all embedders choose to use it. XBL or the eXtensible Binding Language allows you to attach behaviors to XUL's XML elements. More information on XUL can be found at <a class="external" href="http://www.mozilla.org/xpfe/xulref/">XUL Programmer's Reference</a> and on <a href="/en/XBL" title="en/XBL">XBL</a> at <a href="/en/XBL/XBL_1.0_Reference" title="en/XBL/XBL_1.0_Reference">XBL:XBL_1.0_Reference</a>. There is also a wealth of good information on XUL at <a class="external" href="http://www.xulplanet.com/">XULPlanet</a>.</p>

<h3 id="Choosing_Additional_Functionalities" name="Choosing_Additional_Functionalities">Choosing Additional Functionalities</h3>

<p>As of this writing (8/19/02), Gecko is a partially modularized rendering engine. Some functionalities beyond basic browsing are always embedded with Gecko, and, as a result of certain architectural decisions, always will be; some are at present always embedded with Gecko, but may, at some point in the future, be separable; and some are now available purely as options. The following table describes the present status of these additional functionalities:</p>

<table>
 <tbody>
  <tr>
   <th>Functions</th>
   <th>Status Now</th>
   <th>Status in Future</th>
  </tr>
  <tr>
   <td>FTP support</td>
   <td>Optional</td>
   <td> </td>
  </tr>
  <tr>
   <td>HTTPS support</td>
   <td>Optional</td>
   <td> </td>
  </tr>
  <tr>
   <td>International character support</td>
   <td>Optional</td>
   <td> </td>
  </tr>
  <tr>
   <td>XUL support</td>
   <td>Required</td>
   <td>Probably optional</td>
  </tr>
  <tr>
   <td>Network support</td>
   <td>Required</td>
   <td>Maybe optional</td>
  </tr>
  <tr>
   <td>JavaScript support</td>
   <td>Required</td>
   <td>Maybe optional</td>
  </tr>
  <tr>
   <td>CSS support</td>
   <td>Required</td>
   <td>Always required</td>
  </tr>
  <tr>
   <td>DOM support</td>
   <td>Required</td>
   <td>Probably always</td>
  </tr>
  <tr>
   <td>XML support</td>
   <td>Required</td>
   <td>Probably always</td>
  </tr>
 </tbody>
</table>

<p>At this time embedding Mozilla's editor along with the rendering engine Gecko is an uncertain proposion, although the situation continues to improve. For more information on the status of the embeddable editor, see <a class="external" href="http://www.mozilla.org/editor/Editor_Embedding_Guide.html" rel="freelink">http://www.mozilla.org/editor/Editor...ing_Guide.html</a>.</p>

<h2 id="What_Gecko_Provides" name="What_Gecko_Provides">What Gecko Provides</h2>

<p>The following is a description of some of the interfaces most commonly used in embedding Gecko. It is by no means an exhaustive list of the available interfaces. The interfaces in this section are on classes provided by Mozilla. There is also a set of interfaces for which Gecko expects the embedder to provide the implementation. A sample of those are covered in the next section.</p>

<h3 id="Initialization_and_Teardown" name="Initialization_and_Teardown">Initialization and Teardown</h3>

<p>There are two C++ only functions which serve to initalize and terminate Gecko. The initialization function (<a class="external" href="http://mozilla.org/projects/embedding/embedapiref/embedapi2.html#1099700">NS_InitEmbedding</a>) must be called before attempting to use Gecko. It ensures XPCOM is started, creates the component registry if necessary, and starts global services. The shutdown function (<a class="external" href="http://mozilla.org/projects/embedding/embedapiref/embedapi2.html#1101115">NS_TermEmbedding</a>) terminates the Gecko embedding layer, ensuring that global services are unloaded, files are closed and XPCOM is shut down.</p>

<h3 id="nsIWebBrowser" name="nsIWebBrowser"><a class="external" href="http://mozilla.org/projects/embedding/embedapiref/embedapi4.html">nsIWebBrowser</a></h3>

<p>Use of this interface during initialization allows embedders to associate a new <code>nsWebBrowser</code> instance (an object representing the "client-area" of a typical browser window) with the embedder's chrome and to register any listeners. The interface may also be used at runtime to obtain the content DOM window and from that the rest of the DOM.</p>

<p>The <a class="external" href="http://xulplanet.com/references/xpcomref/ifaces/nsIWebBrowser.html">XULPlanet <code>nsWebBrowser</code> reference</a> also has a lot of useful information on this class.</p>

<h3 id="nsIWebBrowserSetup" name="nsIWebBrowserSetup"><a class="external" href="http://www.mozilla.org/projects/embedding/embedapiref/embedapi10.html">nsIWebBrowserSetup</a></h3>

<p>This interface is used to set basic properties (like whether image loading will be allowed) before the browser window is open.</p>

<h3 id="nsIWebNavigation" name="nsIWebNavigation"><a class="external" href="http://www.xulplanet.com/references/xpcomref/ifaces/nsIWebNavigation.html">nsIWebNavigation</a></h3>

<p>The <code>nsIWebNavigation</code> interface is used to load URIs into the web browser instance and provide access to session history capabilities - such as back and forward. As of June 6, 2006, this interface is not yet frozen.</p>

<h3 id="nsIWebBrowserPersist" name="nsIWebBrowserPersist"><a class="external" href="http://www.xulplanet.com/references/xpcomref/ifaces/nsIWebBrowserPersist.html">nsIWebBrowserPersist</a></h3>

<p>The <code>nsIWebBrowserPersist</code> interface allows a URI to be saved to file. As of June 6, 2006, this interface is not yet frozen.</p>

<h3 id="nsIBaseWindow" name="nsIBaseWindow"><a class="external" href="http://www.xulplanet.com/references/xpcomref/ifaces/nsIBaseWindow.html">nsIBaseWindow</a></h3>

<p>The <code>nsIBaseWindow</code> interface describes a generic window and basic operations (size, position, window title retrieval, etc.) that can be performed on it. As of June 6, 2006, this interface is not yet frozen.</p>

<h3 id="nsISHistory" name="nsISHistory"><a class="external" href="http://mozilla.org/projects/embedding/embedapiref/embedapi58.html">nsISHistory</a></h3>

<p>The <code>nsISHistory</code> interface provides access to session history information and allows that information to be purged.</p>

<h3 id="nsIWebBrowserFind" name="nsIWebBrowserFind"><a class="external" href="http://mozilla.org/projects/embedding/embedapiref/embedapi14.html">nsIWebBrowserFind</a></h3>

<p>The <code>nsIWebBrowserFind</code> interface controls the setup and execution of text searches in the browser window.</p>

<h2 id="What_You_Provide" name="What_You_Provide">What You Provide</h2>

<p>The following is a description of some of the more common embedder-provided interfaces used in embedding Gecko. It is by no means an exhaustive list of the available interfaces.</p>

<h3 id="nsIWebBrowserChrome" name="nsIWebBrowserChrome"><a class="external" href="http://mozilla.org/projects/embedding/embedapiref/embedapi6.html">nsIWebBrowserChrome</a></h3>

<p>The <code>nsIWebBrowserChrome</code> interface corresponds to the top-level, outermost window containing an embedded Gecko web browser. You associate it with the WebBrowser through the <code>nsIWebBrowser</code> interface. It provides control over window setup and whether or not the window is modal. It must be implemented.</p>

<h3 id="nsIEmbeddingSiteWindow" name="nsIEmbeddingSiteWindow"><a class="external" href="http://www.mozilla.org/projects/embedding/embedapiref/embedapi12.html">nsIEmbeddingSiteWindow</a></h3>

<p>The <code>nsIEmbeddingSiteWindow</code> interface provides Gecko with the means to call up to the host to resize the window, hide or show it and set/get its title. It must be implemented.</p>

<h3 id="nsIWebProgressListener" name="nsIWebProgressListener"><a href="/en/nsIWebProgressListener" title="en/nsIWebProgressListener">nsIWebProgressListener</a></h3>

<p>The <code>nsIWebProgressListener</code> interface provides information on the progress of loading documents. It is added to the WebBrowser through the <code>nsIWebBrowser</code> interface. It must be implemented. As of this writing (8/19/02), it is not frozen.</p>

<h3 id="nsISHistoryListener" name="nsISHistoryListener"><a class="external" href="http://mozilla.org/projects/embedding/embedapiref/embedapi59.html">nsISHistoryListener</a></h3>

<p>The <code>nsISHistoryListener</code> interface is implemented by embedders who wish to receive notifications about activities in session history. A history listener is notified when pages are added, removed and loaded from session history. It is associated with Gecko through the <code>nsIWebBrowser</code> interface. Implementation is optional.</p>

<h3 id="nsIContextMenuListener" name="nsIContextMenuListener"><a class="external" href="http://mozilla.org/projects/embedding/embedapiref/embedapi5.html">nsIContextMenuListener</a></h3>

<p>The <code>nsIContextMenuListener</code> interface is implemented by embedders who wish to receive notifications for context menu events, i.e. generated by a user right-mouse clicking on a link. It should be implemented on the web browser chrome object associated with the window for which notifications are required. When a context menu event occurs, the browser will call this interface if present. Implementation is optional.</p>

<h3 id="nsIPromptService" name="nsIPromptService"><a href="/en/XPCOM_Interface_Reference/nsIPromptService" title="en/nsIPromptService">nsIPromptService</a></h3>

<p>The <code>nsIPromptServices</code> interface allows the embedder to override Mozilla's standard prompts: alerts, dialog boxes, and check boxes and so forth. The class that implements these embedder specific prompts must be registered with the Component Manager using the same CID and contract ID that the Mozilla standard prompt service normally uses. Implementation is optional. As of this writing (8/19/02), this interface is not frozen.</p>

<h2 id="Common_Embedding_Tasks" name="Common_Embedding_Tasks">Common Embedding Tasks</h2>

<p>The following is a series of code snippets (taken from MFCEmbed, the Windows based embedding Gecko sample) which demonstrate very briefly implementation associated with common embedding tasks. MFCEmbed code was deleted from the current repository as the code quality was not very high and it did not use good embedding APIs. If you need a MFC embedding example, maybe take a look at the K-Meleon source. There are also Linux- and Mac OS-based examples, see <a class="external" href="http://mxr.mozilla.org/mozilla-central/source/embedding/tests/" title="http://mxr.mozilla.org/mozilla-central/source/embedding/tests/">http://mxr.mozilla.org/mozilla-central/source/embedding/tests/</a> for a list of examples.</p>

<h3 id="Gecko_setup" name="Gecko_setup">Gecko setup</h3>

<p>The Gecko embedding layer must be initialized before you can use Gecko. This ensures XPCOM is started, creates the component registry if necessary, and starts global services. There is an equivalent shutdown procedure.</p>

<p>Note that the embedding layer is started up by passing it two parameters. The first indicates where the executable is stored on the file system (<code>nsnull</code> indicates the working directory). The second indicates the file location object "provider" that specifies to Gecko where to find profiles, the component registry preferences, and so on.</p>

<pre>nsresult rv;
rv = NS_InitEmbedding(nsnull, provider);
if(NS_FAILED(rv))
{
ASSERT(FALSE);
return FALSE;
}
</pre>

<h3 id="Creating_a_browser_instance" name="Creating_a_browser_instance">Creating a browser instance</h3>

<p>The embedder-provided BrowserView object calls its method <code>CreateBrowser()</code>. Each browser object (a webbrowser) represents a single browser window. Notice the utility directive <code>do_CreateInstance()</code> and the use of macros.</p>

<pre>//Create an instance of the Mozilla embeddable browser

HRESULT CBrowserView::CreateBrowser()
{
// Create a web shell
nsresult rv;
mWebBrowser = do_CreateInstance(NS_WEBBROWSER_CONTRACTID, &amp;rv);
if(NS_FAILED(rv))
return rv;
</pre>

<p>Once the <code>nsWebBrowser</code> object is created the application uses <code>do_QueryInterface()</code> to load a pointer to the <a class="external" href="http://www.xulplanet.com/references/xpcomref/ifaces/nsIWebNavigation.html">nsIWebNavigation</a> interface into the <code>mWebNav</code> member variable. This will be used later for web page navigation.</p>

<pre>rv = NS_OK;
mWebNav = do_QueryInterface(mWebBrowser, &amp;rv);
if(NS_FAILED(rv))
return rv;
</pre>

<p>Next the embedder-provided <code>CBrowserImpl</code> object is created. Gecko requires that some interfaces be implemented by the embedder so that Gecko can communicate with the embedding application. See the <a href="#What_You_Provide">What You Provide Section</a>. In the sample, <code>CBrowserImpl</code> is the object that implements those required interfaces. It will be passed into the <code>SetContainerWindow()</code> call below.</p>

<pre>mpBrowserImpl = new CBrowserImpl();
if(mpBrowserImpl == nsnull)
return NS_ERROR_OUT_OF_MEMORY;
</pre>

<p>The <code>mWebBrowser</code> interface pointer is then passed to the <code>CBrowserImpl</code> object via its <code>Init()</code> method. A second pointer to the platform specific <code>BrowserFrameGlue</code> interface is also passed in and saved. The <code>BrowserFrameGlue</code> pointer allows <code>CBrowserImpl</code> to call methods to update status bars, progress bars, and so forth.</p>

<pre>mpBrowserImpl-&gt;Init(mpBrowserFrameGlue, mWebBrowser);
mpBrowserImpl-&gt;AddRef();
</pre>

<p>Next the embedder-supplied chrome object is associated with the webbrowser. Note the use of an <code>nsCOMPtr</code>.</p>

<pre>mWebBrowser-&gt;SetContainerWindow
	(NS_STATIC_CAST(nsIWebBrowserChrome*, mpBrowserImpl));
nsCOMPtr&lt;nsIWebBrowserSetup&gt;setup(do_QueryInterface(mWebBrowser));
if (setup)
	setup-&gt;SetProperty(nsIWebBrowserSetup::SETUP_IS_CHROME_WRAPPER,PR_TRUE);
</pre>

<p>Then, the real webbrowser window is created.</p>

<pre>rv = NS_OK;
mBaseWindow = do_QueryInterface(mWebBrowser, &amp;rv);
if(NS_FAILED(rv))
return rv;
</pre>

<h3 id="Binding_a_window" name="Binding_a_window">Binding a window</h3>

<p>Basic location information is passed in.</p>

<pre>RECT rcLocation;
GetClientRect(&amp;rcLocation);
if(IsRectEmpty(&amp;rcLocation))
{
	rcLocation.bottom++;
	rcLocation.top++;
}
rv = mBaseWindow-&gt;InitWindow(nsNativeWidget(m_hWnd),
		nsnull,0, 0, rcLocation.right - rcLocation.left,
		rcLocation.bottom - rcLocation.top);
rv = mBaseWindow-&gt;Create();
</pre>

<p>Note the <code>m_hWnd</code> passed into the call above to <code>InitWindow()</code>. (<code>CBrowserView</code> inherits the <code>m_hWnd</code> from <code>CWnd</code>). This <code>m_hWnd</code> will be used as the parent window by the embeddable browser.</p>

<h3 id="Adding_a_listener" name="Adding_a_listener">Adding a listener</h3>

<p>The <code>BrowserImpl</code> object is added as an <a href="/en/nsIWebProgressListener" title="en/nsIWebProgressListener">nsIWebProgressListener</a>. It will now receive progress messages. These callbacks will be used to update the status/progress bars.</p>

<pre>nsWeakPtr weakling
	(dont_AddRef(NS_GetWeakReference(NS_STATIC_CAST(nsIWebProgressListener*,
			mpBrowserImpl))));
void mWebBrowser-&gt;AddWebBrowserListener(weakling, NS_GET_IID(nsIWebProgressListener));
</pre>

<p>Finally the webbrowser window is shown.</p>

<pre>mBaseWindow-&gt;SetVisibility(PR_TRUE);
</pre>

<h3 id="Using_session_history_to_navigate" name="Using_session_history_to_navigate">Using session history to navigate</h3>

<p>The pointer to <a class="external" href="http://www.xulplanet.com/references/xpcomref/ifaces/nsIWebNavigation.html">nsIWebNavigation</a> saved above is used to move back through session history.</p>

<pre>void CBrowserView::OnNavBack()
{
if(mWebNav)
	mWebNav-&gt;GoBack();
}
</pre>

<h2 id="Appendix:_Data_Flow_Inside_Gecko" name="Appendix:_Data_Flow_Inside_Gecko">Appendix: Data Flow Inside Gecko</h2>

<p>While it isn't strictly necessary for embedders to understand how Gecko does what it does, a brief overview of the main structures involved as Gecko puts bits on a display may be helpful.</p>

<p><img alt="Image:EmbeddingBasicsa.gif" class="internal" src="/@api/deki/files/189/=EmbeddingBasicsa.gif"></p>

<p>HTML data comes into Gecko either from the network or a local source. The first thing that happens is that it is parsed, using Gecko's own HTML parser. Then the Content Model arranges this parsed data into a large tree. The tree is also known as the "Document" and its structure is based on the W3C Document Object Model. Any use of DOM APIs manipulates the data in the Content Model.</p>

<p>Next the data is put into frames using CSS and the Frame Constructor. A frame in this sense (which is not the same thing as an HTML frame) is basically an abstract box within which a DOM element will be displayed. This process produces a Frame Tree, which, like the Content Model, is a tree of data, but this time focused not on the logical relationship among the elements but on the underlying calculations needed to display the data. In the beginning a frame has no size. Using CSS rules specifying how the elements of the DOM should look when they are displayed, including information like font type or image size, the eventual size of each frame is calculated. Because the same data may need to be displayed in different ways -- to a monitor and to a printer, for example -- a particular Content Model may have more than one Frame Tree associated with it. In such a case, each individual Frame Tree would belong to a different "presentation" mode.</p>

<p>Calculations continue as new information flows into the system using a process called <strong>reflow</strong>. As information in the Frame Tree changes, the section of the Frame Tree involved is marked "dirty" by the Frame Constructor. Reflow repeatedly steps through the tree, processing every "dirty" item it encounters until all the items it encounters are "clean". Every item in the Frame Tree has a pointer back to its corresponding item in the Content Model. A change in the Content Model, say through using the DOM APIs to change an element from hidden to visible, produces an equivalent change in the Frame Tree. It's important to note that all of these operations are purely data manipulations. Painting to the display itself is not yet involved at this point.</p>

<p>The next stage is the View Manager. With a few small exceptions that have to do with prompting the Frame Constructor to load graphics, the View Manager is the first place in the process that accesses the native OS. Delaying OS access until this point both helps Gecko to run more quickly and makes cross-platform issues easier to deal with. The View Manger is the place where Gecko figures out where on the display the data will need to be drawn. It then tells the system that that area is "invalid" and needs to be repainted. The actual painting is managed by the gfx submodule, while other low-level system operations are run through the widget submodule, which handles things like platform specific event (mouse clicks and so forth) processing loops and accessing system defaults (colors, fonts, etc.) Both gfx and widget are system specific.</p>

<p>If you want to take a look at the code underlying these structures, the code for the Content Model can be found in <code>/mozilla/content</code>, for the Frame Constructor, CSS, and Reflow in <code>/mozilla/layout</code>, for the View Manager in <code>/mozilla/view</code>, and for the DOM APIs in <code>/mozilla/dom</code>.</p>

<div class="originaldocinfo">
<h2 id="Original_Document_Information" name="Original_Document_Information">Original Document Information</h2>

<ul>
 <li>Author(s): <a class="external" href="/mailto:jeev@jeev13@gmail.com" title="mailto:jeev@jeev13@gmail.com">Ellen Evans</a></li>
 <li>Last Updated Date: August 19, 2002</li>
 <li>Copyright Information: Copyright (C) <u>Creative Commons Attribution</u></li>
</ul>
</div>

<p>{{ languages( { "ja": "ja/Gecko_Embedding_Basics" } ) }}</p>
