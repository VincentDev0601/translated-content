---
title: Opérateurs binaires
slug: Web/JavaScript/Reference/Opérateurs/Opérateurs_binaires
tags:
  - JavaScript
  - Operator
  - Opérateur
  - Reference
translation_of: Web/JavaScript/Reference/Operators
---
<div>{{jsSidebar("Operators")}}</div>

<p>Les opérateurs binaires traitent leurs opérandes comme des séquences de 32 bits (des zéros et des uns), plutôt que comme des nombres décimaux, hexadécimaux ou octaux. Par exemple, le nombre décimal neuf a une représentation binaire de 1001. Les opérateurs binaires traitent de telles représentations binaires, mais renvoient des valeurs numériques JavaScript standards.</p>

<div>{{EmbedInteractiveExample("pages/js/expressions-bitwiseoperators.html")}}</div>

<p class="hidden">Le code source de cet exemple interactif est disponible dans un dépôt GitHub. Si vous souhaitez contribuez à ces exemples, n'hésitez pas à cloner <a href="https://github.com/mdn/interactive-examples">https://github.com/mdn/interactive-examples</a> et à envoyer une <em>pull request</em> !</p>

<p>Le tableau qui suit résume les opérateurs binaires de JavaScript :</p>

<table class="standard-table">
 <tbody>
  <tr>
   <th>Opérateur</th>
   <th>Utilisation</th>
   <th>Description</th>
  </tr>
  <tr>
   <td><a href="/fr/docs/Web/JavaScript/Reference/Opérateurs/Opérateurs_binaires#(ET_binaire)">ET binaire</a></td>
   <td><code>a &amp; b</code></td>
   <td>
    <p>Renvoie un <code>1</code> pour chaque position de bit pour laquelle les bits correspondants des deux opérandes sont des <code>1</code>.</p>
   </td>
  </tr>
  <tr>
   <td><a href="/fr/docs/Web/JavaScript/Reference/Opérateurs/Opérateurs_binaires#(OU_binaire)">OU binaire</a></td>
   <td><code>a | b</code></td>
   <td>Renvoie un <code>1</code> pour chaque position de bit pour laquelle le bit correspondant d'au moins un des deux opérandes est un <code>1</code> .</td>
  </tr>
  <tr>
   <td><a href="/fr/docs/Web/JavaScript/Reference/Opérateurs/Opérateurs_binaires#(XOR_binaire)">OU exclusif binaire (<em>XOR</em>)</a></td>
   <td><code>a ^ b</code></td>
   <td>Renvoie un <code>1</code> pour chaque position de bit pour laquelle le bit correspondant d'un seul des deux opérandes est un <code>1</code>.</td>
  </tr>
  <tr>
   <td><a href="/fr/docs/Web/JavaScript/Reference/Opérateurs/Opérateurs_binaires#(NON_binaire)">NON binaire</a></td>
   <td><code>~ a</code></td>
   <td>Inverse les bits de son opérande.</td>
  </tr>
  <tr>
   <td><a href="/fr/docs/Web/JavaScript/Reference/Opérateurs/Opérateurs_binaires#&lt;&lt;_(décalage_à_gauche)">Décalage à gauche</a></td>
   <td><code>a &lt;&lt; b</code></td>
   <td>Décale <code>a</code> en représentation binaire de <code>b</code> bits vers la gauche, en introduisant des zéros par la droite.</td>
  </tr>
  <tr>
   <td><a href="/fr/docs/Web/JavaScript/Reference/Opérateurs/Opérateurs_binaires#>>_(décalage_à_droite_avec_propagation_du_signe)">Décalage à droite avec propagation du signe</a></td>
   <td><code>a &gt;&gt; b</code></td>
   <td>Décale <code>a</code> en représentation binaire de <code>b</code> bits vers la droite, en rejetant les bits à droite.</td>
  </tr>
  <tr>
   <td><a href="/fr/docs/Web/JavaScript/Reference/Opérateurs/Opérateurs_binaires#>>>_(décalage_à_droite_avec_insertion_de_zéros)">Décalage à droite avec introduction de zéros</a></td>
   <td><code>a &gt;&gt;&gt; b</code></td>
   <td>Décale <code>a</code> en représentation binaire de <code>b</code> bits vers la droite, en rejetant les bits à droite et en introduisant des zéros par la gauche.</td>
  </tr>
 </tbody>
</table>

<h2 id="Entiers_sur_32_bits_signés">Entiers sur 32 bits signés</h2>

<p>Les opérandes de tous les opérateurs binaires sont convertis en entiers signés sur 32 bits en ordre big-endian et en format de <a href="https://fr.wikipedia.org/wiki/Compl%C3%A9ment_%C3%A0_deux">complément à deux</a> (à l'exception de l'opération de décalage à droite avec remplissage des zéros qui renvoie un non-signé). L'ordre big-endian signifie que le bit le plus significatif (la position du bit qui a la plus grande valeur) est le bit le plus à gauche si les 32 bits sont disposés sur une ligne horizontale. Le format de complément à deux signifie que la contrepartie négative d'un nombre (par exemple 5 pour -5) est l'inversion de tous les bits du nombre (NON binaire du nombre, c'est-à-dire son complément à un) plus un. Par exemple, la représentation suivante encode l'entier 314 (base 10) :</p>

<pre class="eval">00000000000000000000000100111010
</pre>

<p>La représentation suivante encode ~314, c'est-à-dire le complément à un de 314 :</p>

<pre class="eval">11111111111111111111111011000101
</pre>

<p>Finalement, la représentation suivante encode -314, c'est-à-dire le complément à deux de 314 :</p>

<pre class="eval">11111111111111111111111011000110
</pre>

<p>Le complément à deux garantit que le bit le plus à gauche soit 0 lorsque le nombre est positif, et <code>1</code> lorsque le nombre est négatif. C'est pourquoi on l'appelle le <em>bit de signe</em> .</p>

<p>Le nombre 0 est l'entier constitué intégralement de bits à <code>0</code> .</p>

<pre>0 (base 10) = 00000000000000000000000000000000 (base 2)</pre>

<p>Le nombre -1 est l'entier constitué intégralement de bits à <code>1</code> .</p>

<pre>-1 (base 10) = 11111111111111111111111111111111 (base 2)</pre>

<p>Le nombre <code>-2147483648</code> (qui correspond à <code>-0x80000000</code> en notation hexadécimale) est l'entier uniquement composé de 0, à l'exception du premier bit (le plus à gauche) qui vaut 1.</p>

<pre>-2147483648 (base 10) = 10000000000000000000000000000000 (base 2)</pre>

<p>Le nombre <code>2147483647</code> (qui correspond à <code>0x7fffffff</code> en notation hexadécimale) est l'entier uniquement composé de 1, à l'exception du premier bit (le plus à gauche) qui vaut 0.</p>

<pre>2147483647 (base 10) = 01111111111111111111111111111111 (base 2)</pre>

<p>Les nombres <code>-2147483648</code> et <code>2147483647</code> sont respectivement le nombre le plus petit et le plus grand qu'on peut représenter sur 32 bits (signés).</p>

<h2 id="Opérateurs_logiques_binaires">Opérateurs logiques binaires</h2>

<p>Conceptuellement, les opérateurs logiques binaires fonctionnent de la manière suivante :</p>

<ul>
 <li>Les opérandes sont convertis en entiers sur 32 bits et exprimés sous la forme d'une série de bits (des 1 et des 0). Les nombres sur plus de 32 bits voient leurs bits supplémentaires supprimés :
  <pre class="brush: js">Avant : 11100110111110100000000000000110000000000001
Après :             10100000000000000110000000000001</pre>
 </li>
 <li>Chaque bit du premier opérande est combiné avec le bit correspondant du second opérande : le premier bit avec le premier bit, le second bit avec le second bit, et ainsi de suite.</li>
 <li>L'opérateur est appliqué à chaque paire de bits, et le résultat est construit bit après bit.</li>
</ul>

<h3 id="(ET_binaire)"><a name="ET">&amp; (ET binaire)</a></h3>

<p>Effectue l'opération ET (<em>AND</em>) sur chaque paire de bits. <code>a</code> ET <code>b</code> donne 1 uniquement si à la fois <code>a</code> et <code>b</code> sont <code>1</code> . La table de vérité pour l'opération ET est :</p>

<table class="standard-table">
 <tbody>
  <tr>
   <td class="header">a</td>
   <td class="header">b</td>
   <td class="header">a ET b</td>
  </tr>
  <tr>
   <td>0</td>
   <td>0</td>
   <td>0</td>
  </tr>
  <tr>
   <td>0</td>
   <td>1</td>
   <td>0</td>
  </tr>
  <tr>
   <td>1</td>
   <td>0</td>
   <td>0</td>
  </tr>
  <tr>
   <td>1</td>
   <td>1</td>
   <td>1</td>
  </tr>
 </tbody>
</table>

<pre class="eval">     9 (base 10) = 00000000000000000000000000001001 (base 2)
    14 (base 10) = 00000000000000000000000000001110 (base 2)
                   --------------------------------
14 &amp; 9 (base 10) = 00000000000000000000000000001000 (base 2) = 8 (base 10)
</pre>

<p>Utiliser le ET binaire avec n'importe quel nombre x et zéro donne zéro. Utiliser le ET binaire avec n'importe quel nombre x et -1 donne x.</p>

<h3 id="(OU_binaire)"><a name="OU">| (OU binaire)</a></h3>

<p>Effectue l'opération OU (<em>OR</em>) sur chaque paire de bits. <code>a</code> OU <code>b</code> donne <code>1</code> si <code>a</code> ou <code>b</code> vaut 1. La table de vérité pour l'opération OU est :</p>

<table class="standard-table">
 <tbody>
  <tr>
   <td class="header">a</td>
   <td class="header">b</td>
   <td class="header">a OU b</td>
  </tr>
  <tr>
   <td>0</td>
   <td>0</td>
   <td>0</td>
  </tr>
  <tr>
   <td>0</td>
   <td>1</td>
   <td>1</td>
  </tr>
  <tr>
   <td>1</td>
   <td>0</td>
   <td>1</td>
  </tr>
  <tr>
   <td>1</td>
   <td>1</td>
   <td>1</td>
  </tr>
 </tbody>
</table>

<pre class="eval">     9 (base 10) = 00000000000000000000000000001001 (base 2)
    14 (base 10) = 00000000000000000000000000001110 (base 2)
                   --------------------------------
14 | 9 (base 10) = 00000000000000000000000000001111 (base 2) = 15 (base 10)
</pre>

<p>Utiliser le OU binaire avec n'importe quel nombre x et 0 donne x. Utiliser le OU binaire avec n'importe quel nombre x et -1 donne -1.</p>

<h3 id="(XOR_binaire)"><a name="XOR">^ (XOR binaire)</a></h3>

<p>Effectue l'opération XOR (OU exclusif) sur chaque paire de bits. <code>a</code> XOR <code>b</code> donne <code>1</code> si <code>a</code> et <code>b</code> sont différents. La table de vérité pour l'opération XOR est :</p>

<table class="standard-table">
 <tbody>
  <tr>
   <td class="header">a</td>
   <td class="header">b</td>
   <td class="header">a XOR b</td>
  </tr>
  <tr>
   <td>0</td>
   <td>0</td>
   <td>0</td>
  </tr>
  <tr>
   <td>0</td>
   <td>1</td>
   <td>1</td>
  </tr>
  <tr>
   <td>1</td>
   <td>0</td>
   <td>1</td>
  </tr>
  <tr>
   <td>1</td>
   <td>1</td>
   <td>0</td>
  </tr>
 </tbody>
</table>

<pre class="eval">     9 (base 10) = 00000000000000000000000000001001 (base 2)
    14 (base 10) = 00000000000000000000000000001110 (base 2)
                   --------------------------------
14 ^ 9 (base 10) = 00000000000000000000000000000111 (base 2) = 7 (base 10)
</pre>

<p>Utiliser le XOR binaire avec n'importe quel nombre x et 0 donne x. Utiliser le XOR binaire avec n'importe quel nombre x et -1 donne ~x.</p>

<h3 id="(NON_binaire)"><a name="NON">~ (NON binaire)</a></h3>

<p>Effectue l'opération NON (<em>NOT</em>) sur chaque bit. NON <code>a</code> donne la valeur inversée (c'est-à-dire le complément à un) de <code>a</code>. La table de vérité de l'opération NON est :</p>

<table class="standard-table">
 <tbody>
  <tr>
   <td class="header">a</td>
   <td class="header">NON a</td>
  </tr>
  <tr>
   <td>0</td>
   <td>1</td>
  </tr>
  <tr>
   <td>1</td>
   <td>0</td>
  </tr>
 </tbody>
</table>

<pre class="eval"> 9 (base 10) = 00000000000000000000000000001001 (base 2)
               --------------------------------
~9 (base 10) = 11111111111111111111111111110110 (base 2) = -10 (base 10)
</pre>

<p>Utiliser le NON binaire avec n'importe quel nombre <code>x</code> donne <code>-(x + 1)</code>. Par exemple, <code>~-5</code> donne <code>4</code>.</p>

<p>Étant donnée la représentation sur 32 bits des nombres en JavaScript, on a <code>~-1</code> et <code>~4294967295</code> (2<sup>32</sup>-1) qui valent tous les deux <code>0</code>.</p>

<h2 id="Opérateurs_de_décalage_binaire">Opérateurs de décalage binaire</h2>

<p>Les opérateurs de décalage binaire (<em>shift</em>) prennent deux opérandes : le premier est une valeur à décaler et le second spécifie le nombre de positions de bits duquel le premier opérande doit glisser. La direction de l'opération de décalage est contrôlée par l'opérateur utilisé.</p>

<p>Les opérateurs de décalage convertissent leurs opérandes en entiers 32 bits en ordre big-endian et renvoient un résultat du même type que l'opérande de gauche. L'opérande droit doit être inférieur à 32, sinon les cinq bits les plus faibles seront utilisés.</p>

<h3 id="&lt;&lt;_(décalage_à_gauche)"><a name="Gauche">&lt;&lt; (décalage à gauche)</a></h3>

<p>Cet opérateur décale le premier opérande du nombre de bits spécifié vers la gauche. Les bits surnuméraires éjectés à gauche sont perdus. Des bits à zéro sont insérés par la droite.</p>

<p>Par exemple, <code>9 &lt;&lt; 2</code> donne 36 :</p>

<pre class="eval">     9 (base 10) : 00000000000000000000000000001001 (base 2)
                   --------------------------------
9 &lt;&lt; 2 (base 10) : 00000000000000000000000000100100 (base 2) = 36 (base 10)
</pre>

<p>Décaler un nombre <strong>x</strong> de <strong>y</strong> bits vers la gauche renverra <math><semantics><mrow><mi>x</mi><mo>*</mo><msup><mn>2</mn><mi>y</mi></msup></mrow><annotation encoding="TeX">x*2^y</annotation></semantics></math>. Par exemple,  <code>9 &lt;&lt; 3</code> correspondra à <code>9 * (2 ** 3) = 9 * 8 = 72</code>.</p>

<h3 id=">>_(décalage_à_droite_avec_propagation_du_signe)"><a name="Droite">&gt;&gt; (décalage à droite avec propagation du signe)</a></h3>

<p>Cet opérateur décale le premier opérande du nombre de bits spécifié vers la droite. Les bits surnuméraires éjectés à droite sont perdus. Des copies du bit le plus à gauche sont insérés par la gauche. Comme le bit le plus a gauche a la même valeur qu'avant l'opération, le bit de signe (celui qui est le plus à gauche) ne change pas. D'où ce qu'on appelle la « propagation du signe ».</p>

<p>Par exemple, <code>9 &gt;&gt; 2</code> donne 2 :</p>

<pre class="eval">     9 (base 10) : 00000000000000000000000000001001 (base 2)
                   --------------------------------
9 &gt;&gt; 2 (base 10) : 00000000000000000000000000000010 (base 2) = 2 (base 10)
</pre>

<p>De même, <code>-9 &gt;&gt; 2</code> donne -3, parce que le signe est préservé :</p>

<pre class="eval">     -9 (base 10) : 11111111111111111111111111110111 (base 2)
                    --------------------------------
-9 &gt;&gt; 2 (base 10) : 11111111111111111111111111111101 (base 2) = -3 (base 10)
</pre>

<h3 id=">>>_(décalage_à_droite_avec_insertion_de_zéros)"><a name="Droite_zero">&gt;&gt;&gt; (décalage à droite avec insertion de zéros)</a></h3>

<p>Cet opérateur décale le premier opérande du nombre de bits spécifié vers la droite. Les bits surnuméraires éjectés à droite sont perdus. Des bits à zéro sont insérés par la gauche. Le bit de signe devient 0, donc le résultat est toujours positif. À la différence des autres opérateurs binaires, cette opération renvoie un entier non-signé sur 32 bits.</p>

<p>Pour les nombres non négatifs, le décalage à droite avec insertion de zéros et le décalage à droite avec propagation du signe donnent le même résultat. Par exemple, <code>9 &gt;&gt;&gt; 2</code> donne 2, tout comme <code>9 &gt;&gt; 2</code> :</p>

<pre class="eval">      9 (base 10) : 00000000000000000000000000001001 (base 2)
                    --------------------------------
9 &gt;&gt;&gt; 2 (base 10) : 00000000000000000000000000000010 (base 2) = 2 (base 10)
</pre>

<p>Cependant, ce n'est pas le cas des nombres négatifs. Par exemple, <code>-9 &gt;&gt;&gt; 2</code> donne 1073741821, ce qui est différent de <code>-9 &gt;&gt; 2</code> (qui donne -3) :</p>

<pre class="eval">      -9 (base 10) : 11111111111111111111111111110111 (base 2)
                     --------------------------------
-9 &gt;&gt;&gt; 2 (base 10) : 00111111111111111111111111111101 (base 2) = 1073741821 (base 10)
</pre>

<h2 id="Exemples">Exemples</h2>

<h3 id="Exemple_flags_et_bitmasks">Exemple : <em>flags</em> et <em>bitmasks</em></h3>

<p>Les opérateurs logiques binaires sont souvent utilisés pour créer, manipuler et lire des séquences de<em>flags</em> , qui sont comme des variables binaires. On pourrait très bien utiliser des variables à la place de ces séquences binaires, mais des flags binaires prennent nettement moins de mémoire (par un facteur de 32).</p>

<p>Supposons que l'on ait 4 flags :</p>

<ul>
 <li>flag A : nous avons une araignée</li>
 <li>flag B : nous avons une belette</li>
 <li>flag C : nous avons un chat</li>
 <li>flag D : nous avons un dinosaure</li>
</ul>

<p>Ces flags sont représentés par une séquence de bits : DCBA. Lorsqu'un flag est <em>positionné</em>, il a une valeur de 1. Sinon, il a une valeur de 0. Supposons qu'une variable <code>flags</code> a la valeur binaire de 0101 :</p>

<pre class="eval">var flags = 0x5;   // 0101 en binaire
</pre>

<p>Cette valeur indique :</p>

<ul>
 <li>le flag A est vrai (nous avons une araignée) ;</li>
 <li>le flag B est faux (nous n'avons pas de belette) ;</li>
 <li>le flag C est vrai (nous avons un chat) ;</li>
 <li>le flag D est faux (nous n'avons pas de dinosaure).</li>
</ul>

<p>Comme les opérateurs binaires sont sur 32 bits, <code>0101</code> est en fait <code>00000000000000000000000000000101</code>, mais les zéros qui précèdent peuvent être négligés étant donné qu'ils ne contiennent aucune information significative.</p>

<p>Un <em>bitmask</em> est une séquence de bits qui peuvent manipuler et/ou lire des flags. Typiquement, un masque « primitif » pour chaque flag est défini :</p>

<pre class="eval">var FLAG_A = 0x1; // 0001
var FLAG_B = 0x2; // 0010
var FLAG_C = 0x4; // 0100
var FLAG_D = 0x8; // 1000
</pre>

<p>De nouveaux masques peuvent être créés à l'aide des opérateurs logiques binaires sur ces masques primitifs. Par exemple, le masque <code>1011</code> peut être créé avec une opération OU sur <code>FLAG_A</code>, <code>FLAG_B</code> et <code>FLAG_D</code> :</p>

<pre class="eval">var mask = FLAG_A | FLAG_B | FLAG_D; // 0001 | 0010 | 1000 =&gt; 1011
</pre>

<p>Des valeurs de flag particulières peuvent être extraites à l'aide d'une opération ET avec un bitmask, où chaque bit avec la valeur 1 va « extraire » le flag qui correspond. Le bitmask <em>masque</em> les flags dont on n'a pas besoin en effectuant l'opération ET avec des zéros (d'où le terme « bitmask »). Par exemple, le masque 0100 peut être utilisé pour voir si le flag C est positionné :</p>

<pre class="eval">// si l'on a un chat
if (flags &amp; FLAG_C) { // 0101 &amp; 0100 =&gt; 0100 =&gt; true
   // faire quelque chose
}
</pre>

<p>Un masque avec plusieurs flags positionnés agit comme un « et/ou ». Par exemple, les deux instructions suivantes sont équivalentes :</p>

<pre class="eval">// si on a une belette ou si on a un chat
if ((flags &amp; FLAG_B) || (flags &amp; FLAG_C)) { // (0101 &amp; 0010) || (0101 &amp; 0100) =&gt; 0000 || 0100 =&gt; true
   // faire quelque chose
}
</pre>

<pre class="eval">// si on a une belette ou si on a un chat
var mask = FLAG_B | FLAG_C; // 0010 | 0100 =&gt; 0110
if (flags &amp; mask) { // 0101 &amp; 0110 =&gt; 0100 =&gt; true
   // faire quelque chose
}
</pre>

<p>Les flags peuvent être positionnés en utilisant l'opération OU avec un masque, où chaque bit de la valeur 1 définira le flag correspondant, si celui-ci n'est pas déjà positionné. Par exemple, le masque 1100 peut être utilisé pour positionner les flags C et D :</p>

<pre class="eval">// oui, on a un chat et un dinosaure
var mask = FLAG_C | FLAG_D; // 0100 | 1000 =&gt; 1100
flags |= mask;   // 0101 | 1100 =&gt; 1101
</pre>

<p>Les flags peuvent être remis à zéro en utilisant l'opération ET avec un masque, où chaque bit avec la valeur 0 remettra à zéro le flag correspondant s'il ne l'est pas déjà. Ce masque peut être créé avec l'opération NOT sur les masques primitifs. Par exemple, le masque 1010 peut être utilisé pour remettre à zéro les flags A et C :</p>

<pre class="eval">// non, nous n'avons pas d'araignée ou de chat
var mask = ~(FLAG_A | FLAG_C); // ~0101 =&gt; 1010
flags &amp;= mask;   // 1101 &amp; 1010 =&gt; 1000
</pre>

<p>Le masque aurait également pu être créé avec <code>~FLAG_A &amp; ~FLAG_C</code> (Loi de De Morgan) :</p>

<pre class="eval">// non, nous n'avons pas d'araignée ou de chat
var mask = ~FLAG_A &amp; ~FLAG_C;
flags &amp;= mask;   // 1101 &amp; 1010 =&gt; 1000
</pre>

<p>Les flags peuvent être inversés en utilisant l'opération XOR avec un masque, où chaque bit avec la valeur 1 inversera le flag correspondant. Par exemple, le masque 0110 peut être utilisé pour inverser les flags B et C :</p>

<pre class="eval">// si on n'avait pas de belette, on en a maintenant une.
// si on en avait une, on ne l'a plus. Même chose pour les chats.
var mask = FLAG_B | FLAG_C;
flags = flags ^ mask;   // 1100 ^ 0110 =&gt; 1010
</pre>

<p>Finalement, les flags peuvent être tous inversés avec l'opérateur NON :</p>

<pre class="eval">// entrée dans un univers parallèle...
flags = ~flags;    // ~1010 =&gt; 0101
</pre>

<h3 id="Codes_de_conversion">Codes de conversion</h3>

<p>Pour convertir une <code><a href="/fr/docs/Web/JavaScript/Reference/Objets_globaux/String">String</a></code> binaire en un <code><a href="/fr/docs/Web/JavaScript/Reference/Objets_globaux/Number">Number</a></code> (en base 10):</p>

<pre class="brush: js">var chaîneBinaire = "1011";
var monNombre = parseInt(chaîneBinaire, 2);
console.log(monNombre); // affiche 11 (1011 en base 2)
</pre>

<p>Pour convertir un <code><a href="/fr/docs/Web/JavaScript/Reference/Objets_globaux/Number">Number</a></code> (en base 10) en une <code><a href="/fr/docs/Web/JavaScript/Reference/Objets_globaux/String">String</a></code> binaire :</p>

<pre class="brush: js">var monNombre = 11;
var chaîneBinaire = monNombre.toString(2);
console.log(chaîneBinaire); // affiche 1011 (11 en base 10)
</pre>

<h3 id="Automatiser_la_création_d'un_masque">Automatiser la création d'un masque</h3>

<p>Si vous devez créer plusieurs masques à partir de booléens, il est possible d'automatiser ce processus :</p>

<pre class="brush: js">function créerMasque () {
  var nMask = 0, nFlag = 0, nLen = arguments.length &gt; 32 ? 32 : arguments.length;
  for (nFlag; nFlag &lt; nLen; nMask |= arguments[nFlag] &lt;&lt; nFlag++);
  return nMask;
}
var masque1 = créerMasque(true, true, false, true); // 11, i.e.: 1011
var masque2 = créerMasque(false, false, true); // 4, i.e.: 0100
var masque3 = créerMasque(true); // 1, i.e.: 0001
// etc.

console.log(masque1); // affiche 11, i.e.: 1011
</pre>

<h3 id="Algorithme_réciproque_obtenir_un_tableau_de_booléen_à_partir_d'un_masque">Algorithme réciproque : obtenir un tableau de booléen à partir d'un masque</h3>

<p>Si on souhaite créer un tableau de booléens à partir d'un masque, on pourra utiliser le code suivant :</p>

<pre class="brush: js">function tableauMasque (nMask) {
  // nMask doit être compris entre -2147483648 et 2147483647
  if (nMask &gt; 0x7fffffff || nMask &lt; -0x80000000) {
    throw new TypeError("tableauMasque - intervalle de valeur dépassé");
  }
  for (var nShifted = nMask, aFromMask = []; nShifted;
       aFromMask.push(Boolean(nShifted &amp; 1)), nShifted &gt;&gt;&gt;= 1);
  return aFromMask;
}

var tableau1 = tableauMasque(11);
var tableau2 = tableauMasque(4);
var tableau3 = tableauMasque(1);

console.log("[" + tableau1.join(", ") + "]");
// affiche "[true, true, false, true]", i.e.: 11, i.e.: 1011
</pre>

<p>On peut ainsi utiliser les deux algorithmes :</p>

<pre class="brush: js">var test = 19; // un masque quelconque
var résultat = créerMasque.apply(this, tableauMasque(test));

console.log(résultat); // 19
</pre>

<p>Pour l'exemple (car il existe la méthode <code><a href="/fr/docs/Web/JavaScript/Reference/Objets_globaux/Number/toString">Number.toString(2)</a></code>), on peut également modifier l'algorithme précédent pour créer une chaîne à partir de la représentation binaire d'un nombre :</p>

<pre class="brush: js">function créerChaîneBinaire(nMask) {
  // nMask doit être compris entre -2147483648 et 2147483647
  for (var nFlag = 0, nShifted = nMask, sMask = ""; nFlag &lt; 32;
       nFlag++, sMask += String(nShifted &gt;&gt;&gt; 31), nShifted &lt;&lt;= 1);
  return sMask;
}

var string1 = créerChaîneBinaire(11);
var string2 = créerChaîneBinaire(4);
var string3 = créerChaîneBinaire(1);

console.log(string1);
// affiche 00000000000000000000000000001011, i.e. 11
</pre>

<h2 id="Spécifications">Spécifications</h2>

<table class="standard-table">
 <tbody>
  <tr>
   <th scope="col">Spécification</th>
   <th scope="col">Statut</th>
   <th scope="col">Commentaires</th>
  </tr>
  <tr>
   <td>{{SpecName('ES1')}}</td>
   <td>{{Spec2('ES1')}}</td>
   <td>Définition initiale.</td>
  </tr>
  <tr>
   <td>{{SpecName('ES5.1', '#sec-11.7')}}</td>
   <td>{{Spec2('ES5.1')}}</td>
   <td>Définis au sein de plusieurs sections de la spécification : <a href="http://www.ecma-international.org/ecma-262/5.1/#sec-11.4.8">Opérateur NON binaire</a>, <a href="http://www.ecma-international.org/ecma-262/5.1/#sec-11.7">Opérateurs binaires de décalage</a>, <a href="http://www.ecma-international.org/ecma-262/5.1/#sec-11.10">Opérateurs binaires</a></td>
  </tr>
  <tr>
   <td>{{SpecName('ES6', '#sec-bitwise-shift-operators')}}</td>
   <td>{{Spec2('ES6')}}</td>
   <td>Définis au sein de plusieurs sections de la spécification : <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-bitwise-not-operator">Opérateur NON binaire</a>, <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-bitwise-shift-operators">Opérateurs binaires de décalage</a>, <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-binary-bitwise-operators">Opérateurs binaires</a></td>
  </tr>
  <tr>
   <td>{{SpecName('ESDraft', '#sec-bitwise-shift-operators')}}</td>
   <td>{{Spec2('ESDraft')}}</td>
   <td>Defined in several sections of the specification: <a href="http://tc39.github.io/ecma262/#sec-bitwise-not-operator">opérateur NON binaire</a>, <a href="http://tc39.github.io/ecma262/#sec-bitwise-shift-operators">opérateurs binaires de décalage</a>, <a href="http://tc39.github.io/ecma262/#sec-binary-bitwise-operators">opérateurs binaires</a></td>
  </tr>
 </tbody>
</table>

<h2 id="Compatibilité_des_navigateurs">Compatibilité des navigateurs</h2>

<div class="hidden">Ce tableau de compatibilité a été généré à partir de données structurées. Si vous souhaitez contribuer à ces données, n'hésitez pas à envoyer une <em>pull request</em> sur <a href="https://github.com/mdn/browser-compat-data">https://github.com/mdn/browser-compat-data</a>.</div>

<p>{{Compat("javascript.operators.bitwise")}}</p>

<h2 id="Voir_aussi">Voir aussi</h2>

<ul>
 <li><a href="/fr/docs/Web/JavaScript/Reference/Opérateurs/Opérateurs_logiques">Les opérateurs logiques</a></li>
</ul>
