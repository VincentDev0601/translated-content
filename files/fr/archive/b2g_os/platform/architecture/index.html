---
title: Architecture de Firefox OS
slug: Archive/B2G_OS/Platform/Architecture
tags:
  - Architecture
  - Firefox OS
  - Guide
translation_of: Archive/B2G_OS/Architecture
---
<div class="summary">
<p><span class="seoSummary">Cet article est une vue d'ensemble de l'architecture de la plate-forme Firefox OS, présentant les concepts clés et expliquant sommairement comment les composants interagissent.</span></p>
</div>

<div class="note">
<p><strong>Note:</strong> Gardez à l'esprit que Firefox OS est toujours un produit non finalisé ("Pre-release"). L'architecture décrite ici n'est pas forcément finalisée, et des changements peuvent survenir.</p>
</div>

<h2 id="Terminologie_Firefox_OS">Terminologie Firefox OS</h2>

<p>Voici quelques termes à connaître avant de lire la suite de notre documentation de Firefox OS.</p>

<dl>
 <dt>B2G</dt>
 <dd>Acronyme de Boot to Gecko.</dd>
 <dt>Boot to Gecko</dt>
 <dd>Le nom de code du système d'exploitation Firefox OS lors de sa conception. Vous trouverez souvent ce terme en référence à Firefox OS, car il a été longtemps utilisé avant que le projet ait un nom officiel.</dd>
 <dt>Firefox OS</dt>
 <dd>Firefox OS correspond aux services de support et de branding de Mozilla (et ceux de ses partenaires OEM) ajoutés au-dessus de <strong>Boot to Gecko</strong>, pour créer un produit fini.</dd>
 <dt><a href="/fr/Firefox_OS/Platform/Gaia" title="/en-US/docs/Mozilla/Firefox_OS/Gaia">Gaia</a></dt>
 <dd>L'interface utilisateur de la plate-forme Firefox OS. Tout ce qui est affiché à l'écran une fois que Firefox OS est lancé, est produit par la couche Gaia. Gaia implémente l'écran de verrouillage, l'écran d'accueil et toutes les applications standards que vous attendez sur un smartphone moderne. Gaia est implémenté entièrement à l'aide de HTML, CSS et Javascript. Les seules interfaces avec le système d'exploitation sous-jacent se font au travers d'API Web libres, elles-mêmes implémentées par la couche Gecko. Les applications tierces peuvent être installées en parallèle de la couche Gaia.</dd>
 <dt><a href="/fr/docs/Gecko" title="/en-US/docs/Accessibility/AT-APIs/Gecko">Gecko</a></dt>
 <dd>C'est l'application permettant d'exécuter Firefox OS ; c'est-à-dire, la couche permettant le support des trois standards : HTML, CSS et Javascript. Il assure que chacune de ces technologies fonctionnent sur tous les systèmes d'exploitation supportés par Gecko. Cela signifie que Gecko inclut, entre autres, une pile réseau, une pile graphique, un<em> </em>moteur de présentation, une machine virtuelle JavaScript et des couches de portage.</dd>
 <dt><a href="/fr/Firefox_OS/Platform/Gonk" title="/en-US/docs/Mozilla/Firefox_OS/Gonk">Gonk</a></dt>
 <dd>Gonk représente la couche la plus basse du système d'exploitation de la plate-forme Firefox OS. Elle est composée d'un noyau Linux (basé sur l'<a href="http://source.android.com/">Android Open Source Project</a> (AOSP)) et une couche d'abstraction matérielle de l'espace utilisateur (HAL userspace). Le noyau et plusieurs bibliothèques en espace utilisateur font partie de projets open-source communs : Linux, libusb, bluez, et bien d'autres. D'autres parties de la HAL sont partagées avec l'AOSP : GPS, caméra et d'autres. Vous pouvez considérer Gonk comme une distribution Linux basique. Gonk est une <strong>cible de portage</strong> de Gecko, il y a un port de Gecko vers Gonk, tout comme il y a un port de Gecko vers OS X, Windows et Android. Vu que le projet Firefox OS a un contrôle total sur Gonk, nous pouvons exposer des objets à Gecko, qui ne peuvent être exposés sur d'autres systèmes d'exploitation. Par exemple, Gecko a un accès direct à la pile téléphonique complète et à l'affichage frame buffer sur Gonk, mais n'a pas ce type d'accès sur les autres systèmes d'exploitation.</dd>
 <dt><a name="Jank">Jank</a></dt>
 <dd>Ce terme est souvent utilisé dans l'univers du mobile, pour désigner une opération qui crée un effet de latence dans une application, qui bloque le rafraîchissement de l'interface, la fait laguer ou la rend inutilisable. Nos ingénieurs Gaia utilisent des techniques d'optimisation variées pour essayer d'éradiquer cette sensation à tout prix.</dd>
</dl>

<h2 id="Architecture_générale">Architecture générale</h2>

<p>Le schéma suivant compare les architectures de plate-formes propriétaires et de Firefox OS.</p>

<p><img alt="on the left is a native mobile architecture stack, on the right is the Firefox OS architecture. they are similarm except that the native stack is all proprietary device functionality, and the Firefox OS stack is all done with open source and web technologies." src="https://mdn.mozillademos.org/files/9487/general-architecture.png" style="display: block; height: 488px; margin: 0px auto; width: 997px;"></p>

<p>Firefox OS élimine la couche native de l'API entre le système d'exploitation et les couches applicatives. Ce design intégré réduit les couches au-dessus de la plate-forme et simplifie la sécurité sans sacrifier les performances ni l'expérience utilisateur.</p>

<ol>
 <li><a href="https://developer.mozilla.org/fr/Firefox_OS/Platform/Gaia">Gaia</a> est le noyau d'application web de l'appareil et la couche de l'interface utilisateur, en HMTL5, CSS et JavaScript, a<span id="result_box" lang="fr"><span class="hps">vec un certain nombre d'API</span> <span class="hps">exposées</span> <span class="hps">pour permettre</span> <span class="hps">le code</span> <span class="hps">de l'interface utilisateur</span> <span class="hps">d'interagir avec le</span> <span class="hps">matériel du téléphone</span> <span class="hps">et de fonctionnalité</span> de <span class="hps">Gecko</span><span>.</span></span></li>
 <li><a href="https://developer.mozilla.org/fr/docs/Gecko">Gecko</a> <span id="result_box" lang="fr"><span class="hps">est le</span> <span class="hps">moteur Web</span> <span class="hps">et la couche</span> <span class="hps">de présentation</span> <span class="hps">dans Firefox</span> <span class="hps">OS</span> <span class="hps">qui relie</span> le <span class="hps">matériel avec le</span> <span class="hps">HTML,</span> <span class="hps">en se servant de</span> <span class="hps">l'interface</span> <span class="hps">entre le contenu</span> <span class="hps">Web et le</span> <span class="hps">périphérique sous-jacent</span><span>.</span> <span class="hps">Gecko</span> <span class="hps">fournit une</span> <span class="hps">analyse</span> <span class="hps">HTML5 et</span> <span class="hps">un moteur de rendu</span><span>,</span> <span class="hps">l'accès</span> <span class="hps">programmatique</span> <span class="hps">à la fonctionnalité</span> <span class="hps">du matériel</span> <span class="hps">via des APIs</span> <span class="hps">Web</span> <span class="hps">sécurisés</span><span>,</span> <span class="hps">une infrastructure de sécurité intelligente</span><span>, la gestion</span> <span class="hps">de mise à jour</span><span>,</span> <span class="hps">et d'autres</span> <span class="hps">services de base</span><span>.</span></span></li>
 <li><a href="https://developer.mozilla.org/fr/Firefox_OS/Platform/Gonk">Gonk</a> <span id="result_box" lang="fr"><span class="hps">est</span> <span class="hps">la composante au</span> <span class="hps">niveau du noyau</span> <span class="hps">dans la pile</span> <span class="hps">de Firefox</span> <span class="hps">OS qui</span> <span class="hps">sert d'interface</span> <span class="hps">entre</span> <span class="hps">Gecko et le</span> <span class="hps">matériel </span></span><span lang="fr"><span class="hps">sous-jacent.</span> <span class="hps">Gonk</span> <span class="hps">contrôle le matériel</span> <span class="hps">sous-jacent et</span> <span class="hps">expose</span> les <span class="hps">capacités matérielles</span> <span class="hps">aux API</span> <span class="hps">Web</span> <span class="hps">mis en œuvre dans</span> <span class="hps">Gecko</span><span>.</span> <span class="hps">Gonk</span> <span class="hps">peut</span> <span class="hps">être considéré comme la</span> <span class="hps">«boîte noire»</span> <span class="hps">qui fait tout le</span> <span class="hps">travail complexe et</span> <span class="hps">détaillé</span> <span class="hps">dans les coulisses pour</span> <span class="hps">contrôler</span> <span class="hps">l'appareil mobile</span> <span class="hps">en adoptant</span> <span class="hps">la demande au</span> <span class="hps">niveau du matériel.</span></span></li>
 <li><span id="result_box" lang="fr"><span class="hps">Le dispositif</span> <span class="hps">mobile est le</span> <span class="hps">matériel du téléphone</span> <span class="hps">fonctionnant</span> avec <span class="hps">Firefox</span> <span class="hps">OS</span><span>.</span> <span class="atn hps">L'</span><span>OEM</span> <span class="hps">est responsable de fournir</span> <span class="hps">l'appareil mobile</span><span>.</span></span></li>
</ol>

<p> </p>

<h2 id="L'architecture_spécifique_de_Firefox_OS">L'architecture spécifique de Firefox OS</h2>

<p><img alt="Firefox OS Architecture" src="/files/4605/FirefoxOS.png" style="display: block; height: 915px; margin: 0px auto; width: 754px;"></p>

<h2 id="Déroulement_du_chargement_de_Firefox_OS">Déroulement du chargement de Firefox OS</h2>

<p>Cette section décrit le processus suivi lors de l'amorçage d'un matériel sous Firefox OS, quelles parties sont impliquées et où. Pour visualiser rapidement, le schéma d'amorçage général du système passe par le chargeur de boot dans l'espace noyau, à l'init du code natif, au B2G puis au tour de Gecko dans l'espace utilisateur, pour terminer par le système d'applications, le gestionnaire de fenêtres et enfin l'application d'accueil de Gecko. Toutes les autres applications vont venir s'appuyer là-dessus.</p>

<p><img alt="" src="https://mdn.mozillademos.org/files/7491/bootup.png" style="display: block; height: 1979px; margin: 0px auto; width: 2112px;"></p>

<h3 id="Le_processus_d'amorçage">Le processus d'amorçage</h3>

<p>Quand un appareil Firefox OS est allumé, l'exécution commence dans le premier chargeur d'amorçage. A partir de là, le processus de chargement du système d'exploitation principal se déroule d'une manière commune : une succession de chargeurs d'amorçage de niveaux de plus en plus hauts amorcent le chargeur suivant de la chaîne. A la fin du processus, l'exécution est transférée au noyau Linux.</p>

<p>Il y a plusieurs points à souligner à propos du processus d'amorçage :</p>

<ul>
 <li>Les chargeurs d'amorçage affichent souvent le premier écran d'accueil visualisé par l'utilisateur pendant le démarrage de l'appareil : habituellement c'est un logo marchand.</li>
 <li>Les chargeurs d'amorçage implémentent la projection d'une image sur l'appareil. Des appareils différents utilisent des protocoles différents ; la plupart des téléphones utilisent le <a href="http://android-dls.com/wiki/index.php?title=Fastboot" title="http://android-dls.com/wiki/index.php?title=Fastboot">protocole fastboot</a>, mais le Samsung Galaxy S II utilise le protocole odin.</li>
 <li>Vers la fin du processus d'amorçage, l'image du modem est la plupart du temps chargée et s'exécute sur le processeur du modem. La façon dont cela se produit est très spécifique à l'appareil et peut être propriétaire.</li>
</ul>

<h3 id="Le_noyau_Linux">Le noyau Linux</h3>

<p>Le noyau Linux utilisé par Gonk est très similaire au <u><strong>upstream </strong></u>Linux duquel il dérive (basé sur un <a href="http://source.android.com/" title="http://source.android.com/">projet Android Open Source</a>). Il y a quelques changements réalisés par l'AOSP qui n'ont pas encore été <u><strong>upstreamed</strong></u>. De plus, les marchands modifient parfois le noyau et upstream ces changements dans leur propre programme. En général, cependant, le noyau Linux et proche du <u><strong>stock.</strong></u></p>

<p>Le <a href="http://en.wikipedia.org/wiki/Linux_startup_process" title="http://en.wikipedia.org/wiki/Linux_startup_process">processus de démarrage pour Linux</a> est bien documenté ailleurs sur Internet et cet article ne couvrira donc pas ce point.</p>

<p>Le noyau Linux (ou kernel) va soulever des appareils et exécuter des processus essentiels. Il va exécuter des processus définis dans <code>init.rc</code> et le successeur <a href="https://github.com/mozilla-b2g/gonk-misc/blob/master/init.b2g.rc">init.b2g.rc</a> pour amorcer les processus essentiels comme <code>b2g</code> (le processus de base de FirefoxOS, qui contient Gecko) et <code>rild</code> (les processus relatifs à la téléphonie qui peuvent être propriétaires par différents jeux de puces) — voir ci-dessous pour plus de détails. A la fin du processus, un processus d'espace utilisateur <code>init</code> est lancé, comme dans la plupart des systèmes d'exploitation similaires à UNIX.</p>

<p>Dès que le processus <code>init</code> est lancé, le noyau Linux gère les appels système de l'espace utilisateur, et interrompt, et ainsi de suite les dispositifs matériels. Beaucoup de fonctions matérielles sont exposées à l'espace utilisateur au travers de <a href="http://en.wikipedia.org/wiki/Sysfs" title="http://en.wikipedia.org/wiki/Sysfs"><code>sysfs</code></a>. Par exemple, voici un <a href="https://github.com/cgjones/mozilla-central/blob/master/hal/gonk/GonkHal.cpp#L277" title="https://github.com/cgjones/mozilla-central/blob/master/hal/gonk/GonkHal.cpp#L277">bout de code</a> qui lit l'état de la batterie dans Gecko:</p>

<pre class="brush:cpp;"><code class="language-cpp">FILE <span class="operator token">*</span>capacityFile <span class="operator token">=</span> <span class="function token">fopen<span class="punctuation token">(</span></span><span class="string token">"/sys/class/power_supply/battery/capacity"</span><span class="punctuation token">,</span> <span class="string token">"r"</span><span class="punctuation token">)</span><span class="punctuation token">;</span>
double capacity <span class="operator token">=</span> dom<span class="punctuation token">:</span><span class="punctuation token">:</span>battery<span class="punctuation token">:</span><span class="punctuation token">:</span>kDefaultLevel <span class="operator token">*</span> <span class="number token">100</span><span class="punctuation token">;</span>
<span class="keyword token">if</span> <span class="punctuation token">(</span>capacityFile<span class="punctuation token">)</span> <span class="punctuation token">{</span>
  <span class="function token">fscanf<span class="punctuation token">(</span></span>capacityFile<span class="punctuation token">,</span> <span class="string token">"%lf"</span><span class="punctuation token">,</span> <span class="operator token">&amp;</span>capacity<span class="punctuation token">)</span><span class="punctuation token">;</span>
  <span class="function token">fclose<span class="punctuation token">(</span></span>capacityFile<span class="punctuation token">)</span><span class="punctuation token">;</span>
<span class="punctuation token">}</span></code></pre>

<h3 id="En_savoir_plus_sur_le_processus_init">En savoir plus sur le processus init</h3>

<p>Le processus <code>init</code> dans Gonk gère le montage des fichiers système requis et engendre les services système. Après, il reste autour pour servir de gestionnaire de processus. Ceci est assez similaire au init des autres systèmes d'exploitation ressemblant à UNIX. Il interprète des scripts (c'est-à-dire, les fichiers <code>init*.rc</code>) qui consistent en des commandes décrivant ce qui devrait être réalisé pour démarrer des services. Le <code>init.rc</code> de Firefox OS est habituellement le <u><strong>stock </strong></u><code>init.rc</code> d'Android pour l'appareil patché pour inclure les éléments nécessaires à la relance de Firefox OS. Il varie toutefois selon les appareils.</p>

<p>Une tâche clé que gère le processus <code>init</code> est le démarrage du processus <code>b2g</code> ; c'est le c<span style="background: transparent;">œ</span>ur du système d'exploitation Firefox OS.</p>

<p>Le code de <code>init.rc</code> qui démarre ceci ressemble à :</p>

<pre>service b2g /system/bin/b2g.sh
    class main
    onrestart restart media</pre>

<div class="note">
<p><strong>Note :</strong> Savoir exactement à quel point <code>init.rc</code> diffère de la version Android varie selon les appareils ; parfois, <code>init.b2g.rc</code> est simplement ajouté; parfois les patchs sont plus significatifs.</p>
</div>

<h2 id="L'architecture_des_processus_de_l'espace_utilisateur">L'architecture des processus de l'espace utilisateur</h2>

<p>A présent, il est utile d'avoir un regard de plus haut niveau sur la manière dont les composants multiples de Firefox OS s'imbriquent et interagissent entre eux. Le diagramme ci-dessous montre le principal processus de l'espace utilisateur de Firefox OS.</p>

<p><a href="/files/3849/B2G userspace architecture.svg"><img alt="Userspace diagram" src="/files/3849/B2G%20userspace%20architecture.svg" style="float: right; height: 491px; position: relative; width: 520px;"></a></p>

<div class="note">
<p><strong>Note :</strong> Gardez à l'esprit que depuis que Firefox OS est développé activement, le diagramme est susceptible de changer et pourrait ne pas être complètement exact.</p>
</div>

<p>Le processus <code>b2g</code> est le principal processus système. Il s'exécute avec de hauts privilèges ; il a accès à la plupart des matériels de l'appareil. <code>b2g</code> communique avec le modem, dessine le <strong><u>framebuffer </u></strong>affiché et échange avec les GPS, l'appareil photo et d'autres fonctions matérielles. De manière interne, <code>b2g</code> exécute la couche Gecko (implémentée par <code>libxul.so</code>). Voir <a href="#Gecko">Gecko</a> pour plus de détails sur la manière dont fonctionne la couche Gecko et comment <code>b2g</code> communique avec elle.</p>

<h3 id="b2g">b2g</h3>

<p>Le processus <code>b2g</code> peut à son tour déclencher un certain nombre de <strong>processus content </strong>à faibles privilèges. Ces processus sont l'endroit où les applications web et autres contenus web sont chargés. Ces processus communiquent avec le processus serveur principal Gecko avec le protocole <a href="/en-US/docs/IPDL" title="/en-US/docs/IPDL">IPDL</a>, un système de transmission de messages.</p>

<p>Le processus <code>b2g</code> exécute libxul, qui référence <code>b2g/app/b2g.js</code> pour obtenir les préférences par défaut. Avec ces préférences, il va ouvrir le ficher HTML <code>b2g/chrome/content/shell.html</code>, qui est compilé dans le fichier <code>omni.ja</code>.. <code>shell.html</code> inclut le fichier <code>b2g/chrome/content/shell.js</code>, qui déclenche l'application <code>system</code> de Gaia.</p>

<h3 id="rild">rild</h3>

<p>Le processus <code>rild</code> est l'interface du processeur du modem. <code>rild</code> est le démon qui implémente la couche de l'interface radio (<strong>Radio Interface Layer</strong> ou RIL). C'est un morceau de code propriétaire qui est implémenté par le fournisseur de matériel pour échanger avec le modem matériel. <code>rild</code> permet au code client de se connecter avec un socket UNIX auquel il se lie. Il commence par le code suivant dans le script d'<code>init</code> :</p>

<pre>service ril-daemon /system/bin/rild
    socket rild stream 660 root radio</pre>

<h3 id="rilproxy">rilproxy</h3>

<p>Dans Firefox OS, le client <code>rild</code> est le processus <code>rilproxy</code>. Il agit comme un simple proxy de transfert d'information entre <code>rild</code> et <code>b2g</code>. Ce proxy est nécessaire comme un détail d'implémentation ; il suffit de dire qu'il est en effet nécessaire. Le <a href="https://github.com/mozilla-b2g/rilproxy" title="https://github.com/mozilla-b2g/rilproxy">code<code> rilproxy</code> </a>est accessible sur GitHub.</p>

<h3 id="mediaserver">mediaserver</h3>

<p>Le processus <a href="https://github.com/android/platform_frameworks_base/tree/ics-mr0-release/media/libmediaplayerservice" title="https://github.com/android/platform_frameworks_base/tree/ics-mr0-release/media/libmediaplayerservice"><code>mediaserver</code></a> contrôle la lecture de l'audio et de la vidéo. Gecko échange avec lui à travers un mécanisme Android de Remote Procedure Call (RPC). Une partie des médias que Gecko peut lire (OGG Vorbis audio, OGG Theora video, et <a href="http://www.webmproject.org/about/" title="http://www.webmproject.org/about/">WebM</a> video) est décodée par Gecko et envoyée directement au processus <code>mediaserver</code>. Les autres fichiers média sont décodés par <code>libstagefright</code>, qui est capable d'accéder aux codecs propriétaires et aux encodeurs matériels.</p>

<div class="note">
<p><strong>Note :</strong> Le processus <code>mediaserver</code> est un composant "temporaire" de Firefox OS ; il est là pour nous aider dans notre travail initial de développement. Cependant, il est prévu qu'il disparaisse éventuellement. Toutefois, cela ne devrait pas se produire avant au moins la version 2.0 de Firefox OS.</p>
</div>

<h3 id="netd">netd</h3>

<p>Le processus <code>netd</code> est utilisé pour configurer les interfaces réseau.</p>

<h3 id="wpa_supplicant">wpa_supplicant</h3>

<p>Le processus <code>wpa_supplicant</code> est le démon UNIX-style standard qui gère la connectivité avec les points d'accès Wi-Fi.</p>

<h3 id="dbus-daemon">dbus-daemon</h3>

<p>Le processus dbus-daemon implémente <a href="http://www.freedesktop.org/wiki/Software/dbus" title="http://www.freedesktop.org/wiki/Software/dbus">D-Bus</a>, un système de bus de messages que Firefox OS utilise pour la communication Bluetooth.</p>

<h2 id="Gecko">Gecko</h2>

<p><a href="https://developer.mozilla.org/en-US/docs/Gecko" title="/en-US/docs/Gecko">Gecko</a>, comme mentionné précédemment, est une exécution de standards web (<a href="https://developer.mozilla.org/en-US/docs/HTML" title="/en-US/docs/HTML">HTML</a>, <a href="https://developer.mozilla.org/en-US/docs/CSS" title="/en-US/docs/CSS">CSS</a>, et <a href="https://developer.mozilla.org/en-US/docs/JavaScript" title="/en-US/docs/JavaScript">JavaScript</a>). Il est utilisé pour implémenter tout ce que voit l'utilisateur dans Firefox OS et pour contrôler les interactions avec le matériel du téléphone. Les applications Web connectent le HTML5 au matériel via des APIs Web contrôlées et sécurisées, implémentées dans Gecko. L'API Web fournit un accès informatisé aux fonctionnalités présentes dans le matériel sous-jacent de l'appareil mobile (comme la batterie ou la vibration), ainsi que les données stockées sur, ou disponibles pour, un périphérique (comme le calendrier ou les contacts). Le contenu Web appelle l'API Web accessible depuis HTML5.</p>

<p>Une application consiste en une collection de contenus web connexes HTML5. Pour construire des applications web qui s'exécutent sur des périphériques mobiles Firefox OS, les développeurs assemblent, emballent et distribuent simplement ce contenu web. Lors de l'exécution, ce contenu web est interprété, compilé et rendu dans un navigateur web. Pour plus d'informations sur les applications, voir le <a href="https://developer.mozilla.org/en-US/Apps">App Center</a>.</p>

<div class="note">
<p><strong>Note</strong> : Pour rechercher la base de code Gecko, vous pouvez utiliser <a href="http://dxr.mozilla.org">http://dxr.mozilla.org</a>. C'est plus "fancy" et cela fournit de bonnes fonctionnalités de référence, mais avec des répertoires limités. Ou vous pouvez essayer le traditionnel <a href="http://mxr.mozilla.org">http://mxr.mozilla.org</a>, qui regroupe plus de projets de Mozilla.</p>
</div>

<h3 id="Diagramme_d'architecture_Gecko">Diagramme d'architecture Gecko</h3>

<p><img alt="" src="https://mdn.mozillademos.org/files/5027/securityframework.png" style="height: 591px; width: 979px;"></p>

<ul>
 <li><strong>Framework de sécurité,</strong> contient

  <ul>
   <li><strong>Permission manager </strong>: porte d'entrée pour accéder à la fonctionnalité de l'API Web.</li>
   <li><strong>Access control list </strong>: matrice des rôles et des permissions requises pour accéder à la fonctionnalité de l'API Web.</li>
   <li><strong>Credential validation </strong>: authentification des applications/utilisateurs.</li>
   <li><strong>Permissions Store</strong> : ensemble des privilèges requis pour accéder à la fonctionnalité de l'APIWeb.</li>
  </ul>
 </li>
 <li><strong>Web API </strong>: ensemble d'APIs standards qui exposent les fonctionnalités matérielles au contenu web. Fournit des applications web avec des accès sécurisés aux fonctions contenues dans le matériel de l'appareil mobile sous-jacent, avec les données stockées sur - ou disponibles pour - l'appareil.</li>
 <li><strong>I/O </strong>: interface vers le matériel et le(s) magasin(s) de données.</li>
 <li><strong>Software Updates </strong>: obtiennent et installent les mises à jour sur le logiciel système et les applications tierces.</li>
 <li><strong>Content Layout &amp; Rendering</strong> : moteur qui passe, interprète et exécute le contenu web et, avec de l'information formatée, affiche le contenu formaté à l'utilisateur.</li>
 <li><strong>b2g process </strong>: (Gecko) exécute un processus système à hauts privilèges qui a accès aux fonctions matérielles du téléphone. Les applications en cours d'exécution sont des processus fils de b2g.</li>
</ul>

<h3 id="Fichiers_Gecko_en_rapport_avec_Firefox_OS">Fichiers Gecko en rapport avec Firefox OS</h3>

<h4 id="b2g_2">b2g/</h4>

<p>Le dossier b2g contient la plupart des fonctions en lien avec Firefox OS.</p>

<h5 id="b2gchromecontent">b2g/chrome/content</h5>

<p>Contient les fichiers JavaScript exécutés sur l'application système.</p>

<h5 id="b2gchromecontentshell.html">b2g/chrome/content/shell.html</h5>

<p>Le point d'entrée dans Gaia — le HTML pour l'application système <code>shell.html</code> arrive dans <code>settings.js</code> et <code>shell.js</code>:</p>

<pre class="brush: html">&lt;script type="application/javascript;version=1.8" src="chrome://browser/content/settings.js"&gt; &lt;/script&gt;
&lt;script type="application/javascript;version=1.8" src="chrome://browser/content/shell.js"&gt; &lt;/script&gt;</pre>

<p><code>settings.js</code> contient les paramètres par défaut de réglages du système.</p>

<h5 id="b2gchromecontentshell.js">b2g/chrome/content/shell.js</h5>

<p><code>shell.js</code> est le premier script à charger dans l'application <code>system</code> de Gaia.</p>

<p><code>shell.js</code> importe tous les modules requis, enregistre les écouteurs de touches, définit <code>sendCustomEvent</code> et <code>sendChromeEvent</code> pour communiquer avec Gaia et fournit des aides d'installation des webapps : quota indexedDB, RemoteDebugger, clavier auxiliaire et outil d'impression écran.</p>

<p>Mais la fonction la plus importante de <code>shell.js</code> est de lancer l'application <code>system</code> de Gaia, puis remettre l'ensemble du travail de gestion des systèmes à l'application <code>system</code> de Gaia.</p>

<pre class="brush: js">let systemAppFrame =
  document.createElementNS('http://www.w3.org/1999/xhtml', 'html:iframe');
    ...
  container.appendChild(systemAppFrame);</pre>

<h5 id="b2gappb2g.js">b2g/app/b2g.js</h5>

<p>Le script contient des paramètres prédéfinis -comme about:config dans un navigateur- et identique à pref.js de Gaia. Ces paramètres peuvent être modifiés depuis l'application Paramètres et peuvent être écrasés avec user.js dans le script de compilation de Gaia.</p>

<h4 id="domAPI">dom/{API}</h4>

<p>Des nouvelles implémentations de l'API (post-b2g) seront placées dans <code>dom/</code>. Des API plus vieilles seront placées dans <code>dom/base</code>, par exemple <code>Navigator.cpp</code>.</p>

<h5 id="domapps">dom/apps</h5>

<p><code>.jsm</code> sera chargé — les implementations de l'API <code>.js</code> comme <code>webapp.js </code> install, <code>getSelf</code>, etc.</p>

<h5 id="domappssrc">dom/apps/src/</h5>

<p><span class="short_text" id="result_box" lang="fr"><span class="hps">Toutes les autorisations</span> <span class="hps">sont définies</span></span> dans <a href="http://mxr.mozilla.org/mozilla-central/source/dom/apps/src/PermissionsTable.jsm">PermissionsTable.jsm</a></p>

<h4 id="domwebidl">dom/webidl</h4>

<p>WebIDL est le langage utilisé pour définir les APIs web. Pour les attributs supportés, lisez <a href="https://developer.mozilla.org/en-US/docs/Mozilla/WebIDL_bindings">WebIDL_bindings</a>.</p>

<h4 id="halgonk">hal/gonk</h4>

<p><span id="result_box" lang="fr"><span class="hps">Ce répertoire contient</span> <span class="hps">les fichiers liés à</span> <span class="hps">la couche</span> <span class="hps">de</span> <span class="hps">port</span> <span class="hps">gonk</span></span>.</p>

<h4 id="Les_fichiers_Générés"><span class="short_text" id="result_box" lang="fr"><span class="hps">Les fichiers Générés</span></span></h4>

<h5 id="modulelibprefsrcinitall.js">module/libpref/src/init/all.js</h5>

<p>Contient tous les fichiers de configuration.</p>

<h5 id="systemb2g_omni.ja_and_omni.js">/system/b2g/ omni.ja and omni.js</h5>

<p><span id="result_box" lang="fr"><span class="hps">Contient le</span> <span class="hps">pack de</span> <span class="hps">styles</span> <span class="hps">pour les ressources</span> <span class="hps">de l'appareil.</span></span></p>

<h3 id="Traitement_des_Événements_d'entrée"><span class="short_text" id="result_box" lang="fr"><span class="hps">Traitement des </span></span>É<span class="short_text" lang="fr"><span class="hps">vénements d'entrée</span><span class="hps"> </span></span></h3>

<p><span id="result_box" lang="fr"><span class="hps">La plupart des actions</span> <span class="hps">à l'intérieur de</span> <span class="hps">Gecko</span> sont <span class="hps">déclenchées par</span> <span class="hps">les actions de l'utilisateur</span><span>.</span> <span class="hps">Ces actions</span> <span class="hps">sont représentées par des</span> <span class="hps">événements d'entrée</span> <span class="atn hps">(</span><span>tels que les</span> <span class="hps">pressions de bouton</span><span>, touch</span><span class="hps">es</span></span><span lang="fr"> <span class="hps">à un</span> <span class="hps">appareil à écran tactile</span><span>,</span> <span class="hps">et ainsi de suite</span><span>)</span><span>.</span></span> Ces événements entrent dans le Gecko par la source <a href="https://dxr.mozilla.org/mozilla-central/source/widget/gonk/nsAppShell.cpp" rel="custom">Implementation de</a> de l'interface <code><a href="/fr/docs/Mozilla/Tech/XPCOM/Reference/Interface/nsIAppShell" title="">nsIAppShell</a></code>, une interface de Gecko qui est utilisée pour représenter les points principaux d'entrée pour une application de Gecko; c'est-à-dire le pilote du dispositif d'entrée appelle des méthodes sur l'objet <code>nsAppShell</code> qui représente le sous-système de Gecko pour envoyer des événements à l'interface utilisateur.</p>

<p>Par exemple :</p>

<pre class="brush:cpp;">void GeckoInputDispatcher::notifyKey(nsecs_t eventTime,
                                     int32_t deviceId,
                                     int32_t source,
                                     uint32_t policyFlags,
                                     int32_t action,
                                     int32_t flags,
                                     int32_t keyCode,
                                     int32_t scanCode,
                                     int32_t metaState,
                                     nsecs_t downTime) {
  UserInputData data;
  data.timeMs = nanosecsToMillisecs(eventTime);
  data.type = UserInputData::KEY_DATA;
  data.action = action;
  data.flags = flags;
  data.metaState = metaState;
  data.key.keyCode = keyCode;
  data.key.scanCode = scanCode;
  {
    MutexAutoLock lock(mQueueLock);
    mEventQueue.push(data);
  }
  gAppShell-&gt;NotifyNativeEvent();
}</pre>

<p><span id="result_box" lang="fr"><span class="hps">Ces événements</span> <span class="hps">viennent du</span> <span class="hps">système standard</span></span> <code>input_event</code> de Linux. <span id="result_box" lang="fr"><span class="hps">Firefox</span> <span class="hps">OS</span> <span class="hps">utilise une</span></span> <a href="https://dxr.mozilla.org/mozilla-central/source/widget/gonk/libui/InputReader.cpp" rel="custom">couche d'abstraction légère</a>, <span id="result_box" lang="fr"><span class="hps">celle-ci</span> <span class="hps">offre</span> <span class="hps">quelques fonctionnalités intéressantes comme</span> <span class="hps">le filtrage des événements</span><span>.</span> <span class="hps">Vous pouvez voir</span> <span class="hps">le code qui crée</span> <span class="hps">des événements d'entrée</span> <span class="hps">dans la méthode</span></span> <code>EventHub::getEvents()</code> dans <a href="https://dxr.mozilla.org/mozilla-central/source/widget/gonk/libui/EventHub.cpp" rel="custom">widget/gonk/libui/EventHub.cpp</a>.</p>

<p><span id="result_box" lang="fr"><span class="hps">Une fois que</span> <span class="hps">les événements</span> <span class="hps">sont reçus par</span> <span class="hps">Gecko</span><span>,</span> <span class="hps">ils sont</span> <span class="hps">expédiés</span> <span class="hps">dans</span> <span class="hps">le DOM</span> <span class="hps">par </span></span><code><a href="https://dxr.mozilla.org/mozilla-central/source/widget/gonk/nsAppShell.cpp" rel="custom">nsAppShell</a></code>:</p>

<pre class="brush:cpp;">static nsEventStatus sendKeyEventWithMsg(uint32_t keyCode,
                                         uint32_t msg,
                                         uint64_t timeMs,
                                         uint32_t flags) {
    nsKeyEvent event(true, msg, NULL);
    event.keyCode = keyCode;
    event.location = nsIDOMKeyEvent::DOM_KEY_LOCATION_MOBILE;
    event.time = timeMs;
    event.flags |= flags;
    return nsWindow::DispatchInputEvent(event);
}
</pre>

<p><span id="result_box" lang="fr"><span class="hps">Après cela</span><span>,</span> <span class="hps">les événements</span> <span class="hps">sont soit</span> <span class="hps">consommés par</span> <span class="hps">Gecko</span> <span class="hps">lui-même ou</span> <span class="hps">sont expédiés</span> <span class="hps">à des applications Web</span> en tant qu'<a href="/US/docs/DOM_Client_Object_Cross-Reference/DOM_Events"> </a><a href="https://developer.mozilla.org/en-US/docs/DOM_Client_Object_Cross-Reference/DOM_Events">événements DOM</a> <span class="hps">pour un traitement ultérieur</span><span>.</span></span></p>

<h3 id="Graphisme">Graphisme</h3>

<p><span id="result_box" lang="fr"><span class="hps">Au</span> <span class="hps">niveau le plus bas</span><span>,</span> <span class="hps">Gecko</span> <span class="hps">utilise <a href="http://www.khronos.org/opengles/2_X/">OpenGL ES 2.0</a></span> </span>pour dessiner<span lang="fr"> <span class="hps">un contexte</span> <span class="hps">GL</span> <span class="hps">qui enveloppe</span> <span class="hps">les</span> </span>tampons de trame<span lang="fr"> <span class="hps">de</span> <span class="hps">matériel.</span> <span class="hps">Cela se fait</span> <span class="hps">dans</span> <span class="hps">l'implémentation</span> <span class="hps">Gonk de</span></span><code> <a href="https://dxr.mozilla.org/mozilla-central/source/widget/gonk/nsWindow.cpp" rel="custom">nsWindow</a></code> <span class="short_text" id="result_box" lang="fr"><span class="hps">par</span> <span class="hps">un code similaire</span> <span class="hps">à ceci </span></span>:</p>

<pre class="brush:cpp;">gNativeWindow = new android::FramebufferNativeWindow();
sGLContext = GLContextProvider::CreateForWindow(this);</pre>

<p>La class <code>FramebufferNativeWindow</code> est apportée directement d'Android; voir <a href="https://github.com/android/platform_frameworks_base/blob/ics-mr1-release/libs/ui/FramebufferNativeWindow.cpp" title="https://github.com/android/platform_frameworks_base/blob/ics-mr1-release/libs/ui/FramebufferNativeWindow.cpp"><code>FramebufferNativeWindow.cpp</code></a>. Cette derni<span id="result_box" lang="fr"><span class="hps">è</span></span>re utilise l'API <strong>gralloc</strong> API <span id="result_box" lang="fr"><span class="hps">pour accéder au</span> <span class="hps">pilote graphique</span> dans l'optique de <span class="hps">repr</span></span>ésenter<span lang="fr"><span class="hps"> les tampons</span> <span class="hps">du dispositif de</span> <span class="hps">framebuffer</span> <span class="hps">dans la mémoire</span><span>.</span></span></p>

<p><span id="result_box" lang="fr"><span class="hps">Gecko</span> <span class="hps">utilise</span> <span class="hps">son système de</span> <a href="https://developer.mozilla.org/en-US/docs/Gecko/Layers">Couches</a> <span class="hps">au contenu</span> <span class="hps">composite </span></span><span lang="fr"><span class="hps">élaboré</span> <span class="hps">à l'écran</span><span>.</span> <span class="hps">En résumé</span><span>,</span> <span class="hps">voici ce qui se passe</span> <span class="hps">: </span></span></p>

<ol>
 <li>Gecko <span id="result_box" lang="fr"><span class="hps">dessine des régions distinctes</span> <span class="hps">de pages</span> <span class="hps">dans des tampons</span> de <span class="hps">mémoire</span></span>. <span id="result_box" lang="fr"><span class="hps">Parfois, ces</span> <span class="hps">tampons</span> <span class="hps">sont</span> <span class="hps">dans la mémoire système</span><span>;</span> <span class="hps">d'autres fois</span><span>, elles sont</span> <span class="hps">des textures</span> <span class="hps">mappées</span> <span class="hps">dans l'espace</span> <span class="hps">d'adresse de</span> <span class="hps">Gecko</span></span>,<span id="result_box" lang="fr"><span class="hps"> ce qui signifie que</span> <span class="hps">Gecko</span> dessine <span class="hps">directement dans la mémoire</span> <span class="hps">vidéo</span><span>.</span> <span class="hps">Cela se fait habituellement</span> <span class="hps">dans la m</span></span><span id="result_box" lang="fr"><span class="hps">éthode </span></span><a href="http://mxr.mozilla.org/mozilla-central/source/gfx/layers/basic/BasicThebesLayer.cpp#83" title="http://mxr.mozilla.org/mozilla-central/source/gfx/layers/basic/BasicThebesLayer.cpp#201"><code>BasicThebesLayer::PaintThebes()</code></a>.</li>
 <li>Gecko regroupe alors toutes ces textures à l'écran utilisant<span id="result_box" lang="fr"><span class="hps"> des commandes</span> <span class="hps">OpenGL</span></span>. <span id="result_box" lang="fr"><span class="hps">Cette composition</span> <span class="hps">se produit dans</span></span> <a href="http://mxr.mozilla.org/mozilla-central/source/gfx/layers/opengl/ThebesLayerOGL.cpp#124" title="http://mxr.mozilla.org/mozilla-central/source/gfx/layers/basic/BasicThebesLayer.cpp#201"><code>ThebesLayerOGL::RenderTo()</code></a>.</li>
</ol>

<p><span id="result_box" lang="fr"><span class="hps">Les</span> <span class="hps">détails sur</span> <span class="hps">la façon dont</span> <span class="hps">Gecko</span> <span class="hps">gère le</span> <span class="hps">rendu du contenu</span> <span class="hps">web sortent du cadre de</span><span class="hps"> ce document</span><span>.</span></span></p>

<h3 id="Couche_d'Abstraction_Matérielle_(HAL_)"><span class="short_text" id="result_box" lang="fr"><span class="hps">Couche d'Abstraction</span> M<span class="hps">atérielle</span></span> (HAL )</h3>

<p><span id="result_box" lang="fr"><span class="hps">La couche</span> <span class="hps">d'abstraction matérielle</span> <span class="hps">Gecko</span> <span class="hps">est</span> <span class="hps">l'une des couches</span> <span class="hps">de portage</span> <span class="hps">de</span> <span class="hps">Gecko</span><span>.</span> <span class="hps">Il gère</span> <span class="hps">l'accès</span> <span class="hps">de bas niveau</span> <span class="hps">aux interfaces</span> <span class="hps">du système</span> <span class="hps">à travers de multiples</span> <span class="hps">plate-formes utilisant</span> <span class="hps">une API</span> <span class="hps">C</span><span class="hps">++</span> <span class="hps">qui est accessible</span> <span class="hps">aux</span> plus hauts <span class="hps">niveaux de</span> <span class="hps">Gecko</span><span>.</span> <span class="hps">Ces API</span> <span class="hps">sont mises en œuvre</span> </span>selon la plate-forme à l'intérieur du Gecko HAL (Hardware Abstraction Layer) lui-même<span lang="fr"><span class="hps">.</span></span> Cette couche d'abstraction de matériel n'est pas exposée directement au code JavaScript dans Gecko --- <span id="result_box" lang="fr"><span class="hps">cette partie</span> <span class="hps">de l'interaction</span> <span class="hps">est assurée par</span> <span class="hps">les</span> <span class="hps">API Web</span><span>.</span></span></p>

<p><span id="result_box" lang="fr"><span class="hps">Regardons</span> <span class="hps">le processus</span> au haut<span class="hps"> niveau</span><span>.</span> <span class="hps">Quand un</span> <span class="hps">utilisateur effectue une demande</span> <span class="hps">pour utiliser une fonction</span> <span class="hps">du téléphone</span> <span class="hps">(comme</span> <span class="hps">composer un numéro</span><span>,</span> <span class="hps">accéder à un</span> <span class="hps">réseau Wi-Fi</span> <span class="hps">local,</span> <span class="hps">ou se connecter</span> <span class="hps">via Bluetooth</span><span>)</span><span>,</span> <span class="hps">toutes les couches</span> <span class="hps">de la pile</span> <span class="hps">de technologie</span> <span class="hps">Firefox</span> <span class="hps">OS</span> <span class="hps">sont impliquées</span> <span class="hps">dans la réalisation de</span> <span class="hps">la demande</span><span>.</span> <span class="hps">Les applications</span> <span class="hps">et</span> <span class="hps">le contenu</span> <span class="hps">web</span> <span class="hps">dans la couche</span> <span class="hps">Gaia</span> <span class="hps">soumettent des demandes</span> <span class="atn hps">d'accès à l'</span><span>appareil</span> <span class="hps">sous-jacent</span> <span class="hps">via des appels</span> <span class="hps">d'API</span> <span class="hps">Web</span> <span class="atn hps">(</span><span>appelées à partir de</span> <span class="hps">l'intérieur de</span> <span class="hps">fonctions</span> <span class="hps">HTML5</span><span>)</span><span>,</span> <span class="hps">qui sont</span> <span class="hps">mis en œuvre dans</span> <span class="hps">Gecko</span><span>.</span> <span class="hps">Gecko,</span> <span class="hps">à son tour,</span> <span class="hps">soumet la demande</span> <span class="hps">à Link</span><span>.</span> <span class="hps">Une seule demande</span> <span class="hps">de</span> <span class="hps">Gecko</span> <span class="hps">peut déclencher</span> <span class="hps">une série</span> <span class="hps">complexe d'opérations</span><span>,</span> <span class="hps">lancées et gérées par</span> <span class="hps">Gonk</span><span>,</span> <span class="hps">dans le téléphone mobile</span><span>.</span></span></p>

<h4 id="Comment_fonctionne_le_HAL"><span class="short_text" id="result_box" lang="fr"><span class="hps">Comment</span> <span class="hps">fonctionne</span> <span class="hps">le</span> <span class="hps">HAL</span></span></h4>

<p><span id="result_box" lang="fr"><span class="atn hps">Prenons l'</span><span class="hps">API</span></span> <a href="/fr/docs/Web/API/Window/navigator/vibrate" title="Cette documentation n'a pas encore été rédigée, vous pouvez aider en contribuant !"><code>Vibration</code></a><span lang="fr"> <span class="hps">comme exemple</span><span>.</span> <span class="hps">Le</span> <span class="hps">Gecko</span> <span class="hps">HAL</span> <span class="hps">pour cette</span> <span class="hps">API</span> <span class="hps">est défini dans</span> </span><a href="https://dxr.mozilla.org/mozilla-central/source/hal/Hal.h" rel="custom">hal/Hal.h</a><span lang="fr"><span>.</span> <span class="hps">En substance</span> <span class="atn hps">(</span><span>simplification de la</span> <span class="hps">signature de la méthode</span> <span class="hps">pour</span> <span class="hps">des raisons de clarté</span><span>)</span><span>,</span> <span class="hps">vous avez</span> <span class="hps">cette fonction</span><span> :</span></span></p>

<pre>void Vibrate(const nsTArray&lt;uint32&gt; &amp;pattern);</pre>

<p><span id="result_box" lang="fr"><span class="hps">Ceci est la</span> <span class="hps">fonction appelée</span> <span class="hps">par le code</span> <span class="hps">Gecko</span> <span class="hps">pour activer</span> <span class="hps">le</span> <span class="hps">dispositif</span> <span class="hps">de</span> <span class="hps">vibration</span> <span class="hps">en fonction de la</span> <span class="hps">configuration spécifiée</span><span>;</span> <span class="hps">une fonction correspondante</span> <span class="hps">existe</span> <span class="hps">pour annuler</span> <span class="hps">toute vibration</span> <span class="hps">continue</span><span>.</span> <span class="hps">La mise en </span></span>œ<span lang="fr"><span class="hps">uvre</span> <span class="hps">de ce procédé</span> <span class="hps">Gonk</span> <span class="hps">se trouve dans</span></span> <a href="https://dxr.mozilla.org/mozilla-central/source/hal/gonk/GonkHal.cpp" rel="custom">hal/gonk/GonkHal.cpp</a>:</p>

<pre class="brush:cpp;">void Vibrate(const nsTArray&lt;uint32_t&gt; &amp;pattern) {
  EnsureVibratorThreadInitialized();
  sVibratorRunnable-&gt;Vibrate(pattern);
}
</pre>

<p><span id="result_box" lang="fr"><span class="hps">Ce code</span> <span class="hps">envoie la demande pour</span><span class="hps"> faire vibrer le</span> <span class="hps">dispositif</span> <span class="hps">à un autre fil d'exécution</span><span>,</span> <span class="hps">qui est</span> <span class="hps">mis en œuvre dans </span></span> <code>VibratorRunnable::Run()</code>. <span id="result_box" lang="fr"><span class="hps">La boucle principale de</span> <span class="hps">ce fil</span> <span class="hps">ressemble à ceci :</span></span></p>

<pre class="brush:cpp;">while (!mShuttingDown) {
  if (mIndex &lt; mPattern.Length()) {
    uint32_t duration = mPattern[mIndex];
    if (mIndex % 2 == 0) {
      vibrator_on(duration);
    }
    mIndex++;
    mMonitor.Wait(PR_MillisecondsToInterval(duration));
  }
  else {
    mMonitor.Wait();
  }
}
</pre>

<p><code>vibrator_on()</code> <span id="result_box" lang="fr"><span class="hps">est</span> <span class="hps">l'API</span> <span class="hps">Gonk</span> <span class="hps">HAL</span> (<span class="hps">couche</span> <span class="hps">d'abstraction matérielle</span></span><span lang="fr">) <span class="hps">qui tourne sur</span> <span class="hps">le moteur vibrant</span><span>.</span> <span class="hps">En interne,</span> <span class="hps">cette méthode</span> <span class="hps">envoie un message</span> <span class="hps">au pilote </span><span class="hps">du noyau</span> <span class="hps">en écrivant une valeur</span> <span class="hps">à un objet</span> <span class="hps">de</span> <span class="hps">noyau utilisant </span></span> <code>sysfs</code>.</p>

<h4 id="Alternatives_aux_implémentations_de_l'API_HAL">Alternatives aux impl<span class="short_text" id="result_box" lang="fr"><span class="hps">é</span></span>mentations de l'API HAL</h4>

<p><span id="result_box" lang="fr"><span class="hps">Les</span> <span class="hps">APIs </span></span><span lang="fr"><span class="hps">HAL Gecko</span> <span class="hps">sont prises en charge</span> <span class="hps">sur toutes les plate-formes</span><span>.</span> <span class="hps">Quand</span> <span class="hps">Gecko</span> <span class="hps">est compil</span></span><span class="short_text" id="result_box" lang="fr"><span class="hps">é</span></span><span lang="fr"><span class="hps"> pour</span> <span class="hps">une</span> <span class="hps">plate-forme</span> <span class="hps">qui ne</span> <span class="hps">dispose pas</span> d'<span class="hps">une interface</span> <span class="hps">de</span> <span class="hps">moteurs vibrants</span> <span class="hps">(comme</span> <span class="hps">un ordinateur de bureau</span><span>), alors une</span> alternative <span class="hps">à l'impl</span></span><span class="short_text" id="result_box" lang="fr"><span class="hps">é</span></span><span lang="fr"><span class="hps">mentation</span> <span class="hps">de</span> <span class="hps">l'API</span> <span class="hps">HAL</span> <span class="hps">est utilisée.</span> <span class="hps">Pour les vibrations</span><span>,</span> <span class="hps">cela est</span> <span class="hps">mis en œuvre dans</span></span> <a href="https://dxr.mozilla.org/mozilla-central/source/hal/fallback/FallbackVibration.cpp" rel="custom">hal/fallback/FallbackVibration.cpp</a>.</p>

<pre class="brush:cpp;">void Vibrate(const nsTArray&lt;uint32_t&gt; &amp;pattern) {
}</pre>

<h4 id="Implémentations_Sandbox">Impl<span class="short_text" id="result_box" lang="fr"><span class="hps">é</span></span>mentations Sandbox</h4>

<p><span id="result_box" lang="fr"><span class="hps">Parce que</span> <span class="hps">la plupart des contenus</span> <span class="hps">web fonctionne</span> <span class="hps">dans les processus</span> <span class="hps">de contenu</span> <span class="hps">avec</span> <span class="hps">des privilèges faibles</span><span>,</span> <span class="hps">nous ne pouvons pas</span> <span class="hps">assumer que ces</span> <span class="hps">processus</span> <span class="hps">ont les</span> <span class="hps">privilèges nécessaires pour</span> <span class="hps">être en mesure, </span><span>par exemple</span><span>,</span> d'<span class="hps">allumer et éteindre</span> <span class="hps">le moteur</span> <span class="hps">de vibration</span><span>.</span> <span class="hps">De plus,</span> <span class="hps">nous voulons avoir</span> <span class="hps">un emplacement central</span> <span class="hps">pour le traitement des</span> <span class="hps">conditions de course</span> <span class="hps">potentielles</span><span>.</span> <span class="hps">Dans le</span> <span class="hps">Gecko</span> <span class="hps">HAL</span><span>, cela se fait</span> <span class="hps">à travers une</span> <span class="hps">mise en œuvre</span> <span class="atn hps">«</span><span>sandbox</span><span>» de la</span> <span class="hps">HAL</span><span>.</span> <span class="hps">Cette mise en œuvre</span> <span class="hps">sandbox</span> <span class="hps">proxie</span> <span class="hps">simplement</span> <span class="hps">des demandes formulées</span> <span class="hps">par des procédés</span> <span class="hps">de contenu</span> <span class="hps">et les transmet</span> <span class="hps">au processus</span> <span class="hps">du "serveur</span> <span class="hps">Gecko</span><span>"</span><span>.</span> <span class="hps">Les</span> <span class="hps">demandes de proxy</span> <span class="hps">sont envoyés en utilisant</span> </span>IPDL<span lang="fr"><span>.</span></span></p>

<p><span class="short_text" id="result_box" lang="fr"><span class="hps">Pour les vibrations</span><span>,</span> <span class="hps">cela est géré</span> <span class="hps">par la fonction</span></span> <code>Vibrate()</code> implément<span id="result_box" lang="fr"><span class="hps">é dans </span></span> <a href="https://dxr.mozilla.org/mozilla-central/source/hal/sandbox/SandboxHal.cpp" rel="custom">hal/sandbox/SandboxHal.cpp</a>:</p>

<pre class="brush:cpp;">void Vibrate(const nsTArray&lt;uint32_t&gt;&amp; pattern, const WindowIdentifier &amp;id) {
  AutoInfallibleTArray&lt;uint32_t, 8&gt; p(pattern);

  WindowIdentifier newID(id);
  newID.AppendProcessID();
  Hal()-&gt;SendVibrate(p, newID.AsArray(), GetTabChildFrom(newID.GetWindow()));
}</pre>

<p><span id="result_box" lang="fr"><span class="hps">Cela envoie</span> <span class="hps">un message défini</span> <span class="hps">par</span> <span class="hps">l'interface</span></span> <code>PHal</code>,<span class="short_text" id="result_box" lang="fr"><span class="hps"><code> </code>décrit par </span></span>IPDL dans <a href="https://dxr.mozilla.org/mozilla-central/source/hal/sandbox/PHal.ipdl" rel="custom">hal/sandbox/PHal.ipdl</a>. <span class="short_text" id="result_box" lang="fr"><span class="hps">Cette méthode est décrite</span> <span class="hps">plus ou moins</span> <span class="hps">comme suit </span></span>:</p>

<pre>Vibrate(uint32_t[] pattern);</pre>

<p><span class="short_text" id="result_box" lang="fr"><span class="hps">Le</span> <span class="hps">destinataire de ce message</span> <span class="hps">est la m</span></span><span id="result_box" lang="fr"><span class="hps">é</span></span><span class="short_text" lang="fr"><span class="hps">thode </span></span><code>HalParent::RecvVibrate()</code> dans <a href="https://dxr.mozilla.org/mozilla-central/source/hal/sandbox/SandboxHal.cpp" rel="custom">hal/sandbox/SandboxHal.cpp</a>, <span class="short_text" id="result_box" lang="fr"><span class="hps">qui</span> <span class="hps">ressemble à ceci </span></span>:</p>

<pre class="brush:cpp;">virtual bool RecvVibrate(const InfallibleTArray&lt;unsigned int&gt;&amp; pattern,
            const InfallibleTArray&lt;uint64_t&gt; &amp;id,
            PBrowserParent *browserParent) MOZ_OVERRIDE {

  hal::Vibrate(pattern, newID);
  return true;
}</pre>

<p><span id="result_box" lang="fr"><span class="hps">Ceci</span> <span class="hps">omet</span> <span class="hps">certains détails</span> <span class="hps">qui ne sont pas</span> <span class="hps">appropriés à cette</span> documentation<span>;</span> <span class="hps">Cependant</span><span>, il montre comment</span> <span class="hps">le message</span> <span class="hps">progresse</span> <span class="hps">d'un contenu</span></span><span lang="fr"><span class="hps"> de processus</span> <span class="hps">de</span> <span class="hps">Gecko</span> <span class="hps">à</span> <span class="hps">Gonk</span><span>, puis à</span> <span class="hps">la mise en œuvre</span> <span class="hps">du</span> <span class="hps">HAL</span> de <span class="hps">Gonk</span> </span> <code>Vibrate()</code><span lang="fr"> <span class="hps">et finalement</span> <span class="hps">au pilote </span><span class="hps">de vibration</span><span>.</span></span></p>

<h3 id="Les_API_DOM"><span class="short_text" id="result_box" lang="fr"><span class="hps">Les API DOM</span></span></h3>

<p>Les interfaces du DOM sont, en substance, comment le contenu Web communique avec Gecko. Ils sont plus impliqués que cela et si vous êtes intéressés par des détails supplémentaires, vous pouvez lire <a href="https://developer.mozilla.org/fr/docs/Web/Guide/DOM">la documentation sur le DOM</a>. Les interfaces du DOM sont définies en utilisant <a href="https://developer.mozilla.org/fr/docs/XPIDL">IDL</a>, qui comprend aussi bien l'interface de fonction étrangère (FFI) que le modèle d'objet (OM) entre le JavaScript et C++.</p>

<p><span id="result_box" lang="fr"><span class="hps">L'API de</span> <span class="hps">vibration</span> <span class="hps">est exposée</span> <span class="hps">au contenu web</span><span class="hps"> à travers</span> <span class="hps">une interface</span> <span class="hps">IDL</span><span>,</span> <span class="hps">qui est prévue dans</span></span><code> <a href="https://dxr.mozilla.org/mozilla-central/source/dom/interfaces/base/nsIDOMNavigator.idl" rel="custom">nsIDOMNavigator.idl</a>:</code></p>

<pre>[implicit_jscontext] void mozVibrate(in jsval aPattern);</pre>

<p>L'argument <a href="/en-US/docs/SpiderMonkey/JSAPI_Reference/Jsval" title="/en-US/docs/SpiderMonkey/JSAPI_Reference/JSVAL_IS_OBJECT"><code>jsval</code></a> indique que <code>mozVibrate()</code> (<span id="result_box" lang="fr"><span class="hps">qui est</span> <span class="hps">notre implémentation</span> <span class="hps">du</span> <span class="hps">fournisseur</span> <span class="hps">préfixée</span> <span class="hps">de cette spécification</span> <span class="hps">de</span> <span class="hps">vibrations</span> <span class="hps">non</span><span class="atn">-</span><span>finalisé</span></span>) <span class="short_text" id="result_box" lang="fr"><span class="hps">accepte</span> <span class="hps">en entrée</span> <span class="hps">toute</span> <span class="hps">valeur</span> <span class="hps">JavaScript</span></span>. Le compilateur IDL, <a href="/en-US/docs/XPIDL/xpidl" title="/en-US/docs/XPIDL/xpidl"><code>xpidl</code></a>, <span id="result_box" lang="fr"><span class="hps">génère</span> <span class="hps">une interface</span> <span class="hps">C</span><span class="hps">++</span> <span class="hps">qui est</span> <span class="hps">ensuite mise en œuvre</span> <span class="hps">par la classe</span> </span> <code>Navigator </code><span lang="fr"> <span class="hps">dans </span></span><code><a href="https://dxr.mozilla.org/mozilla-central/source/dom/base/Navigator.cpp" rel="custom">Navigator.cpp</a></code>.</p>

<pre class="brush:cpp;">NS_IMETHODIMP Navigator::MozVibrate(const jsval&amp; aPattern, JSContext* cx) {
  // ...
  hal::Vibrate(pattern);
  return NS_OK;
}</pre>

<p>Il y a beaucoup plus de code dans cette méthode que ce que vous voyez ici, mais ce n'est pas important pour le but de cette documentation. Le fait est que l'appel à hal::Vibrate() le contrôle de transferts du DOM au HAL de Gecko. De là, nous entrons dans la mise en œuvre du HAL discutée dans la section précédente et nous frayons un chemin vers le pilote graphique. Par-dessus tout, la mise en œuvre du DOM ne se soucie pas du tout sur quelle plate-forme il est exécuté (Gonk, Windows, OS X, ou autre chose). Il ne se soucie pas non-plus si le code fonctionne dans un processus de contenu ou dans le processus serveur de Gecko. Ces détails sont tous laissés à des niveaux inférieurs du système à traiter.</p>

<p><span lang="fr"><span class="hps">L'API de vibration est une API très simple, ce qui en fait un bon exemple. L'<a href="/fr/docs/WebAPI/WebSMS">API </a></span><a href="/fr/docs/WebAPI/WebSMS"><span class="hps">SMS</span></a> <span class="hps">est un exemple d'une API plus complexe qui utilise sa propre couche "d'accès distant" reliant les processus de contenu au serveur.</span></span></p>

<h2 id="Couche_d'Interface_Radio_(RIL)"><span class="short_text" id="result_box" lang="fr"><span class="hps">Couche</span> <span class="hps">d'Interface Radio</span></span> (RIL)</h2>

<p>La Couche d'Interface Radio, ou RIL pour Radio Interface Layer en Anglais a été mentionnée dans la section <a href="#L'architecture_des_processus_de_l'espace_utilisateur_">L'architecture des processus de l'espace utilisateur </a>. Cette section examinera un peu plus de détail la manière dont les différents éléments de cette couche interagissent.</p>

<p><span lang="fr"><span class="hps">Les principaux composants impliqués dans la RIL sont :</span></span></p>

<dl>
 <dt><code>rild</code></dt>
 <dd><span lang="fr"><span class="hps">Chargé de communiquer avec le firmware modem propriétaire.</span></span></dd>
 <dt><code>rilproxy</code></dt>
 <dd><span lang="fr"><span class="hps">Qui proxie les messages entre rild et Gecko (lequel est mis en œuvre dans le processus de b2g). Ceci résout le problème d'autorisation qui se pose lorsque vous essayez de parler à rild directement, lorsque rild ne peut être communiquée à l'intérieur du groupe de radio.</span></span></dd>
 <dt><code>b2g</code></dt>
</dl>

<p><span lang="fr"><span class="hps">Ce processus, également connu comme le procédé chrome, implémente Gecko. Les parties de celui-ci qui se rapportent à la couche d'interface radio sont <a href="https://dxr.mozilla.org/mozilla-central/source/dom/system/gonk/ril_worker.js" rel="custom">dom/system/gonk/ril_worker.js</a> qui mettent en œuvre un thread (fil) de travail qui communique avec rild par le biais de rilproxy et implémentent la machine d'état de la radio; et l' <code><a href="/fr/docs/Mozilla/Tech/XPCOM/Reference/Interface/nsIRadioInterfaceLayer" title="">nsIRadioInterfaceLayer</a></code> interface, qui est le service principal </span><a href="/fr/docs/XPCOM">XPCOM</a> <span class="hps">du thread qui agit principalement comme un échange de messages entre le thread ril_worker.js et divers autres composants Gecko, y compris le processus contenu Gecko.</span></span></p>

<dl>
 <dt><span class="short_text" id="result_box" lang="fr"><span class="hps">Processus</span> <span class="hps">du contenu</span> <span class="hps">de</span> <span class="hps">Gecko</span></span></dt>
</dl>

<p><span lang="fr"><span class="hps">Au sein du processus du contenu de Gecko, l' <code><a href="/fr/docs/Mozilla/Tech/XPCOM/Reference/Interface/nsIRILContentHelper" title="">nsIRILContentHelper</a></code> interface fournit un service de XPCOM qui laisse le code mettant en œuvre les parties de DOM, comme la</span></span> <a href="/fr/docs/Web/Guide/Telephony">Téléphonie</a> et les APIs de <a href="/fr/docs/WebAPI/WebSMS">SMS</a>, communiquer avec l'interface de la radio, qui est dans le processus chrome., communiquer avec l'interface de la radio, qui est dans le processus chrome.</p>

<h3 id="Exemple_Communication_du_rild_au_DOM"><span class="short_text" id="result_box" lang="fr"><span class="hps">Exemple:</span> <span class="hps">Communication</span> <span class="hps">du</span> <span class="hps">rild</span> <span class="hps">au DOM</span></span></h3>

<p><span lang="fr"><span class="hps">Jetons un </span></span>œ<span lang="fr"><span class="hps">il à un exemple de la façon dont les parties de niveau inférieur du système communiquent avec le code DOM. Lorsque le modem reçoit un appel entrant, il notifie au rild en utilisant un mécanisme propriétaire. rild prépare alors un message pour son client selon le protocole «ouvert», qui est décrit dans</span></span><span class="short_text" id="result_box" lang="fr"> </span><a href="https://github.com/mozilla-b2g/android-hardware-ril/blob/master/include/telephony/ril.h">ril.h. </a><span lang="fr"><span class="hps">Dans le cas d'un appel entrant, un message</span> </span><code>RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED</code> est généré et envoyé par<span lang="fr"> </span><code>rild</code><span lang="fr"> <span class="hps">à</span> </span><code>rilproxy</code>.</p>

<p>rilproxy, implémenté dans le <a href="https://github.com/mozilla-b2g/rilproxy/blob/master/src/rilproxy.c">rilproxy.c</a>, reçoit ce message dans sa boucle principale, qui sonde sa connexion à<span id="result_box" lang="fr"> </span><code>rild</code><span lang="fr"> <span class="hps">en utilisant le code suivant :</span></span></p>

<pre class="brush:cpp;">ret = read(rilproxy_rw, data, 1024);

if(ret &gt; 0) {
  writeToSocket(rild_rw, data, ret);
}</pre>

<p><span id="result_box" lang="fr"><span class="hps">Une fois le message</span> <span class="hps">reçu de</span> </span><code>rild</code><span lang="fr"><span>,</span> <span class="hps">il est</span> <span class="hps">ensuite </span></span>expédié<span lang="fr"><span class="hps"> le long</span> <span class="hps">de</span> <span class="hps">Gecko</span> <span class="hps">sur la</span> <span class="hps">prise</span> <span class="hps">qui relie</span> </span><code>rilproxy </code><span lang="fr"><span class="hps">Gecko</span><span>.</span> <span class="hps">Gecko</span> <span class="hps">reçoit le message</span> <span class="hps">transmis</span> <span class="hps">sur son </span></span><a href="https://dxr.mozilla.org/mozilla-central/source/ipc/ril/Ril.cpp" rel="custom">IPC thread</a>:</p>

<pre class="brush:cpp;">int ret = read(fd, mIncoming-&gt;Data, 1024);
// ... <span class="short_text" id="result_box" lang="fr"><span class="alt-edited hps">gestion des erreurs</span></span> ...
mIncoming-&gt;mSize = ret;
sConsumer-&gt;MessageReceived(mIncoming.forget());
</pre>

<p><span class="short_text" id="result_box" lang="fr"><span class="hps">Le consommateur</span> <span class="hps">de ces messages</span> <span class="hps">est </span></span><a href="https://dxr.mozilla.org/mozilla-central/source/dom/system/gonk/SystemWorkerManager.cpp" rel="custom">SystemWorkerManager</a>, <span class="short_text" id="result_box" lang="fr"><span class="hps">qui</span> <span class="hps">reconditionne</span> <span class="hps">les</span> <span class="hps">messages</span> <span class="hps">et</span> <span class="hps">les envoie</span> <span class="hps">au </span></span><code><a href="https://dxr.mozilla.org/mozilla-central/source/dom/system/gonk/ril_worker.js" rel="custom">ril_worker.js</a> </code>thread <span id="result_box" lang="fr"><span class="hps">qui implémente </span><span class="hps">la machine d'état</span> <span class="hps">RIL</span><span>;</span> <span class="hps">ceci est fait</span> <span class="hps">dans la méthode </span></span><span lang="fr"> </span><code>RILReceiver::MessageReceived()</code><span lang="fr"> <span class="hps">:</span></span></p>

<pre class="brush:cpp;">virtual void MessageReceived(RilRawData *aMessage) {
  nsRefPtr&lt;DispatchRILEvent&gt; dre(new DispatchRILEvent(aMessage));
  mDispatcher-&gt;PostTask(dre);
}</pre>

<p><span id="result_box" lang="fr"><span class="hps">La tâche</span> <span class="hps">postée</span> <span class="hps">à</span> <span class="hps">ce thread</span> <span class="hps">appelle à son tour</span> <span class="hps">la fonction</span> </span><code>onRILMessage()</code><span lang="fr"><span>,</span> <span class="hps">qui est</span> <span class="hps">impl</span></span><span id="result_box" lang="fr"><span class="hps">é</span></span><span lang="fr"><span class="hps">ment</span></span><span id="result_box" lang="fr"><span class="hps">é</span></span><span lang="fr"><span class="hps">e en</span> <span class="hps">JavaScript</span><span>.</span> <span class="hps">Ceci est fait</span> <span class="hps">en utilisant</span> <span class="hps">la fonction API</span> <span class="hps">JavaScript</span></span> <a href="/fr/docs/Référence_de_JSAPI/JS_CallFunction">JS_CallFunctionName()</a>:</p>

<pre>return JS_CallFunctionName(aCx, obj, "onRILMessage", NS_ARRAY_LENGTH(argv),
                           argv, argv);</pre>

<p><code>onRILMessage()</code> <span class="short_text" id="result_box" lang="fr"><span class="hps">est mis en </span></span>œ<span class="short_text" lang="fr"><span class="hps">uvre</span> <span class="hps">dans</span></span> <a href="https://dxr.mozilla.org/mozilla-central/source/dom/system/gonk/ril_worker.js" rel="custom">dom/system/gonk/ril_worker.js</a>, <span id="result_box" lang="fr"><span class="hps">qui</span> <span class="hps">traite le message</span> <span class="hps">octets</span> <span class="hps">et</span> <span class="hps">les</span> d<span class="hps">é</span></span><span lang="fr">coupe <span class="hps">en parcelles</span><span>.</span> <span class="hps">Chaque colis</span> <span class="hps">complet est ensuite</span> <span class="hps">envoyé à</span> <span class="hps">des méthodes de gestionnaire</span> <span class="hps">individuelles</span><span>, le cas échéant</span><span>:</span></span></p>

<pre class="brush:js;">handleParcel: function handleParcel(request_type, length) {
  let method = this[request_type];
  if (typeof method == "function") {
    if (DEBUG) debug("Handling parcel as " + method.name);
    method.call(this, length);
  }
}
</pre>

<p><span id="result_box" lang="fr"><span class="hps">Ce code</span> <span class="hps">fonctionne en récupérant</span> <span class="hps">le type</span> <span class="hps">de demande </span></span><span lang="fr"><span class="hps">de l'objet</span><span>,</span> <span class="hps">en s'assurant qu'il</span> soit<span class="hps"> défini comme</span> <span class="hps">une fonction</span> <span class="hps">dans le code</span> <span class="hps">JavaScript, </span></span>appelant ensuite la méthode. <span id="result_box" lang="fr"><span class="hps">Depuis</span> </span>ril_worker.js<span lang="fr"> <span class="hps">met en œuvre</span> <span class="hps">chaque type</span> <span class="hps">de demande</span> <span class="hps">dans une</span> <span class="hps">méthode donnée, le</span> <span class="hps">même nom que le</span> <span class="hps">type de demande</span><span>,</span> <span class="hps">ce qui est très</span> <span class="hps">simple.</span></span></p>

<p>Dans notre exemple, <code>RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED</code>, le code suivant est appelé:</p>

<pre class="brush:js;">RIL[UNSOLICITED_RESPONSE_CALL_STATE_CHANGED] = function UNSOLICITED_RESPONSE_CALL_STATE_CHANGED() {
  this.getCurrentCalls();
};</pre>

<p>Comme vous pouvez le voir dans le code ci-dessus, quand une notification est reçue indiquant que le call state a changé, la state machine récupère le call state courant en appelant la méthode <code>getCurrentCall()</code>:</p>

<pre class="brush:js;">getCurrentCalls: function getCurrentCalls() {
  Buf.simpleRequest(REQUEST_GET_CURRENT_CALLS);
}</pre>

<p>Cela envoie une request back à <code>rild</code> pour demander l'état de tous les appels actifs à l'instant. The request flows back along a similar path the <code>RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED</code> message followed, but in the opposite direction (that is, from <code>ril_worker.js</code> to <code>SystemWorkerManager</code> to <code>Ril.cpp</code>, then <code>rilproxy</code> and finally to the <code>rild</code> socket). <code>rild</code> then responds in kind, back along the same path, eventually arriving in <code>ril_worker.js</code>'s handler for the <code>REQUEST_GET_CURRENT_CALLS</code> message. Et la communication ainsi bidirectionnelle arrive.</p>

<p>Le call state est alors traité et comparé au précédent état; S'il y a un changement d'état, ril_worker.js notifie le service <code><a href="/fr/docs/Mozilla/Tech/XPCOM/Reference/Interface/nsIRadioInterfaceLayer" title="">nsIRadioInterfaceLayer</a></code> sur le thread principal:</p>

<pre class="brush:js;">_handleChangedCallState: function _handleChangedCallState(changedCall) {
  let message = {type: "callStateChange",
                 call: changedCall};
  this.sendDOMMessage(message);
}</pre>

<p><code><a href="/fr/docs/Mozilla/Tech/XPCOM/Reference/Interface/nsIRadioInterfaceLayer" title="">nsIRadioInterfaceLayer</a></code> est implémenté dans <a href="https://dxr.mozilla.org/mozilla-central/source/dom/system/gonk/RadioInterfaceLayer.js" rel="custom">dom/system/gonk/RadioInterfaceLayer.js</a>; le message est reçu par la méthode <code>onmessage()</code>:</p>

<pre class="brush:js;"> onmessage: function onmessage(event) {
   let message = event.data;
   debug("Received message from worker: " + JSON.stringify(message));
   switch (message.type) {
     case "callStateChange":
       // This one will handle its own notifications.
       this.handleCallStateChange(message.call);
       break;
   ...
</pre>

<p>Tout ce qu'il fait est d'expédier le message pour le processus de contenu en utilisant le Parent Process Message Manager (PPMM):</p>

<pre class="brush:js;">handleCallStateChange: function handleCallStateChange(call) {
  [some internal state updating]
  ppmm.sendAsyncMessage("RIL:CallStateChanged", call);
}</pre>

<p>Dans le processus de contenu, le message est reçu par la méthode <code>receiveMessage()</code> dans le service <code><a href="/fr/docs/Mozilla/Tech/XPCOM/Reference/Interface/nsIRILContentHelper" title="">nsIRILContentHelper</a></code> , depuis le Child Process Message Manager (CPMM):</p>

<pre class="brush:js;">receiveMessage: function receiveMessage(msg) {
  let request;
  debug("Received message '" + msg.name + "': " + JSON.stringify(msg.json));
  switch (msg.name) {
    case "RIL:CallStateChanged":
      this._deliverTelephonyCallback("callStateChanged",
                                     [msg.json.callIndex, msg.json.state,
                                     msg.json.number, msg.json.isActive]);
      break;</pre>

<p>Ce dernier, à son tour, appelle les méthodes <code><a href="https://developer.mozilla.org/fr/docs/XPCOM_Interface_Reference/nsIRILTelephonyCallback#callStateChanged()">nsIRILTelephonyCallback.callStateChanged()</a></code> sur chaque objet telephony callback enregistré. Chaque application web qui accède à l'API <a href="/fr/docs/Web/API/Window/navigator/mozTelephony" title="Cette documentation n'a pas encore été rédigée, vous pouvez aider en contribuant !"><code>window.navigator.mozTelephony</code></a> a enregistré un tel objet callback que propage les événements au code JavaScript dans l'application web, either as un changement d'état d'un objet appel existant ou un nouvel événement appel <code>entrant</code>.</p>

<pre class="brush:cpp;">NS_IMETHODIMP Telephony::CallStateChanged(PRUint32 aCallIndex, PRUint16 aCallState,
                                          const nsAString&amp; aNumber, bool aIsActive) {
  [...]

  if (modifiedCall) {
    // Change state.
    modifiedCall-&gt;ChangeState(aCallState);

    // See if this should replace our current active call.
    if (aIsActive) {
      mActiveCall = modifiedCall;
    }

    return NS_OK;
  }

  nsRefPtr&lt;TelephonyCall&gt; call =
          TelephonyCall::Create(this, aNumber, aCallState, aCallIndex);
  nsRefPtr&lt;CallEvent&gt; event = CallEvent::Create(call);
  nsresult rv = event-&gt;Dispatch(ToIDOMEventTarget(), NS_LITERAL_STRING("incoming"));
  NS_ENSURE_SUCCESS(rv, rv);
  return NS_OK;
}</pre>

<p>Les applications peuvent recevoir ces évenements et mettre à jour leur interface utilisateur etc:</p>

<pre class="brush:js;">handleEvent: function fm_handleEvent(evt) {
  switch (evt.call.state) {
    case 'connected':
      this.connected();
      break;
    case 'disconnected':
      this.disconnected();
      break;
    default:
      break;
  }
}</pre>

<p>Jetez un coup d'œil à la mise en œuvre de <a href="https://github.com/mozilla-b2g/gaia/blob/master/apps/communications/dialer/js/dialer.js" title="https://github.com/mozilla-b2g/gaia/blob/master/apps/communications/dialer/js/dialer.js"><code>handleEvent()</code>, dans l'application de demande de de composeur de numéro comme exemple étendu</a></p>

<h3 id="3G_data">3G data</h3>

<p>Il y a un message RIL qui amorce(introduit) "un appel de données" au service cellulaire; ceci permet le mode de transfert de données dans le modem. Cet appel de données finit par créer et activer un <a href="https://fr.wikipedia.org/wiki/Point-to-Point Protocol" title="Point-to-Point Protocol">Point-to-Point Protocol</a> (PPP) le dispositif d'interface dans le noyau Linux qui peut être configuré utilisant les interfaces habituelles.</p>

<div class="note">
<p><strong>Note:</strong> Cette section doit être écrite.</p>
</div>

<h3 id="API_de_DOM_liées">API de DOM liées</h3>

<p>Cette section inscrit les API de DOM qui sont relatées(liées) aux communications RIL :</p>

<ul>
 <li>API de téléphonie</li>
 <li><a href="/en-US/docs/API/WebSMS/Introduction_to_WebSMS" title="/en-US/docs/API/WebSMS/Introduction_to_WebSMS">API de SMS</a></li>
 <li>API de connexion mobile</li>
</ul>

<h2 id="Wi-Fi">Wi-Fi</h2>

<p>L'arrière-plan Wi-Fi pour Firefox OS utilise simplement wpa_supplicant pour faire la plupart du travail. Cela signifie que le travail principal de l'arrière-plan doit simplement gérer le suppliant et faire quelques tâches auxiliaires comme le chargement du conducteur Wi-Fi et de la permission ou la mise hors de service de l'interface de réseau. En substance, cela signifie que l'arrière-plan est une machine d'état, avec les états après l'état du suppliant.</p>

<div class="note">
<p><strong>Note:</strong> Une grande partie du truc(de la substance) intéressant qui arrive dans le Wi-Fi dépend profondément de changements possibles d'état du processus de wpa_supplicant.</p>
</div>

<p>La mise en œuvre du composant Wi-Fi est cassée dans deux fichiers:</p>

<dl>
 <dt><a href="https://dxr.mozilla.org/mozilla-central/source/dom/wifi/DOMWifiManager.js" rel="custom">dom/wifi/DOMWifiManager.js</a></dt>
 <dd>Met en œuvre l'API qui s'est exposée au contenu Web, comme défini dans <code><a href="/fr/docs/Mozilla/Tech/XPCOM/Reference/Interface/nsIWifi.idl" title="">nsIWifi.idl</a></code>.</dd>
 <dt><a href="https://dxr.mozilla.org/mozilla-central/source/dom/wifi/WifiWorker.js" rel="custom">dom/wifi/WifiWorker.js</a></dt>
 <dd>Met en œuvre la machine d'état et le code qui conduit le suppliant.</dd>
</dl>

<p>Ces deux fichiers(dossiers) communiquent entre eux par l'utilisation du manager de message. L'arrière-plan écoute pour des messages demandant certaines actions, comme "l'associé" et répond par un message quand l'action demandée a été achevée.</p>

<p>Le côté de DOM écoute pour les méthodes de réponse aussi bien que plusieurs messages d'événement qui indiquent des changements d'état et des mises à jour de l'information.</p>

<div class="note">
<p><strong>Note:</strong> N'importe quelle API de DOM synchrones est mise en œuvre par des données mises en antémémoire sur ce côté de la conduite. Des messages synchrones sont évités quand c'est possible.</p>
</div>

<h3 id="WifiWorker.js">WifiWorker.js</h3>

<p>Ce fichier met en œuvre la logique principale derrière l'interface Wi-Fi. Il fonctionne dans le processus chromé (dans le multi-processus construit) et est instancié par le SystemWorkerManager. <span class="transpan"><span id="tran0">Le fichier est généralement cassé dans deux sections : une fonction anonyme géante et WifiWorker (et son prototype). La fonction anonyme finit étant le WifiManager en fournissant une API locale, y compris des notifications pour des événements comme la connexion au suppliant et les résultats de feuilletage étant disponibles. En général, il contient peu de logique et laisse son consommateur unique contrôler ses actions tandis qu'il répond simplement par les informations demandées et contrôle les détails du rapport(de la connexion) avec le suppliant.</span></span></p>

<p>L'objet de WifiWorker est assis entre le WifiManager et le DOM. Il réagit aux événements et les transfert à DOM; à son tour, il reçoit des requêtes de DOM et exécute les actions appropriées sur le suppliant. Il maintient aussi des informations d'état sur le suppliant et ce qu'il doit faire ensuite.</p>

<h3 id="DOMWifiManager.js">DOMWifiManager.js</h3>

<p>Cela met en œuvre l'API de DOM, transmettant des messages dans les deux sens entre des interlocuteurs et le travailleur Wi-Fi réel. Il y a très peu de logique impliquée.</p>

<div class="note">
<p><strong>Note:</strong> Pour éviter des messages synchrones au processus chromé, le Manager Wi-Fi a vraiment besoin du cache de l'état basé sur l'événement reçu.</p>
</div>

<p>Il y a un message synchrone seul, qui est envoyé à temps à l'API DOM est instanciée, pour obtenir l'état actuel du suppliant.</p>

<h3 id="DHCP">DHCP</h3>

<p>DHCP et DNS <span class="transpan"><span id="tran0">sont traités par dhcpcd, la norme Linux DHCP le client. Cependant, il ne peut pas réagir quand la connexion de réseau est perdue. À cause de ceci, Firefox OS tue et reprend dhcpcd chaque fois il connecte à un réseau sans fil donné.</span></span></p>

<p>Dhcpcd est aussi responsable de mettre le parcours par défaut; nous appelons dans le gestionnaire de réseau pour parler au noyau de serveurs DNS.</p>

<h2 id="Gestionnaire_de_réseau">Gestionnaire de réseau</h2>

<p>Le Gestionnaire de réseau configure des interfaces de réseau ouvertes par le 3G des données et des composants Wi-Fi.</p>

<div class="note">
<p><strong>Note:</strong> Cela doit être écrit.</p>
</div>

<h2 id="Processus_et_threads">Processus et threads</h2>

<p><span class="transpan"><span id="tran0">Firefox OS utilise des threads POSIX pour mettre en œuvre tous les threads d'application, ceci inclut le fil conducteur de chaque travailleur d'application aussi bien que Web et des threads d'aide. Des valeurs agréables sont utilisées priorisent au processus et l'exécution de thread comptant ainsi sur le planificateur de noyau Linux standard. Selon le statut d'un processus nous l'assignons un niveau agréable et différent. Nous avons actuellement 7 niveaux :</span></span></p>

<table class="standard-table">
 <caption>Traitez des niveaux prioritaires</caption>
 <thead>
  <tr>
   <th scope="col">Priorité</th>
   <th scope="col">Nice</th>
   <th scope="col">Utilité</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><code>MASTER</code></td>
   <td>0</td>
   <td>Processus de b2g principal</td>
  </tr>
  <tr>
   <td><code>FOREGROUND_HIGH</code></td>
   <td>0</td>
   <td>Applications tenant une UC wakelock</td>
  </tr>
  <tr>
  </tr>
  <tr>
   <td><code>FOREGROUND</code></td>
   <td>1</td>
   <td>Applications de premier plan</td>
  </tr>
  <tr>
   <td><code>FOREGROUND_KEYBOARD</code></td>
   <td>1</td>
   <td>Application de clavier</td>
  </tr>
  <tr>
   <td><code>BACKGROUND_PERCEIVABLE</code></td>
   <td>7</td>
   <td>Applications de fond jouant audio</td>
  </tr>
  <tr>
   <td><code>BACKGROUND_HOMESCREEN</code></td>
   <td>18</td>
   <td>Application d'écran d'accueil</td>
  </tr>
  <tr>
   <td><code>BACKGROUND</code></td>
   <td>18</td>
   <td>Toutes les autres applications fonctionnant en arrière-plan</td>
  </tr>
 </tbody>
</table>

<p><span class="transpan"><span id="tran0">Quelques niveaux partagent les mêmes valeurs agréables, c'est que ces niveaux diffèrent actuellement dans la façon qu'ils sont traités par le tueur de mémoire insuffisante. Toutes les priorités peuvent être ajustées à construisent le temps via des préférences; les entrées pertinentes peuvent être trouvées dans le fichier de b2g/app/b2g.js.</span></span></p>

<div class="note">
<p><strong>Note</strong>: Pour plus d'informations sur le tueur de mémoire insuffisante et comment Firefox OS gère des situations de mémoire basses, lire Mémoire insuffisante la gestion sur Firefox OS.</p>
</div>

<p>Dans un processus le thread conducteur hérite la valeur agréable du processus tandis que l'on donne aux fils de travailleur Web une valeur agréable qui est un point plus haut que le thread conducteur fonctionnant ainsi à la priorité inférieure. <span class="transpan"><span id="tran0">Ceci est fait pour empêcher des travailleurs intensifs de l'UC d'excessivement ralentir le thread conducteur. Les priorités de processus sont changées quand un événement majeur arrive comme une demande est envoyée dans le contexte ou le premier plan, une nouvelle demande est mise en marche ou une application existante saisit une UC wakelock. Quand une priorité de processus est ajustée, les priorités de tous ses fils seront aussi ajustées en conséquence.</span></span></p>

<div class="note">
<p><strong>Note:</strong> Ces groupes ne sont pas actuellement utilisés pour la gestion de ressource comme ils ont prouvé incertains sur certains dispositifs et des noyaux.</p>
</div>
