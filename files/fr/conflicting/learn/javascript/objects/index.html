---
title: Introduction à JavaScript orienté objet
slug: Web/JavaScript/Introduction_à_JavaScript_orienté_objet
tags:
  - Encapsulation
  - Intermédiaire
  - JavaScript
  - OOP
  - Object
  - Orienté objet
translation_of: Learn/JavaScript/Objects
translation_of_original: Web/JavaScript/Introduction_to_Object-Oriented_JavaScript
---
<div>{{jsSidebar("Introductory")}}</div>

<p>JavaScript possède un grand potentiel pour la programmation orientée objet (aussi appelée {{Glossary("OOP")}}). Cet article débutera par une introduction à la programmation orientée objet puis abordera le modèle objet de JavaScript et finira par les concepts de la programmation orientée objet appliquée à JavaScript.</p>

<div class="note">
<p><strong>Note :</strong> Une nouvelle façon de créer des objets a été introduite avec ECMAScript 2015 (ES6) et n'est pas décrite ici. Il s'agit <a href="/fr/docs/Web/JavaScript/Reference/Classes">des classes</a>.</p>
</div>

<h2 id="Un_aperçu_de_JavaScript">Un aperçu de JavaScript</h2>

<p>Si vous n'êtes pas certain de connaître certains concepts comme les variables, les types, les fonctions, et les portées vous pouvez lire <a href="/fr/docs/Web/JavaScript/Une_réintroduction_à_JavaScript">Une réintroduction à JavaScript</a>. Vous pouvez également consulter le <a href="/fr/docs/Web/JavaScript/Guide">guide JavaScript</a>.</p>

<h2 id="La_programmation_orientée_objet">La programmation orientée objet</h2>

<p>La programmation orientée objet est un paradigme de programmation qui se base sur une abstraction du monde réel pour créer des modèles. Plusieurs techniques sont utilisées, provenant de paradigmes précédents, comme la modularité, le polymorphisme, ou l'encapsulation. Aujourd'hui, de nombreux langages de programmation (Java, JavaScript, C#, C++, Python, PHP, Ruby et Objective-C par exemple) utilisent la programmation orientée objet (OOP en anglais pour <em>Object-Oriented Programmation</em>).</p>

<p>La programmation orientée objet peut être vue comme une façon de concevoir un ou des logiciel(s) grâce à un ensemble d'objets qui coopèrent plutôt que d'utiliser, avec une approche plus traditionnelle, un ensemble de fonctions ou encore une liste d'instructions à envoyer à un ordinateur. En programmation orientée objet, chaque objet est capable d'envoyer et de recevoir des messages provenant d'autres objets, de traiter des données. Chaque objet peut être compris comme une entité indépendante avec un rôle distinct.</p>

<p>La programmation orientée objet a pour but de permettre une plus grande flexibilité et maintenabilité du code. Elle est populaire pour les projets logiciels de grande ampleur. Étant donné l'accent mis sur la modularité, le code orienté objet est censé être plus simple à développer, plus facile à reprendre, à analyser et permettre de répondre à des situations complexes en comparaison à d'autres méthodes de programmation moins modulaires.</p>

<h2 id="Terminologie">Terminologie</h2>

<dl>
 <dt>{{Glossary("Namespace","Espace de noms")}}</dt>
 <dd>Un conteneur qui permet aux développeurs d'empaqueter les différentes fonctionnalités d'un programme sous un même nom d'application.</dd>
 <dt>{{Glossary("Class", "Classe")}}</dt>
 <dd>Définit les caractéristiques de l'objet.</dd>
 <dt>{{Glossary("Objet")}}</dt>
 <dd>Une instance (un « exemplaire ») d'une classe.</dd>
 <dt>{{Glossary("Property", "Propriété")}}</dt>
 <dd>Une caractéristique d'un objet (sa couleur par exemple).</dd>
 <dt>{{Glossary("Méthode")}}</dt>
 <dd>Une capacité d'un objet (changer de couleur par exemple).</dd>
 <dt>{{Glossary("Constructeur")}}</dt>
 <dd>Une méthode appelée au moment de l'instantiation.</dd>
 <dt>{{Glossary("Héritage")}}</dt>
 <dd>Une classe peut hériter des caractéristiques et des fonctionnalités d'une autre classe.</dd>
 <dt>{{Glossary("Encapsulation")}}</dt>
 <dd>Une classe définit uniquement les caractéristiques de son objet, une méthode définit uniquement la façon dont elle s'exécute. On regroupe donc les données et les méthodes qui utilisent ces données.</dd>
 <dt>{{Glossary("Abstraction")}}</dt>
 <dd>La conjonction entre l'utilisation de l'héritage, de méthodes ou de propriétés d'un objet pour simuler un modèle de la réalité.</dd>
 <dt>{{Glossary("Polymorphisme")}}</dt>
 <dd>Poly signifie « plusieurs » et morphisme signifie « formes ». Cela signifie que différentes classes peuvent définir la même méthode ou la même propriété.</dd>
</dl>

<p>Pour une description plus étendue, lire l'article {{interwiki("wikipedia","Programmation_orientée_objet","Programmation orientée objet")}} de Wikipédia.</p>

<h2 id="Programmation_orientée_prototype">Programmation orientée prototype</h2>

<p>La programmation orientée prototype est un style de programmation orientée objet qui n'utilise pas les classes. La réutilisation des propriétés d'un objet (appelée héritage pour les langages à classe) est effectuée via des objets qui seront des prototypes pour d'autres objets. Parmi les autres noms de ce modèle, on retrouve la programmation sans classe ou la programmation à base d'instances.</p>

<p>L'exemple premier d'un langage utilisant les prototypes est le langage de programmation {{interwiki("wikipedia", "Self_(langage)", "Self")}}, développé par David Ungar et Randall Smith. Toutefois, ce modèle de programmation s'est popularisé à différents langages comme JavaScript, Cecil, NewtonScript, Io, MOO, REBOL, Kevo, Squeak (quand le framework Viewer est utilisé pour manipuler des composants Morphic), et d'autres encore.</p>

<h2 id="La_programmation_orientée_objet_avec_JavaScript">La programmation orientée objet avec JavaScript</h2>

<h3 id="Les_espaces_de_noms">Les espaces de noms</h3>

<p>Un espace de noms est un conteneur qui permet de regrouper l'ensemble des fonctionnalités d'une application sous un un nom unique, spécifique à cette application. <strong>En JavaScript, un espace de noms est un objet comme les autres qui contient des méthodes et des propriétés.</strong></p>

<div class="note">
<p><strong>Note :</strong> il est important de bien faire la différence avec d'autres langages ou les espaces de noms et les objets sont des entités distinctes. En JavaScript, ce n'est pas le cas.</p>
</div>

<p>Pourquoi créer un espace de noms en JavaScript ? La réponse est simple, on peut ainsi disposer d'un seul objet global qui contient l'ensemble des variables, méthodes et fonctions en tant que propriétés. L'utilisation d'un tel objet permet ainsi de réduire le risque de conflit (utilisation d'un même nom) au sein d'une application qui en utilise une autre.</p>

<p>Par exemple : on peut créer un objet global MONAPPLICATION :</p>

<pre class="brush: js">// espace de nom global
var MONAPPLICATION = MONAPPLICATION || {};</pre>

<p>Dans l'exemple ci-dessus, on vérifie d'abord que MONAPPLICATION n'est pas déjà défini (dans ce fichier ou dans un autre). S'il est déjà défini, on l'utilise, sinon on crée un objet vide MONAPPLICATION qui recevra les différentes méthodes, fonctions et variables à encapsuler.</p>

<p>Il est également possible de créer des espaces de noms à un niveau inférieur (une fois qu'on a bien défini le <em>namespace</em> global) :</p>

<pre class="brush: js">// espace de noms "fils"
MONAPPLICATION.event = {};</pre>

<p>L'exemple ci-dessous permet de créer un espace de noms et de lui ajouter des variables, des fonctions et des méthodes :</p>

<pre class="brush: js">// On crée un conteneur MONAPPLICATION.méthodesCommunes pour regrouper certaines méthodes
MONAPPLICATION.méthodesCommunes = {
  regExPourNom: "", // on définit une expression rationnelle pour un nom
  regExPourTéléphone: "", // une autre pour un numéro de téléphone
  validerNom: function(nom){
    // On valide le nom en utilisant
    // la regexp par exemple
  },

  validerNumTéléphone: function(numTéléphone){
    // on valide le numéro de téléphone
  }
}

// On utilise un conteneur pour les événements
MONAPPLICATION.event = {
  addListener: function(el, type, fn) {
  //  le corps de la méthode
  },
  removeListener: function(el, type, fn) {
  //  le corps de la méthode
  },
  getEvent: function(e) {
  //  le corps de la méthode
  }

 // Il est possible d'ajouter des méthodes et des propriétés
}

// Exemple de syntaxe pour utiliser la méthode addListener :
MONAPPLICATION.event.addListener("monÉlément", "type", callback);</pre>

<h3 id="Objets_natifs_standard">Objets natifs standard</h3>

<p>JavaScript dispose de plusieurs objets essentiels inclus dans le langage. On y trouve entre autres les objets <code>Math</code>, <code>Object</code>, <code>Array</code>, et <code>String</code>. L'exemple ci-après illustre comment utiliser l'objet <code>Math</code> pour obtenir un nombre aléatoire en utilisant la méthode <code>random()</code>.</p>

<pre class="brush: js">console.log(Math.random());
</pre>

<div class="note"><strong>Note :</strong> Cet exemple, ainsi que les suivants, utilisent une fonction {{domxref("console.log()")}} définie globalement. La fonction <code>console.log </code>n'est pas, à proprement parler, une fonctionnalité de JavaScript en tant que telle mais est implémentée dans la plupart des navigateurs à des fins de débogage.</div>

<p>Voir la page sur <a href="/fr/docs/Web/JavaScript/Reference/Objets_globaux">les objets globaux</a> pour une liste de ces objets essentiels.</p>

<p>En JavaScript, chaque objet est une instance de l'objet <a href="/fr/docs/JavaScript/R%C3%A9f%C3%A9rence_JavaScript/Objets_globaux/Object"><code>Object</code></a> et hérite donc des propriétés et des méthodes de ce dernier.</p>

<h3 id="Objets_créés_sur_mesure">Objets créés sur mesure</h3>

<h4 id="Le_constructeur">Le constructeur</h4>

<p>JavaScript est un langage utilisant les prototypes, il ne dispose pas d'une instruction pour déclarer une classe (à la différence de C++ ou Java). Cela peut sembler déroutant pour les développeurs utilisant d'autres langages de classe. JavaScript utilise des fonctions comme constructeurs pour définir un objet. On définit les propriétés et méthodes d'un objet en définissant une fonction qui sera utilisée par la suite pour construire l'objet souhaité. Ici, on définit un constructeur <code>Personne</code>.</p>

<pre class="brush: js">var Personne = function () { }
</pre>

<div class="note">
<p><strong>Note :</strong> Par convention, le nom d'un constructeur commence par une majuscule. Cela permet de différencier les fonctions classiques des constructeurs et de mieux les utiliser.</p>
</div>

<h4 id="L'instance">L'instance</h4>

<p>Pour créer une nouvelle instance, on utilise l'instruction <code>new <em>objet</em></code>, et on affecte le résultat de cette expression à une variable qu'on utilisera par la suite. Il est également possible d'utiliser la méthode <a href="/fr/docs/Web/JavaScript/Reference/Objets_globaux/Object/create"><code>Object.create</code></a> afin de créer une instance non initialisée.</p>

<p>Dans l'exemple qui suit, on utilise le constructeur <code>Personne</code> définit précédemment et on crée deux instances grâce à l'opérateur <a href="/fr/docs/JavaScript/Reference/R%C3%A9f%C3%A9rence_JavaScript/Op%C3%A9rateurs/Op%C3%A9rateurs_sp%C3%A9ciaux/L'op%C3%A9rateur_new"><code>new</code></a> (<code>personne1</code> et <code>personne2</code>).</p>

<pre class="brush: js">var personne1 = new Personne();
var personne2 = new Personne();
</pre>

<div class="note"><strong>Note:</strong> Voir aussi {{jsxref("Object.create()")}} pour une autre méthode d'instanciation.</div>

<h4 id="Le_constructeur_(suite)">Le constructeur (suite)</h4>

<p>Le constructeur est la méthode appelée au moment de l'instanciation (l'instant où l'exemplaire de l'objet est créé). En JavaScript, la déclaration vue précédemment suffit à définir un constructeur. Chaque action déclarée dans le constructeur est executée au moment de l'instanciation.</p>

<p>Le constructeur est utilisé afin de définir les propriétés d'un objet et d'appeler les méthodes nécessaires pour préparer l'objet.</p>

<p>Dans l'exemple ci-dessous, le constructeur de la classe <code>Personne</code> affiche un message dans la console lorsqu'un objet <code>Personne</code> est instancié.</p>

<pre class="brush: js">function Personne() {
  console.log('Nouvel objet Personne créé');
}

var personne1 = new Personne();
// affiche "Nouvel objet Personne créé" dans la console
var personne2 = new Personne();
// affiche "Nouvel objet Personne créé" dans la console
</pre>

<h4 id="Les_propriétés_(ou_attributs)">Les propriétés (ou attributs)</h4>

<p>Les propriétés sont des variables appartenant à un objet. Les propriétés d'un objet peuvent être définies au sein du prototype afin que tous les objets qui en héritent puissent disposer de cette propriété via la chaîne de prototypes.</p>

<p>Dans le contexte d'un objet, l'accès à ses propriétés se fait grâce au mot-clé <code>this</code>, qui fait référence à l'objet courant. L'accès (en écriture ou lecture) à une propriété depuis un autre objet se fait grâce à la syntaxe <code>nomInstance.propriété</code>. Cette syntaxe est la même pour d'autres langages comme C++, Java, etc.</p>

<p>Dans l'exemple qui suit, on crée la propriété <code>nom</code> pour le constructeur <code>Personne</code> et on définit sa valeur lors de l'instanciation :</p>

<pre class="brush: js">function Personne(nom) {
  this.nom = nom;
  console.log('Nouvel objet Personne créé');
}

var personne1 = new Personne('Alice');
var personne2 = new Personne('Bob');

//on affiche le nom de personne1
console.log('personne1 est ' + personne1.nom); // personne1 est Alice
console.log('personne2 est ' + personne2.nom); // personne2 est Bob
</pre>

<h4 id="Les_méthodes">Les méthodes</h4>

<p>Les méthodes sont également des propriétés d'un objet : ce sont des fonctions plutôt que des objets. L'appel à une méthode se fait de la même façon que pour l'accès à une propriété, les parenthèses <code>()</code> en plus, éventuellement avec des arguments. Pour définir une méthode dont disposeront tous les objets qu'on souhaite définir, il faut l'assigner comme propriété de la propriété <code>prototype</code> de l'objet. Le nom auquel est assigné la fonction est le nom de la méthode.</p>

<p>Dans l'exemple qui suit, on définit et utilise la méthode <code>direBonjour()</code> pour un objet <code>Personne</code>.</p>

<pre class="brush: js">function Personne(nom) {
  this.nom = nom;
}

Personne.prototype.direBonjour = function() {
  console.log("Bonjour, je suis " + this.nom);
};

var personne1 = new Personne('Alice');
var personne2 = new Personne('Robert');

// on appelle la méthode.
personne1.direBonjour(); // Bonjour, je suis Alice
</pre>

<p>En JavaScript, les méthodes sont des fonctions classiques simplement liées à un objet en tant que propriété. On peut donc appeler la méthode « en dehors de l'objet ». Par exemple :</p>

<pre class="brush: js">function Personne(nom) {
  this.nom = nom;
}

Personne.prototype.afficherNom = function() {
  console.log("Je suis "+this.nom);
};

var personne1 = new Personne('Gustave');
var donnerUnNom = personne1.afficherNom;

personne1.afficherNom(); // 'Je suis Gustave'
donnerUnNom(); // undefined
console.log(donnerUnNom === personne1.afficherNom); // true
console.log(donnerUnNom === Personne.prototype.afficherNom); // true
donnerUnNom.call(personne1); // 'Je suis Gustave'
</pre>

<p>On voit ici plusieurs concepts. Tout d'abord, il n'existe pas de méthode propre à un objet car toutes les références à la méthode vont utiliser la fonction définie pour le prototype. Ensuite, JavaScript fait un lien entre le contexte de l'objet courant et la variable <strong>this</strong> quand une fonction est appelée en tant que propriété d'un objet. Ceci est équivalent à utiliser la fonction <code>call</code> :</p>

<pre class="brush: js">donnerUnNom.call(personne1); // 'Gustave'
</pre>

<div class="note"><strong>Note :</strong> Voir les pages <a href="/fr/docs/Web/JavaScript/Reference/Objets_globaux/Function/call">Function.call</a> et <a href="/fr/docs/Web/JavaScript/Reference/Objets_globaux/Function/apply">Function.apply</a> pour plus d'informations. Voir également la page sur l'opérateur <a href="/fr/docs/Web/JavaScript/Reference/Op%C3%A9rateurs/L_op%C3%A9rateur_this">this</a> et les différents contextes.</div>

<h4 id="L'héritage">L'héritage</h4>

<p>L'héritage permet de créer un objet spécialisé qui découle d'un autre objet. (<em>JavaScript ne supporte que l'héritage unique : c'est-à-dire qu'un objet peut spécialiser un autre objet mais ne peut pas en spécialiser plusieurs à la fois</em>). L'objet spécialisé est appelé l'objet fils et l'objet générique appelé parent. Pour indiquer un lien d'héritage en JavaScript, on assigne une instance de l'objet parent à la propriété <code>prototype</code> de l'objet fils. Grâce aux navigateurs récents, il est également possible d'utiliser la méthode <a href="/fr/docs/Web/JavaScript/Reference/Objets_globaux/Object/create#H.C3.A9ritage_avec_Object.create">Object.create</a> afin d'implémenter l'héritage.</p>

<div class="note">
<p><strong>Note :</strong> Il est également nécessaire de renseigner la propriété <code>prototype.constructor</code> avec le constructeur de la classe parente ! Voir la page de <a href="/fr/docs/Web/JavaScript/Reference/Objets_globaux/Object/prototype">Object:prototype</a> pour plus d'informations.</p>
</div>

<p>Dans les exemples qui suivent, on définit le constructeur <code>Étudiant</code> pour créer des objets bénéficiant des propriétés d'un objet <code>Personne</code>. Pour cet objet fils, on redéfinit la méthode <code>direBonjour()</code> et on ajoute la méthode <code>aurevoir()</code>.</p>

<pre class="brush: js">// Le constructeur Personne
var Personne = function(nom) {
   this.nom = nom;
};

Personne.prototype.marcher = function(){
  console.log("Je marche !");
};
Personne.prototype.direBonjour = function(){
  console.log("Bonjour, je suis "+this.nom);
};

// Le constructeur Étudiant
function Étudiant(nom, sujet) {
  // On appelle le constructeur parent
  // pour profiter des propriétés définies dans la fonction
  Personne.call(this, nom);
  this.sujet = sujet;
}

// On déclare l'héritage pour bénéficier de la chaîne de prototypes
// Attention à ne pas utiliser "new Personne()". Ceci est incorrect
// on ne peut pas fournir l'argument "nom". C'est pourquoi on appelle
// Personne avant, dans le constructeur Étudiant.
Étudiant.prototype = Object.create(Personne.prototype);

// on corrige le constructeur qui pointe sur celui de Personne
Étudiant.prototype.constructor = Étudiant;

// on remplace la méthode direBonjour pour l'étudiant
Étudiant.prototype.direBonjour = function(){
 console.log("Bonjour, je suis "+ this.nom + ". J'étudie " + this.sujet + ".");
};

// on ajoute la méthode aurevoir
Étudiant.prototype.aurevoir = function(){
  console.log('Au revoir');
};

var étudiant1 = new Étudiant("Jean", "la physique appliquée");
étudiant1.direBonjour();
étudiant1.marcher();
étudiant1.aurevoir();

// on vérifie l'héritage
console.log(étudiant1 instanceof Personne); // true
console.log(étudiant1 instanceof Étudiant); // true
</pre>

<p>Les anciens navigateurs peuvent ne pas disposer de la méthode <a href="/fr/docs/Web/JavaScript/Reference/Objets_globaux/Object/create"><code>Object.create</code></a>. Pour résoudre ce problème, il est possible d'utiliser une prothèse d'émulation (<em>polyfill</em> ou <em>shim</em>) comme :</p>

<pre class="brush: js">function createObject(proto) {
  function ctor() { }
  ctor.prototype = proto;
  return new ctor();
}

// Exemple d'utilisation:
Étudiant.prototype = createObject(Personne.prototype);</pre>

<div class="note"><strong>Note :</strong> Voir la page <a href="/fr/docs/Web/JavaScript/Reference/Objets_globaux/Object/create">Object.create</a> pour plus d'informations et pour une prothèse d'émulation pour les anciens navigateurs.</div>

<p class="note">Il peut parfois être utile de vérifier la valeur de this utilisée au sein de la fonction pour appliquer les bons traitements. Par exemple, on pourra utiliser</p>

<pre class="brush: js">var Person = function(nom) {
  if (this instanceof Personne) {
    this.nom = nom;
  } else {
    return new Personne(nom);
  }
}
</pre>

<h4 id="L'encapsulation">L'encapsulation</h4>

<p>Dans l'exemple précédent, <code>Étudiant</code> n'a pas besoin de réimplémenter la méthode <code>marcher() </code>de <code>Personne</code> : il peut l'utiliser directement. L'encapsulation signifie qu'on a seulement besoin d'implémenter les changements (ex : <code>direBonjour</code>) par rapport à l'objet parent, le reste sera hérité naturellement et pourra être utilisé par l'objet fils. Chaque prototype regroupe les données et les méthodes dans une seule et même unitée.</p>

<p>D'autres langages permettent de masquer des informations grâce des méthodes/propriétés privées et/ou protégées. Bien qu'il soit possible de simuler ce comportement en JavaScript, cet aspect n'est pas obligatoire en programmation orientée objet.</p>

<h4 id="L'abstraction">L'abstraction</h4>

<p>L'abstraction permet de modéliser le problème qu'on souhaite résoudre. On peut créer un modèle abstrait en utilisant l'héritage (autrement dit une spécialisation des objets) et la composition. Comme on l'a vu JavaScript permet de créer un héritage (simple) entre objets et la composition est obtenue car les propriétés d'un objet peuvent elles-mêmes être des objets.</p>

<p>L'objet JavaScript <a href="/fr/docs/Web/JavaScript/Reference/Objets_globaux/Function"><code>Function</code></a> hérite de <code><a href="/fr/docs/Web/JavaScript/Reference/Objets_globaux/Object">Object</a></code> (on a l'héritage) et la propriété <code>Function.prototype</code> est une instance d'<code>Object</code> (on a la composition)</p>

<pre class="brush: js">var toto = function(){};
console.log('toto est une Function : ' + (toto instanceof Function) );
console.log('toto.prototype est un Object : ' + (toto.prototype instanceof Object) );
</pre>

<h4 id="Le_polymorphisme">Le polymorphisme</h4>

<p>Le polymorphisme est rendu possible par l'héritage des méthodes. Les différents objets fils peuvent définir différentes méthodes avec le même nom. Ainsi si on itère sur une collection d'objets dont on sait que ces objets sont des instances du type parent, on pourra utiliser la méthode nommée qui utilisera la méthode définie pour l'objet fils.</p>

<h2 id="Notes">Notes</h2>

<p>Les techniques présentées ici ne sont qu'un fragment des techniques utilisables en JavaScript. JavaScript, grâce à sa nature prototypale, est très flexible et permet d'implémenter différentes façons de programmer avec des objets.</p>

<p>Les techniques présentées ici ne tirent pas partie de l'implémentation des objets d'autres langages ni de bidouilles spécifiques au langage. Il existe d'autres techniques permettant de construire différentes architectures objet en JavaScript mais celles-ci dépassent le cadre de cet article.</p>

<h2 id="Voir_aussi">Voir aussi</h2>

<ul>
 <li><a href="/fr/docs/Web/JavaScript/Guide">Guide JavaScript</a> sur MDN</li>
 <li>L'article Wikipédia : <a href="https://fr.wikipedia.org/wiki/Programmation_orient%C3%A9e_objet">Programmation orientée objet</a></li>
 <li>L'article Wikipédia : <a href="https://fr.wikipedia.org/wiki/Programmation_orient%C3%A9e_prototype">Programmation orientée prototype</a></li>
 <li>L'article Wikipédia : <a href="https://fr.wikipedia.org/wiki/Encapsulation_(programmation)">l'encapsulation</a></li>
 <li><a href="https://davidwalsh.name/javascript-objects">Aperçu de JavaScript pour la POO</a>, une série d'articles en anglais écrite par Kyle Simpson</li>
 <li>{{jsxref("Function.prototype.call()")}}</li>
 <li>{{jsxref("Function.prototype.apply()")}}</li>
 <li>{{jsxref("Object.create()")}}</li>
 <li><a href="/fr/docs/Web/JavaScript/Reference/Strict_mode">Le mode strict</a></li>
</ul>
