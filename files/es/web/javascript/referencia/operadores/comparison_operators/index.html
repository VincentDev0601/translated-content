---
title: Operadores de Comparación
slug: Web/JavaScript/Referencia/Operadores/Comparison_Operators
tags:
  - JavaScript
  - Operador
  - Referencia
translation_of: Web/JavaScript/Reference/Operators
---
<div>{{jsSidebar("Operators")}}</div>

<p>JavaScript tiene comparaciones estrictas y de conversión de tipos. Una comparación estricta (por ejemplo, <code>===</code>) solo es verdadera si los operandos son del mismo tipo y los contenidos coinciden. La comparación abstracta más comúnmente utilizada (por ejemplo, <code>==</code>) convierte los operandos al mismo tipo antes de hacer la comparación. Para las comparaciones abstractas relacionales (p. Ej., <code>&lt;=</code>), Los operandos primero se convierten en primitivos, y luego en el mismo tipo, antes de la comparación.</p>

<p>Las cadenas se comparan en base al orden lexicográfico estándar, utilizando valores Unicode.</p>

<pre class="brush: js notranslate">console.log(1 == 1)
// Esperamos True

console.log("1" == 1 )
// Esperamos true

console.log( 1 === 1)
// Esperamos true

console.log( "1" === 1)
// Esperamos false
</pre>

<p>Características de las comparaciones:</p>

<ul>
 <li>Dos cadenas son estrictamente iguales cuando tienen la misma secuencia de caracteres, la misma longitud y los mismos caracteres en las posiciones correspondientes.</li>
 <li>Dos números son estrictamente iguales cuando son numéricamente iguales (tienen el mismo valor numérico). <a href="/es/docs/Web/JavaScript/Reference/Global_Objects/NaN">NaN</a> no es igual a nada, incluido NaN. Los ceros positivos y negativos son iguales entre sí. </li>
 <li>Dos operandos booleanos son estrictamente iguales si ambos son <code>true</code> o ambos son <code>false</code>.</li>
 <li>Dos objetos distintos nunca son iguales para comparaciones estrictas o abstractas.</li>
 <li>Una expresión que compara objetos solo es verdadera si los operandos hacen referencia al mismo objeto.</li>
 <li>Los tipos Null y Undefined son estrictamente iguales a ellos mismos y abstractivamente iguales entre sí.</li>
</ul>

<h2 id="Operadores_de_igualdad">Operadores de igualdad</h2>

<h3 id="Igualdad"><a name="Equality">Igualdad (==)</a></h3>

<p>El operador de igualdad convierte los operandos si <strong>no son del mismo tipo</strong>, luego aplica una comparación estricta. Si <strong>ambos operandos son objetos</strong>, entonces JavaScript compara las referencias internas que son iguales cuando los operandos se refieren al mismo objeto en la memoria.</p>

<h4 id="Sintaxis">Sintaxis</h4>

<pre class="syntaxbox notranslate">x == y
</pre>

<h4 id="Ejemplos">Ejemplos</h4>

<pre class="brush: js notranslate">1    ==  1         // true
'1'  ==  1         // true
1    == '1'        // true
0    == false      // true
0    == null       // false
var object1 = {'key': 'value'}, object2 = {'key': 'value'};
object1 == object2 // false
0    == undefined  // false
null == undefined  // true
</pre>

<h3 id="Desigualdad_!"><a name="Inequality">Desigualdad (!=)</a></h3>

<p>El operador de desigualdad devuelve verdadero si los operandos no son iguales. Si los dos operandos <strong>no son del mismo tipo</strong>, JavaScript intenta convertir los operandos a un tipo apropiado para la comparación. Si <strong>ambos operandos son objetos</strong>, entonces JavaScript compara las referencias internas que no son iguales cuando los operandos se refieren a diferentes objetos en la memoria.</p>

<h4 id="Sintaxis_2">Sintaxis</h4>

<pre class="syntaxbox notranslate">x != y</pre>

<h4 id="Ejemplos_2">Ejemplos</h4>

<pre class="brush: js notranslate">1 !=   2     // true
1 !=  '1'    // false
1 !=  "1"    // false
1 !=  true   // false
0 !=  false  // false
</pre>

<h3 id="Identidad_igualdad_estricta"><a name="Identity">Identidad / igualdad estricta (===)</a></h3>

<p>El operador de identidad devuelve verdadero si los operandos son estrictamente iguales (ver arriba) <strong>sin conversión de tipo</strong>.</p>

<h4 id="Sintaxis_3">Sintaxis</h4>

<pre class="syntaxbox notranslate">x === y</pre>

<h4 id="Ejemplos_3">Ejemplos</h4>

<pre class="brush: js  notranslate">3 === 3   // true
3 === '3' // false
var object1 = {'key': 'value'}, object2 = {'key': 'value'};
object1 === object2 // false</pre>



<h3 id="Sin_identidad_desigualdad_estricta_!"><a name="Nonidentity">Sin identidad / desigualdad estricta (!==)</a></h3>

<p>El operador sin identidad devuelve verdadero si los operandos <strong>no son iguales y / o no del mismo tipo</strong>.</p>

<h4 id="Sintaxis_4">Sintaxis</h4>

<pre class="syntaxbox notranslate">x !== y</pre>

<h4 id="Ejemplos_4">Ejemplos</h4>

<pre class="brush: js notranslate">3 !== '3' // true
4 !== 3   // true
</pre>

<h2 id="Operadores_relacionales">Operadores relacionales</h2>

<p>Cada uno de estos operadores llamará a la función <code>valueOf()</code> en cada operando antes de realizar una comparación.</p>

<h3 id="Operador_mayor_que_>"><a name="Greater_than_operator">Operador mayor que (&gt;)</a></h3>

<p>El operador mayor que, devuelve verdadero si el operando izquierdo es mayor que el operando derecho.</p>

<h4 id="Sintaxis_5">Sintaxis</h4>

<pre class="syntaxbox notranslate">x &gt; y</pre>

<h4 id="Ejemplos_5">Ejemplos</h4>

<pre class="brush: js notranslate">4 &gt; 3 // true
</pre>

<h3 id="Operador_mayor_o_igual_>"><a name="Greater_than_or_equal_operator">Operador mayor o igual (&gt;=)</a></h3>

<p>El operador mayor o igual que, devuelve verdadero si el operando izquierdo es mayor o igual que el operando derecho.</p>

<h4 id="Sintaxis_6">Sintaxis</h4>

<pre class="syntaxbox notranslate"> x &gt;= y</pre>

<h4 id="Ejemplos_6">Ejemplos</h4>

<pre class="brush: js notranslate">4 &gt;= 3 // true
3 &gt;= 3 // true
</pre>

<h3 id="Operador_menor_que_&lt;"><a name="Less_than_operator"> Operador menor que (&lt;)</a></h3>

<p>El operador menor que devuelve verdadero si el operando de la izquierda es menor que el operando de la derecha.</p>

<h4 id="Sintaxis_7">Sintaxis</h4>

<pre class="syntaxbox notranslate"> x &lt; y</pre>

<h4 id="Ejemplos_7">Ejemplos</h4>

<pre class="brush: js notranslate">3 &lt; 4 // true
</pre>

<h3 id="Operador_menor_o_igual_&lt;"><a id="Less_than_or_equal_operator" name="Less_than_or_equal_operator">Operador menor o igual (&lt;=)</a></h3>

<p>El operador menor o igual devuelve verdadero si el operando izquierdo es menor o igual que el operando derecho.</p>

<h4 id="Sintaxis_8">Sintaxis</h4>

<pre class="syntaxbox notranslate"> x &lt;= y</pre>

<h4 id="Ejemplos_8">Ejemplos</h4>

<pre class="brush: js notranslate">3 &lt;= 4 // true
</pre>

<h2 id="Usando_los_operadores_de_igualdad">Usando los operadores de igualdad</h2>

<p>Los operadores de igualdad estándar (<code>==</code> y <code>!=</code>) utilizan el <a href="http://www.ecma-international.org/ecma-262/5.1/#sec-11.9.3">Algoritmo de Comparación de Igualdad Abstracta</a> para comparar dos operandos. Si los operandos son de tipos diferentes, intentará convertirlos al mismo tipo antes de hacer la comparación, por ejemplo, en la expresión <code>5 == '5'</code>, la cadena de la derecha se convierte a {{jsxref("Number")}} antes de realizar la comparación.</p>

<p>Los operadores de igualdad estricta (<code>===</code> y <code>!==</code>) usan el <a href="http://www.ecma-international.org/ecma-262/5.1/#sec-11.9.6">Algoritmo de Comparación de Igualdad Estricta</a> y están destinados a realizar comparaciones de igualdad en operandos del mismo tipo. Si los operandos son de tipos diferentes, el resultado siempre es <code>false</code>, entonces <code>5 !== '5'</code>.</p>

<p>Utilice operadores de igualdad estrictos si los operandos deben ser de un tipo específico así como de valor o si el tipo exacto de los operandos es importante. De lo contrario, utilice los operadores de igualdad estándar, que le permiten comparar la identidad de dos operandos, incluso si no son del mismo tipo.</p>

<p>Cuando la conversión de tipo está involucrada en la comparación (es decir, comparación no estricta), JavaScript convierte los tipos {{jsxref("String")}}, {{jsxref("Number")}}, {{jsxref("Boolean")}} o {{jsxref("Object")}} operandos de la siguiente manera:</p>

<ul>
 <li>Al comparar un número y una cadena, la cadena se convierte en un valor numérico. JavaScript intenta convertir el literal numérico de cadena a un valor de tipo <code>Number</code>. Primero, un valor matemático se deriva del literal numérico de cadena. A continuación, este valor se redondea al valor de tipo <code>Number</code> más cercano.</li>
 <li>Si uno de los operandos es <code>Boolean</code>, el operando <code>Boolean</code> se convierte en 1 si es <code>true</code> y +0 si es <code>false</code>.</li>
 <li>Si un objeto se compara con un número o cadena, JavaScript intenta devolver el valor predeterminado para el objeto. Los operadores intentan convertir el objeto a un valor primitivo, un valor <code>String</code> o <code>Number</code>, utilizando los métodos <code>valueOf</code> y <code>toString</code> de los objetos. Si falla este intento de convertir el objeto, se genera un error de tiempo de ejecución.</li>
 <li>Tenga en cuenta que un objeto se convierte en una primitiva si, y solo si, su comparando es una primitiva. Si ambos operandos son objetos, se comparan como objetos, y la prueba de igualdad es verdadera solo si ambos refieren el mismo objeto.</li>
</ul>

<div class="note"><strong>Nota:</strong> Los objetos de cadena son Tipo Objeto, no String! Los objetos de cadena rara vez se utilizan, por lo que los siguientes resultados pueden ser sorprendentes:</div>

<pre class="brush:js notranslate">// true, ya que ambos operandos son de tipo String (es decir, primitivas de cadena):
'foo' === 'foo'

var a = new String('foo');
var b = new String('foo');

// false como a y b son tipo Objeto y referencia a diferentes objetos
a == b

// false como a y b son tipo Objeto y referencia a diferentes objetos
a === b

// true como a y 'foo' son de tipo diferente y, el Objeto (a)
// se convierte en cadena 'foo' antes de la comparación
a == 'foo'</pre>

<h2 id="Especificaciones">Especificaciones</h2>

<table class="standard-table">
 <tbody>
  <tr>
   <th scope="col">Especificación</th>
   <th scope="col">Estado</th>
   <th scope="col">Comentario</th>
  </tr>
  <tr>
   <td>{{SpecName('ES1')}}</td>
   <td>{{Spec2('ES1')}}</td>
   <td>Definición inicial. Implementado en JavaScript 1.0</td>
  </tr>
  <tr>
   <td>{{SpecName('ES3')}}</td>
   <td>{{Spec2('ES3')}}</td>
   <td>
    <p>Agrega <code>===</code> y <code>!==</code> operadores. Implementado en JavaScript 1.3</p>
   </td>
  </tr>
  <tr>
   <td>{{SpecName('ES5.1', '#sec-11.8')}}</td>
   <td>{{Spec2('ES5.1')}}</td>
   <td>
    <p>Definido en varias secciones de la especificación: <a href="http://www.ecma-international.org/ecma-262/5.1/#sec-11.8">Operadores Relacionales</a>, <a href="http://www.ecma-international.org/ecma-262/5.1/#sec-11.9">Operadores de Igualdad</a></p>
   </td>
  </tr>
  <tr>
   <td>{{SpecName('ES6', '#sec-relational-operators')}}</td>
   <td>{{Spec2('ES6')}}</td>
   <td>
    <p>Definido en varias secciones de la especificación: <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-relational-operators">Operadores Relacionales</a>, <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-equality-operators">Operadores de Igualdad</a></p>
   </td>
  </tr>
  <tr>
   <td>{{SpecName('ESDraft', '#sec-relational-operators')}}</td>
   <td>{{Spec2('ESDraft')}}</td>
   <td>
    <p>Definido en varias secciones de la especificación: <a href="http://tc39.github.io/ecma262/#sec-relational-operators">Operadores Relacionales</a>, <a href="http://tc39.github.io/ecma262/#sec-equality-operators">Operadores de Igualdad</a></p>
   </td>
  </tr>
 </tbody>
</table>

<h2 id="Compatibilidad_con_navegadores">Compatibilidad con navegadores</h2>



<p>{{Compat("javascript.operators.comparison")}}</p>

<h2 id="Ver_también">Ver también</h2>

<ul>
 <li>{{jsxref("Object.is()")}}</li>
 <li>{{jsxref("Math.sign()")}}</li>
 <li><a href="/es/docs/Web/JavaScript/Equality_comparisons_and_sameness">Comparaciones de igualdad y uniformidad</a></li>
</ul>
