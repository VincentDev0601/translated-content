---
title: Uso de objetos en JavaScript
slug: Mozilla/Tech/XUL/Escuela_XUL/Uso_de_objetos_en_JavaScript
translation_of: Archive/Add-ons/Overlay_Extensions/XUL_School/JavaScript_Object_Management
---
<p>{{AddonSidebar}}</p>

<div class="blockIndicator warning">
<p>Support for extensions using XUL/XPCOM or the Add-on SDK was removed in Firefox 57, released November 2017. As there is no supported version of Firefox enabling these technologies, this page will be removed by December 2020.</p>
</div>

<p>{{LegacyAddonsNotice}}</p>

<p>{{ PreviousNext("Escuela_XUL/Agregar_barras_laterales", "Escuela_XUL/Objetos_XPCOM") }}</p>

<h2 id="Chrome_JavaScript">Chrome JavaScript</h2>

<p>In this section we'll look into how to handle JavaScript data effectively, beginning with chrome code, in ways which will prevent pollution of shared namespaces and conflicts with other add-ons resulting from such global namespace pollution.</p>

<p>The first step to good JavaScript object management is having a namespace that you know will not conflict with Firefox code or other extensions. Namespace declaration is best located in a file of its own, so that you have this one JS file that should be included in all of your XUL files.</p>

<p>We'll be using the placeholder <span class="namespace-name" style="color: gray;">〈Namespace〉</span> below. This needs to be replaced with an identifier name which is unique to your add-on. If your add-on is called <em>Sergeant Pepper</em>, for instance, then <code>SgtPepper</code> would be a good namespace name.</p>

<div class="code panel" style="border-width: 1px;">
<div class="codeContent panelContent">
<pre class="brush: js">/**
 * <span class="namespace-name" style="color: gray;">〈Namespace〉</span> namespace.
 */
if (typeof <span class="namespace-name" style="color: gray;">〈Namespace〉</span> == "undefined") {
  var <span class="namespace-name" style="color: gray;">〈Namespace〉</span> = {};
};
</pre>
</div>
</div>

<div class="panel" style="border-width: 1px;">
<div class="panelContent">
<div class="note">The naming standard that we normally follow is that the first part of the namespace corresponds to the development group (or company), and the second to the specific project. However, most extensions are small projects by individuals, so these examples follow a more practical approach of having just one namespace with the project name.</div>
</div>
</div>

<p>Notice how the <span class="namespace-name" style="color: gray;">〈Namespace〉</span> namespace is declared using <em>var</em>. We need the namespace to be a global object that it can be used everywhere in the window chrome.</p>

<p>You can include functions in any namespace, since namespaces are just regular JS objects. That should come in handy when you have general utility functions or properties that you want to use across all objects within the namespace. For instance, there are frequently used XPCOM services such as the Observer service that can be included as members in the namespace:</p>

<div class="code panel" style="border-width: 1px;">
<div class="codeContent panelContent">
<pre class="brush: js">/**
 * <span class="namespace-name" style="color: gray;">〈Namespace〉</span> namespace.
 */
if (typeof <span class="namespace-name" style="color: gray;">〈Namespace〉</span> == "undefined") {
  var <span class="namespace-name" style="color: gray;">〈Namespace〉</span> = {
    /**
     * Initializes this object.
     */
    init : function() {
      this.obsService =
        Cc["@mozilla.org/observer-service;1"].getService(Ci.nsIObserverService);
    }
  };

  /**
   * Constructor.
   */
  (function() {
    this.init();
  }).apply(<span class="namespace-name" style="color: gray;">〈Namespace〉</span>);
};
</pre>
</div>
</div>

<p>JS objects can also be treated as string-indexed arrays:</p>

<div class="panel" style="border-width: 1px;">
<div class="panelContent">
<div class="code panel" style="border-width: 1px;">
<div class="codeContent panelContent">
<pre class="brush: js">// equivalent.
<span class="namespace-name" style="color: gray;">〈Namespace〉</span>.Hello = {};
<span class="namespace-name" style="color: gray;">〈Namespace〉</span>["Hello"] = {};

// equivalent.
<span class="namespace-name" style="color: gray;">〈Namespace〉</span>.Hello.init();
<span class="namespace-name" style="color: gray;">〈Namespace〉</span>.Hello["init"]();
</pre>
</div>
</div>

<p>This is very useful in cases where you have to set attributes or functions with dynamically generated names. It's one of the funky properties of JavaScript: all objects are nothing more than name / value mappings. You can add or replace functions and attributes to any Javascript object, at any moment you want. This is an odd, but powerful feature that comes in handy at times when things get complicated. For instance, you could replace a method in any object in the Firefox chrome, so that it behaves differently than how it normally does. This should be a last resort option, but it is very useful at times.</p>
</div>
</div>

<p>You usually need only one JS file to control a XUL window, since the code required is normally not that much. If you have complex behavior that requires too much code, look for ways to divide it into multiple objects and files. You can include as many scripts in a XUL window as you need.</p>

<p>To initialize your chrome objects, it's usually better to run the initialization code from the "load" event handler for the window. The <a href="/en/XUL/Attribute/onload" title="en/XUL/Attribute/onload">load event</a> is fired after the DOM on the window has loaded completely, but before it's displayed to the user. This allows you to manipulate and possibly change elements in the window without the user noticing the changes.</p>

<div class="code panel" style="border-width: 1px;">
<div class="codeContent panelContent">
<pre class="brush: js">/**
 * Controls the browser overlay <span class="code-keyword">for</span> the Hello World extension.
 */
<span class="namespace-name" style="color: gray;">〈Namespace〉</span>.BrowserOverlay = {
  /**
   * Initializes this object.
   */
  init : function(aEvent) {
    this._stringBundle = document.getElementById("xulschoolhello-string-bundle");
    // you can make changes to the window DOM here.
  }
  // more stuff
};

window.addEventListener(
  "load", function() { <span class="namespace-name" style="color: gray;">〈Namespace〉</span>.BrowserOverlay.init(); }, false);
</pre>
</div>
</div>

<p>There are some things you can't (or shouldn't) do inside load handlers, such as closing the window being loaded, or opening new windows, alerts or dialogs. The window has to finish loading before it can do any of these things. They are bad UI practices anyway and you should avoid them. If you really need to do something like this anyway, one way to do it is to have a timeout execute the code after a delay:</p>

<div class="code panel" style="border-width: 1px;">
<div class="codeContent panelContent">
<pre class="brush: js">init : function(aEvent) {
  let that = this;

  this._stringBundle = document.getElementById("xs-hw-string-bundle");
  window.setTimeout(
    function() {
      window.alert(that._stringBundle.getString("xulschoolhello.greeting.label")); }, 0);
}
</pre>
</div>
</div>

<p>The <a href="/en/DOM/window.setTimeout" title="en/DOM/window.setTimeout">setTimeout</a> function executes the function in the first parameter, after a delay in miliseconds specified by the second parameter. In this case we set the delay to 0, which means the function should be executed as soon as possible. Firefox has a minimum delay of 10-15ms (taken from <a class="external" href="http://ejohn.org/blog/analyzing-timer-performance/">this blog post</a>), so it won't really run instantly. It is more than enough to let the window finish its load.</p>

<div class="panel" style="border-width: 1px;">
<div class="panelContent">
<div class="note">Use <a href="/en/DOM/window.setTimeout" title="en/DOM/window.setTimeout">window.setTimeout</a> and <a href="/en/DOM/window.setInterval" title="en/DOM/window.setInterval">window.setInterval</a> to control timed code execution. In case you're using JavaScript Code Modules or XPCOM objects, where a window object is not readily available, use an <a href="/en/XPCOM_Interface_Reference/nsITimer" title="en/nsITimer">nsITimer</a> instead. </div>
</div>
</div>

<div class="note"><a class="external" href="http://dbaron.org/log/20100309-faster-timeouts" title="http://dbaron.org/log/20100309-faster-timeouts">This post</a> suggests a way to achieve a true zero ms timeout, as a simple way to achieve parallelism in JS code.</div>

<p>Notice the way we send callback functions as parameters, and the use of an alternate reference for <em>this</em> which we always name <em>that</em>. This is all necessary due to a JavaScript feature (quirk would be a better word for it) called <a href="/en/JavaScript/Reference/Operators/Special/this" title="en/Core JavaScript 1.5 Reference/Operators/Special Operators/this Operator">Method Binding</a>. The consequence of doing this wrong is to have a <em>this</em> reference that doesn't do what you expected it to do. There are a few workarounds for this, and we use the ones we have found to be the most elegant and clear to read.</p>

<div class="panel" style="border-width: 1px;">
<div class="panelContent">
<div class="note">The general guideline we follow is this: whenever you have to set a callback function parameter, wrap it in an anonymous function. That is, something like <em>function() { /* your code, usually a single function call. */ }</em>. If you have to use a reference to <em>this</em> inside the function, declare a variable called <em>that</em> that equals <em>this</em>, and use <em>that</em> in the anonymous function.</div>
</div>
</div>

<p>JavaScript has a host of features that make it extremely flexible, but it also has some disadvantages, as it is not as strict as other languages, such as Java. A clear example of this is the fact that there are no <em>private</em> or <em>public</em> keywords that allow you to protect object members. As a alternative for this, a naming standard is frequently used to distinguish private and public members. There's no scope enforcement whatsoever, but this standard give others the chance to "play nice" and don't use private members.</p>

<div class="panel" style="border-width: 1px;">
<div class="panelContent">
<div class="note">Use "<em>_"</em> at the beginning of private attributes and methods in JS objects. For example: <em>_stringBundle</em>, <em>_createUserNode()</em>.</div>
</div>
</div>

<h3 id="Exercise">Exercise</h3>

<p>Here's a short exercise to test a particular aspect of the chrome. Modify the Hello World extension so that the message says how many times it has been displayed. The message could say something like "Hello! This message has been shown 5 times." Keep the counter as a variable in the <em>BrowserOverlay</em> object, and increment it every time the message is going to be shown.</p>

<p>Once you have this working right, try the following: open the message a few times, so that the number increments. Now open a new window and display the message from the new window. What do you think will happen? What will the count be this time?</p>

<p>You probably didn't expect this, but the count was reset in the new window. Each window keeps its own counter, and now the extension is not behaving as expected. This is a fundamental lesson: <strong>the chrome is not global, it's window-specific.</strong> All of your scripts and objects are replicated for each window, and they work independently from each other. This is an issue that is very easy to overlook, since most Firefox users, specially power users, have a single window open at all times. You have to make sure you test your extension with multiple windows open; never assume everything will work the same as with a single window.</p>

<p>Now, in most cases you'll need to coordinate data in a way that it is consistent for all open Firefox windows. There are several ways in which you can do this. Preferences is one of them, and they are covered in another section of this tutorial. Two other ways are JavaScript Code Modules (Firefox 3 and above), and XPCOM.</p>

<h2 id="JavaScript_Code_Modules">JavaScript Code Modules</h2>

<p><a href="/en/JavaScript_code_modules/Using" title="en/Using JavaScript code modules">JavaScript Code Modules</a> (also known as JSM) are new to Firefox 3, and they're the best tool for keeping everything in sync between windows. They're very simple to set up. The first thing you need to do is add an entry in the <em>chrome.manifest</em> file:</p>

<div class="code panel" style="border-width: 1px;">
<div class="codeContent panelContent">
<pre class="code-java">resource  xulschoolhello     modules/
</pre>
</div>
</div>

<p>Javascript code modules are accessed with the <em>resource</em> protocol, which is very similar to the <em>chrome</em> protocol. Just like with the chrome, we define the package name and then a path. To keep things simple, just locate the JSM files in a <em>modules</em> directory under the root of our project. In order to access a file <em>messageCount.js</em> in this directory, the URL would be:</p>

<div class="code panel" style="border-width: 1px;">
<div class="codeContent panelContent">
<pre class="code-java">resource:<span class="code-comment">//xulschoolhello/messageCount.js</span>
</pre>
</div>
</div>

<p>Code modules are regular JS files, so there's nothing new in regards to naming or file types. Mozilla has adopted a standard of using the extension <em>.jsm</em> for these files, but they say <em>.js</em> is fine as well. To keep things simple, specially regarding code editors and default file associations in the developer's system, we have decided to stick with <em>.js</em>.</p>

<p>Download this version of the <a href="/@api/deki/files/5143/=HelloWorld3.zip" title="https://developer.mozilla.org/@api/deki/files/5143/=HelloWorld3.zip">Hello World project with JSM</a> to see the changes you need to make to the build system in order to include the files in the <em>modules</em> folder. They are minimal, and we add a very small <em>Makefile.in</em> file in the <em>modules</em> directory, just to keep everything separated and organized.</p>

<p>With the setup out of the way, let's get to it. What are JavaScript Code Modules?</p>

<p>A JavaScript Code Module is a regular JS file that specifies which of the declared elements in it are public. All module files should begin with the a declaration like this:</p>

<div class="code panel" style="border-width: 1px;">
<div class="codeContent panelContent">
<pre class="code-java"><span class="code-keyword">var</span> EXPORTED_SYMBOLS = [ <span class="code-quote">"<span class="namespace-name" style="color: gray;">〈ModuleNamespace〉</span>"</span> ];
</pre>
</div>
</div>

<p>EXPORTED_SYMBOLS is a special identifier that tells Firefox that this file is only publishing the object named <em><span class="namespace-name" style="color: gray;">〈ModuleNamespace〉</span></em>. Several objects, functions and variables can be declared on this file, but the only object visible from the outside will be <em><span class="namespace-name" style="color: gray;">〈ModuleNamespace〉</span></em>, which is a namespace in our case. Because of namespacing, we don't need to worry much about what to export, usually we just need the namespace object. All of the objects inside of it are exported as well, since they are members of the <em><span class="namespace-name" style="color: gray;">〈ModuleNamespace〉</span></em> object.</p>

<p>Module files can be imported to a chrome script or to other code modules with the following line:</p>

<div class="code panel" style="border-width: 1px;">
<div class="codeContent panelContent">
<pre class="brush: js">Components.utils.import("<a class="external" rel="freelink">resource://xulschoolhello/messageCount.js</a>");
</pre>
</div>
</div>

<div class="note">When using <a href="/en/Components.utils.import" title="en/Components.utils.import">Components.utils.import</a>, code modules must be loaded using a <strong>file:</strong> or <strong>resource:</strong> URL pointing to a file on the disk. In particular, <strong>chrome:</strong> URLs (even those that point to a file outside a jar archive) are not valid.</div>

<p>To get a better idea, let's look at the code of the modified Hello World example. We have defined two files, one to declare namespaces and another one for the message count functionality mentioned in the previous exercise.</p>

<p>Here again we're using a placeholder, <span class="namespace-name" style="color: gray;">〈ModuleNamespace〉</span>, for the identifier name that you'll need to choose.</p>

<div class="code panel" style="border-width: 1px;">
<div class="codeContent panelContent">
<pre class="brush: js">var EXPORTED_SYMBOLS = [ "<span class="namespace-name" style="color: gray;">〈ModuleNamespace〉</span>" ];

const { classes: Cc, interfaces: Ci } = Components;

/**
 * <span class="namespace-name" style="color: gray;">〈ModuleNamespace〉</span> namespace.
 */
var <span class="namespace-name" style="color: gray;">〈ModuleNamespace〉</span> = {};
</pre>
</div>
</div>

<p>This should all be familiar enough. We're declaring the namespace we'll use at the module level. We need a separate namespace for the chrome because the chrome namespace objects are repeated for each window, while the module namespace objects are unique for all windows. Setting window-specific data on code modules will lead to nothing but problems, so be careful when deciding what should be chrome and what shouldn't be. We needn't test for the pre-existence of our namespace object here, as modules are given their own namespace.</p>

<p>The 2 declared constants above are used to reduce code size. We frequently need to use XPCOM components in our code, so instead of doing this:</p>

<div class="code panel" style="border-width: 1px;">
<div class="codeContent panelContent">
<pre class="brush: js">this.obsService =
  Components.classes["@mozilla.org/observer-service;1"].getService(Components.interfaces.nsIObserverService);
</pre>
</div>
</div>

<p>It's better to do this:</p>

<div class="code panel" style="border-width: 1px;">
<div class="codeContent panelContent">
<pre class="brush: js">this.obsService =
  Cc["@mozilla.org/observer-service;1"].getService(Ci.nsIObserverService);
</pre>
</div>
</div>

<p>These 2 constants don't need to be defined in the overlay because they are already defined globally in the <em>browser.js</em> file in Firefox. We only need to define them when we're making windows of our own, or when we're working with code outside of the chrome (or porting your code to SeaMonkey, which doesn't have those constants declared in the main window).</p>

<div class="panel" style="border-width: 1px;">
<div class="panelContent">
<div class="note">Include the Cc and Ci constants in all XUL windows that are not overlays, all JSM files, and all XPCOM components (see further ahead). Do this even if you don't need them now. It's better to just make a habit out of it.</div>
</div>
</div>

<p>This is a point that is worth highlighting: modules work outside of the window scope. Unlike scripts in the chrome, modules don't have access to objects such as <em>window</em>, <em>document</em>, or other global functions, such as <em>openUILink</em>. These are all UI components and UI operations anyway, so they are better done in the chrome.</p>

<div class="panel" style="border-width: 1px;">
<div class="panelContent">
<div class="note">As a general guideline, we keep all of our business logic in JSM, available through service objects, and chrome scripts are limited to handle presentation logic.</div>
</div>
</div>

<p>We handle most of our code through static objects, singleton objects that don't require instantiation. But it is sometimes necessary to define classes and be able to create multiple instances. Common cases include interacting with a local database or a remote API. Data will often be translated into arrays of entities, and those are better represented through classes. One way to define a class is as follows:</p>

<div class="code panel" style="border-width: 1px;">
<div class="codeContent panelContent">
<pre class="brush: js">/**
 * User class. Represents a Hello World user (whatever that may be).
 */
<span class="namespace-name" style="color: gray;">〈ModuleNamespace〉</span>.User = function(aName, aURL) {
  this._name = aName;
  this._url = aURL;
};

/**
 * User class methods.
 */
<span class="namespace-name" style="color: gray;">〈ModuleNamespace〉</span>.User.prototype = {
  /* The name of the user. */

  _name : null,
  /* The URL of the user. */

  _url : null,

  /**
   * Gets the user name.
   * @<span class="code-keyword">return</span> the user name.
   */
  get name() {
    return this._name;
  },

  /**
   * Gets the user URL.
   * @return the user URL.
   */
  get url() {
    return this._url;
  }
};
</pre>
</div>
</div>

<p>In this example we defined a fictitious <em>User</em> class for the Hello World extension. Using the function keyword to define a class is odd, but this is just the JavaScript way: functions are also objects. The definition of the class acts as a constructor as well, and then you can define all other members using the <em>prototype</em> attribute. In this case we defined "getter" properties for the <em>name</em> and <em>url</em> members. This way we have immutable instances of our class. Well, only if consumers of the class play nice and don't change anything they shouldn't.</p>

<p>Creating an instance and using it is simple enough:</p>

<div class="code panel" style="border-width: 1px;">
<div class="codeContent panelContent">
<pre class="brush: js">let user = new <span class="namespace-name" style="color: gray;">〈ModuleNamespace〉</span>.User("Pete", "<a class="external" href="http://example.com/pete" rel="freelink">http://example.com/pete</a>");

window.alert(user.name);
</pre>
</div>
</div>

<p>This is something you can do with JS in general. You can use it in JSM, chrome, even on regular web pages. Since entities tend to be used all throughout an application, we think that having those classes defined at the module level is the best approach.</p>

<p>JSM is the best solution to handle objects that are window-independent. In the following section we'll discuss XPCOM, which is an older alternative to JSM and one of the foundations of Mozilla applications. You shouldn't skip that section because there are many common situations in extension development where you'll <em>have</em> to use XPCOM, maybe even implement XPCOM components of your own.</p>

<p>{{ PreviousNext("Escuela_XUL/Agregar_barras_laterales", "Escuela_XUL/Objetos_XPCOM") }}</p>

<p><span style="font-size: small;">This tutorial was kindly donated to Mozilla by Appcoast.</span></p>
