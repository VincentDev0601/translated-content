---
title: Binding Attachment and Detachment
slug: Archive/Mozilla/XBL/XBL_1.0_Reference/Binding_Attachment_and_Detachment
tags:
  - XBL
translation_of: Archive/Mozilla/XBL/XBL_1.0_Reference/Binding_Attachment_and_Detachment
---
<p>
</p>
<h2 id="CSS_.E3.82.92.E4.BD.BF.E3.81.A3.E3.81.9F.E5.8F.96.E3.82.8A.E4.BB.98.E3.81.91" name="CSS_.E3.82.92.E4.BD.BF.E3.81.A3.E3.81.9F.E5.8F.96.E3.82.8A.E4.BB.98.E3.81.91"> CSS を使った取り付け </h2>
<p>バインディングは <a href="/ja/docs/Web/CSS/-moz-binding" title="CSS の -moz-binding プロパティは、 Mozilla ベースのアプリケーションで XBL を DOM 要素に結び付けるために使用します。"><code>-moz-binding</code></a> プロパティを使って CSS を通して要素に結びつけることができます。
</p><p><code><b>-moz-binding</b></code><br>
<i>値:</i> <code>none | [&lt;uri&gt;,]&lt;/uri&gt;* &lt;uri&gt; | inherit</code><br>
<i>初期値:</i> <code>none</code><br>
<i>適用先:</i> すべての要素 (生成された内容と疑似要素は除く)<br>
<i>継承:</i> なし<br>
<i>パーセンテージ:</i> 適用不可<br>
</p><p><code>-moz-binding</code> プロパティの値は特定のバインディングを一意に識別する URL のセットです。セットの中の個々の URL はバインディングのドキュメント URL とバインディングのドキュメントで固有の識別子から成っています。
</p><p>以下の例では、バインディングはすべての HTML checkbox (チェックボックス) 要素に結びつけられいるものに参照されています。 </p>
<pre>input[type="checkbox"] {
  -moz-binding: url("http://www.mozilla.org/xbl/htmlBindings.xml#checkbox");
}
</pre>
<p>CSS によって結びついたバインディングは要素がスタイルルールに合致しつづけている限り、バウンド要素上に残るでしょう。バウンド要素のスタイルが他のバインディングを結びつけると決定した場合、いつでも元のバインディング (とその継承のつながりで明示的に拡張されるすべてのバインディング) は分離されます。
</p><p>スタイルルールにマッチする要素にはバインディングは結びつけられませんが、display:none スタイルが設定されている要素内には結びつけられます。<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=307098" title="xbl not created when inside display:none (or hidden=true) element">バグ 307098</a> を参照してください。
</p><p>要素がドキュメントから取り除かれたときはいつでも、ドキュメントに読み込まれた CSS を通して結びつけられたどのバインディングも分離されるでしょう。 </p>
<h2 id="element.style_.E3.83.97.E3.83.AD.E3.83.91.E3.83.86.E3.82.A3.E3.82.92.E4.BD.BF.E3.81.A3.E3.81.9F.E5.8F.96.E3.82.8A.E4.BB.98.E3.81.91" name="element.style_.E3.83.97.E3.83.AD.E3.83.91.E3.83.86.E3.82.A3.E3.82.92.E4.BD.BF.E3.81.A3.E3.81.9F.E5.8F.96.E3.82.8A.E4.BB.98.E3.81.91"> element.style プロパティを使った取り付け </h2>
<p>バインディングは、<code>element.style.MozBinding</code> プロパティを適用するスクリプトを通じて要素に取り付けられます。それぞれのバインディングは、<code>element.style.MozBinding</code> を空文字列に設定することで取り外しできます。
</p><p><em>注:</em> 古い資料に書かれている <code>document.addBinding</code> や <code>document.removeBinding</code> という DOM メソッドは不要として破棄され、現在は実装されていません。
</p>
<pre>var checkbox = document.getElementById("mycheckbox");
checkbox.style.MozBinding =
 "url(http://www.mozilla.org/xbl/htmlBindings.xml#checkbox)";
</pre>
<p>この結びつけは必ずしも同期化されません。このメソッドを呼び出すスクリプトは、メソッドから返った直後にはバインディングが設定されていると仮定すべきではありません。 詳細は <a href="#バインディングドキュメント">バインディングドキュメント</a> を参照。
</p><p>バインディングが DOM を使って結びつけられるとき、それはすでに要素に結びつけられているだろう現在もっとも派生が直近のバインディングから継承します。要素に結びつけられたどのバインディングも、要素が破棄されるか対応するスタイルルールが削除されるまで要素上に残るでしょう。
</p><p>バインディングが結びつけられ、そのバインディングが既に extends 属性によって派生バインディングを定義していたなら、継承のつながりの最後の基底バインディングはすでに結びつけられたもっとも派生が直近のバインディングから継承したものになります。 </p><p>例を挙げてみます。以下の明示的継承のつながりをもつ d1 を考えてみましょう。
</p><p><i>d1</i> -&gt; <i>d2</i> -&gt; <i>d3</i>
</p><p><code>element.style.MozBinding</code> を使ってこの要素がすでに次の継承のつながりをもっている要素と結びつけたとすると、
</p><p><i>s1</i> -&gt; <i>s2</i> -&gt; <i>s3</i>
</p><p>このバインディング付加の結果としてできるバインディングのつながりは、
</p><p><i>d1</i> -&gt; <i>d2</i> -&gt; <i>d3</i> -&gt; <i>s1</i> -&gt; <i>s2</i> -&gt; <i>s3</i>
</p><p>「d3」と「s1」の間の継承は「暗黙」で、2 つのバインディングの間の XBL ドキュメントに何のつながりもありません。継承のリンクは <code>element.style.MozBinding</code> の呼び出しを通して動的に形作られます。
</p>
<h2 id=".3Cconstructor.3E_.E3.81.AE.E5.91.BC.E3.81.B3.E5.87.BA.E3.81.97" name=".3Cconstructor.3E_.E3.81.AE.E5.91.BC.E3.81.B3.E5.87.BA.E3.81.97"> &lt;constructor&gt; の呼び出し </h2>
<p>ドキュメントが呼び出され、スタイルのルールが要素に一致すると、遭遇したどのバインディングドキュメントも必要に応じて読み込まれます。バインディングドキュメントの読み込みが完了するまではバウンドドキュメントでは DOM の <code>load</code> イベントが発生しません。 <code>load</code> イベントが発生したとき、もしすべてのバインディングドキュメントの読み込みが成功したなら、すべてのバインディングはすべての要素に結びつけられたと仮定することができます。 <code>load</code> イベントが発生する間もしくは後に生成された要素については、バインディングの結びつけの順序についてどんな仮定もできません。
</p><p>バインディングが結びつけられると、以下のイベントが発生します。 </p>
<ul><li> 必要なら、無名コンテントがバインディングのコンテントテンプレートから複製され、バウンド要素に挿入されます。
</li><li> バインディングのメソッドとプロパティは要素上にインストールされ、バウンド要素を参照するスクリプトから利用可能になります。
</li><li> 定義したイベントハンドラはすべてその指定対象上に設定されます。 </li></ul>
<p>もし、バインディングが要素への結びつけに続いて初期化コードの実行を必要とするなら、<code>&lt;implementation&gt;</code> セクション内の <code>&lt;constructor&gt;</code>ブロックを使ってそれを行うことができます。このブロックはバインディングの結びつけの完了の後に実行されるスクリプトを含みます。このブロック内では <code>this</code> はバウンド要素を参照します。
</p>
<h2 id=".3Cdestructor.3E_.E3.81.AE.E5.91.BC.E3.81.B3.E5.87.BA.E3.81.97" name=".3Cdestructor.3E_.E3.81.AE.E5.91.BC.E3.81.B3.E5.87.BA.E3.81.97"> &lt;destructor&gt; の呼び出し </h2>
<p>CSS を通して結びつけられたバインディングは、以下のどれかの条件を満たすとき、切り離されます。
</p>
<ul><li> 異なるバインディングで定義されたスタイルルールにバウンド要素が一致したとき
</li><li> 要素がバウンド要素から取り除かれたとき
</li><li> (例えば、ドキュメントを閉じるなどして) 要素が破棄されたとき
</li></ul>
<p>DOM を通して結びつけられたバインディングは、以下のどれかの条件を満たすとき、切り離されます。
</p>
<ul><li> <code>MozBinding</code> スタイルルールが削除されたとき
</li><li> (例えば、ドキュメントを閉じるなどして) 要素が破棄されたとき </li></ul>
<p>バインディングが切り離されると、以下のイベントが発生します。
</p>
<ul><li> バインディングによって生成された無名コンテントは破棄されます。
</li><li> getters/setters をともなうメソッドとプロパティはバインディングからもはやアクセスできません。たとえ、生値をともなうプロパティが残っていてもです。
</li><li> どの定義されたイベントハンドラも、それぞれの対象から外されます。 </li></ul>
<p>バインディングは、バインディング分離に先立って実行される、<code>&lt;implementation&gt;</code> セクション内の <code>&lt;destructor&gt;</code> ブロックを定義することができます。バインディングは分解されるより前に、<code>&lt;destructor&gt;</code> ブロックを使って、必要なクリーンアップをすることができます。
</p><p>継承のつながりのなかのバインディングは必ず、もっとも派生したバインディングから基礎のバインディングへと切り離されます。そのため、派生バインディングの <code>&lt;destructor&gt;</code> ブロックは、実行され、基礎のバインディングのハンドラも実行されます。
</p><p>スタイルを通して結びつけられたバインディングがスタイルの変更によって切り離されるとき、DOM を使って結びつけられたほかのバインディングへは何の影響も及ぼしません。それらのバインディングはインストールされたままでしょう。もし、新しいバインディングが CSS を通して結びつけられたとき、継承のつながりのなかの DOM バインディングの後ろにインストールされます。 </p><p>例を挙げてみます。以下のバインディングのつながりをつもなうバウンド要素を考えましょう。
</p><p><i>d1</i> -&gt; <i>d2</i> -&gt; <i>d3</i> -&gt; <i>s1</i> -&gt; <i>s2</i> -&gt; <i>s3</i>
</p><p>これは CSS を通して結びつけられたバインディングを表している「s1」をともないます。バウンド要素上のスタイルの意図が新しいバインディング「t」が結びつけられるべきだという決定をすると、以下のバインディングのつながりは切り離されます。
</p><p><i>s1</i> -&gt; <i>s2</i> -&gt; <i>s3</i>
</p><p>そして、新しいバインディングが結びつけられます。最後の継承のつながりは、
</p><p><i>d1</i> -&gt; <i>d2</i> -&gt; <i>d3</i> -&gt; <i>t</i>
</p><p>バインディングが <code>element.style.MozBinding</code> を使って切り離されるとき、バインディング上の <code>extends</code> 属性を通して結びつけられたどの基礎バインディングもまた取り除かれます。つまり、<code>element.style.MozBinding</code> を削除すると、もともとの <code>element.style.MozBinding = "url(...)"</code> 呼び出しを通してインストールされたバインディングの同じグループも削除されるということです。
</p><p>この切り離しのルールは以下のようにまとめられます。バインディングが切り離されるときはいつでも、そのバインディングが明示的に継承しているバインディングもすべて切り離されます。 </p>
<h2 id=".E3.83.90.E3.82.A4.E3.83.B3.E3.83.87.E3.82.A3.E3.83.B3.E3.82.B0.E3.83.89.E3.82.AD.E3.83.A5.E3.83.A1.E3.83.B3.E3.83.88" name=".E3.83.90.E3.82.A4.E3.83.B3.E3.83.87.E3.82.A3.E3.83.B3.E3.82.B0.E3.83.89.E3.82.AD.E3.83.A5.E3.83.A1.E3.83.B3.E3.83.88"> バインディングドキュメント </h2>
<p>バインディングがほかのドキュメントの要素に結びつけられるときはいつでも、バインディングドキュメントがバウンドドキュメントではまだ使われていない場合に限って、バインディングドキュメントはフェッチされます。新しいバウンドドキュメントは使われているバインディングドキュメントごとに分けられたそれぞれの固有のコピーを持っています。
</p><p>バインディングドキュメント URL の等しいバインディングを 1 つのバウンドドキュメント中で使用していれば、それらは全て同じバインディングドキュメントを共有します。そのため、もしつながりのなかのすべてのバインディングがバウンドドキュメントにすでに読み込まれているバインディングドキュメントからもたらされたのであれば、バインディングの結びつけは (バインディングが CSS によるものでも DOM によるものでも) 同期されることが保証されます。 </p><p>必要な任意の XBL ドキュメントをプリフェッチするために <code>loadBindingDocument</code> を呼ぶことで全てのバインディングが確実に同期して付加されるようにできます。バインディングドキュメントが <code>load</code> イベントが発生する前に読み込まれている場合、読み込み後に行われる全てのバインディング付加は読み込み済みバインディングドキュメント中のバインディングによるものであれば同期されます。
</p><p><code>loadBindingDocument</code> によって得られるドキュメントはバウンドドキュメントに固有のバインディングドキュメントの複製です。バインディングドキュメントの中のバインディングは標準 DOM API を使って変更することができます。バウンドドキュメントの要素上で発生したバインディングドキュメントの中のバインディングに対する結果としてのどのバインディング付加も修正された複製を使います。ですから、新たなバインディングの定義を動的に生成したり、バインディングの無名コンテントテンプレートを作り替えて、バウンドドキュメントで使用することができます。
</p>
