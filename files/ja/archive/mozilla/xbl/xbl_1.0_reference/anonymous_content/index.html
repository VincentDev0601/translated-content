---
title: Anonymous Content
slug: Archive/Mozilla/XBL/XBL_1.0_Reference/Anonymous_Content
tags:
  - XBL
translation_of: Archive/Mozilla/XBL/XBL_1.0_Reference/Anonymous_Content
---
<h2 id=".E3.81.AF.E3.81.98.E3.82.81.E3.81.AB" name=".E3.81.AF.E3.81.98.E3.82.81.E3.81.AB">はじめに</h2>

<p>バインディングは、<code>content</code> 要素を使って「無名コンテンツテンプレート」を定義することができます。このテンプレートはバインディングの結びつけの間にバウンド要素の周辺に生成されるだろうコンテンツ (内容) ツリーを記述します。単独のタグを使ってバウンドドキュメントに宣言された要素は、複数の子供要素によって構築され、この実装(XUL側)はバウンドドキュメントから隠されます。</p>

<p>例えば、HTML ファイルアップロードコントロールは多くのブラウザではテキストフィールドとボタンで構成された混合部品として表示されます。ファイル部品のためのサンプル XBL バインディングは以下のようになるでしょう。</p>

<pre>&lt;binding id="fileupload"&gt;
  &lt;content&gt;
    &lt;html:input type="text"/&gt;
    &lt;html:input type="button"/&gt;
  &lt;/content&gt;
&lt;/binding&gt;
</pre>

<p>このコンテンツ (content) は親要素から見えないため、「匿名コンテンツ」と呼ばれます。</p>

<h2 id=".E3.82.B9.E3.82.B3.E3.83.BC.E3.83.97.E4.BD.BF.E7.94.A8_.E3.81.A8_DOM_.E3.82.92.E4.BD.BF.E3.81.A3.E3.81.9F.E3.82.A2.E3.82.AF.E3.82.BB.E3.82.B9" name=".E3.82.B9.E3.82.B3.E3.83.BC.E3.83.97.E4.BD.BF.E7.94.A8_.E3.81.A8_DOM_.E3.82.92.E4.BD.BF.E3.81.A3.E3.81.9F.E3.82.A2.E3.82.AF.E3.82.BB.E3.82.B9">スコープ使用 と DOM を使ったアクセス</h2>

<p>バインディングが結びつけられ、特定の条件が満たされたとき、バインディングの <code>content</code> 要素の子供は複製されます。XBL 名前空間の要素と属性は決して複製されません。バウンド要素の配下に生成されたコンテンツでは、最上位ノードの <code>parentNode</code> ポインタはバウンド要素に設定されます。無名コンテンツの要素はバウンド要素より上位に構築されるとき、最上位要素の <code>parentNode</code> ポインタはバウンド要素の <code>parentNode</code> に設定されます。すべての無名ノードの <code>ownerDocument</code> ポインタは生成時にバウンドドキュメントにセットされます。</p>

<p>結局、無名コンテンツはドキュメント内部の遮断された自身の領域の中に存在しています。<code>parentNode</code> を使って、無名コンテンツノードは明示された親を参照することができますが、明示された親は自分の無名子供について何も知りません。無名コンテンツはバウンド要素のための <code>childNodes</code> リストを通じてアクセス可能ではありません。そして、バウンド要素の子供を通して順次アクセスするための <code>firstChild</code>/<code>nextSibling</code> を使ったアクセスも可能ではありません。 The anonymous content is accessible only through special methods like <a href="https://developer.mozilla.org/en-US/docs/XBL/XBL_1.0_Reference/DOM_Interfaces#getAnonymousNodes" title="https://developer.mozilla.org/En/XBL/XBL_1.0_Reference/DOM_Interfaces#getAnonymousNodes"><code>getAnonymousNodes</code></a> and <a href="https://developer.mozilla.org/en-US/docs/XBL/XBL_1.0_Reference/DOM_Interfaces#getAnonymousElementByAttribute" title="https://developer.mozilla.org/En/XBL/XBL_1.0_Reference/DOM_Interfaces#getAnonymousElementByAttribute"><code>getAnonymousElementByAttribute</code></a>.</p>

<p>無名コンテンツはドキュメント内部のノードに「スコープ」の概念を取り入れます。無名コンテンツ要素はまた、その無名コンテンツを生成するのに結びつけられたバインディングを持つことができるため、このスコープ使用は任意のネストのレベルをとることができます。</p>

<p>明示的なコンテンツは「ドキュメントレベルのスコープ」であると呼ばれます。無名コンテンツノードは自身の「バインディングレベルのスコープ」にあります。バインディングのスコープは無名ノードの生成する責任を持つバインディングを含むバウンド要素によって決定されます。</p>

<p>要素のスコープは <code>DocumentXBL</code> インタフェース上の <code>getBindingParent</code> メソッドを使って決定されます。詳細情報は <a href="ja/XBL/XBL_1.0_Reference/DOM_Interfaces#The_DocumentXBL_Interface">セクション 3</a> を参照のこと。このメソッドは無名ノードに責任を持つそのノードを囲んでいるスコープの中のバウンド要素を返します。もし、ドキュメントレベルのスコープで要素上で呼び出されたら、null を返します。</p>

<p>(例えば <code>getElementsByTagName</code> のような) 要素上で呼び出されることのできる DOM メソッドは同じスコープにあるノードだけを見ることができるでしょう。(例えば <code>getElementById</code> のような) ドキュメント上で呼び出されるメソッドは、ドキュメントレベルのスコープにあるノードだけ参照することができます。</p>

<h2 id=".E3.82.B3.E3.83.B3.E3.83.86.E3.83.B3.E3.83.84.E3.81.AE.E7.94.9F.E6.88.90" name=".E3.82.B3.E3.83.B3.E3.83.86.E3.83.B3.E3.83.84.E3.81.AE.E7.94.9F.E6.88.90">コンテンツの生成</h2>

<h3 id=".E7.94.9F.E6.88.90.E3.81.AE.E8.A6.8F.E5.89.87" name=".E7.94.9F.E6.88.90.E3.81.AE.E8.A6.8F.E5.89.87">生成の規則</h3>

<p>バインディングが要素に結びつけられるときはいつでも、無名コンテンツは生成されたり破棄されたりする可能性があります。新しいバインディングが結びつけられると、明示的なつながりの中のバインディングは無名コンテンツテンプレートを持っているか見るために調べられます。テンプレートをともなうつながりの中の大半の派生バインディングは、無名コンテンツが生成されるべきか決定するのに使われるものです。</p>

<p>生成のためのチェックがなされる時にバウンド要素の下に見つかったすべての明示的なコンテンツ (内容) のためのテンプレート内部で定義されている挿入点がある時だけ、無名コンテンツはテンプレートから生成されます。バインディングが明示的なコンテンツ (内容) に対する挿入点を何も定義していなければ、バウンド要素が明示的な子供を持たない時に限り、無名コンテンツは構築されるでしょう。</p>

<p>すべての明示的な子供が有効な挿入点を持つと仮定すると、無名コンテンツはバウンド要素の下に生成されます。生成に責任を持つバインディングは「第一生成バインディング」と呼ばれます。第一生成バインディングがバウンド要素上で変更されるときはいつでも、バウンド要素のスコープにあるすべての無名ノードは破棄されます。</p>

<h3 id="contentgenerated_.E3.82.A4.E3.83.99.E3.83.B3.E3.83.88" name="contentgenerated_.E3.82.A4.E3.83.99.E3.83.B3.E3.83.88"><code>contentgenerated</code> イベント</h3>

<div class="note">
<p><strong>Note:</strong> The <code>contentgenerated</code> event is not implemented yet; see {{bug(223411)}}.</p>
</div>

<p>コンテンツがバインディングのテンプレートからビルドされるときはいつでも、<code>contentgenerated</code> が発生します。バインディングではバインディングがコンテンツを生成した後に実行されるためのスクリプトを含んだ <code>contentgenerated</code> ハンドラを定義できます。</p>

<p>コンテンツ生成ハンドラは第一生成バインディングが変化しバインディングがバウンド要素周辺でコンテンツを生成するべきと判断されるときに必ず呼び出されます。バインディングのつながりのためのこのハンドラは基底バインディングからもっとも派生したバインディングまでいつも発生します。つながりのすべてのバインディングからのコンテンツが生成されるまで、どのハンドラも呼び出されません。</p>

<h3 id="contentdestroyed_.E3.82.A4.E3.83.99.E3.83.B3.E3.83.88" name="contentdestroyed_.E3.82.A4.E3.83.99.E3.83.B3.E3.83.88"><code>contentdestroyed</code> イベント</h3>

<p>第一生成バインディングが変更 (他のバインディングになるか、まったく何にもならないか) される時はいつでも、もし無名コンテンツがすでに現在バウンド要素の周辺にある時、そのコンテンツは破棄されます。コンテンツの破棄に先立って、<code>contentdestroyed</code> イベントが発生します。</p>

<p>ハンドラはつながりの最も派生したバインディングから基底バインディングまで実行されます。すべてのハンドラはコンテンツが実際に破棄される前に発生します。ハンドラが発生した時、第一生成バインディングはまだ変更されていません。</p>

<h2 id=".E5.B1.9E.E6.80.A7.E8.BB.A2.E9.80.81" name=".E5.B1.9E.E6.80.A7.E8.BB.A2.E9.80.81">属性転送</h2>

<p>無名コンテンツ要素上の属性は、バウンド要素上の属性に結び付けることができます。属性がバウンド要素上にセットもしくは削除される時はいつでも、無名コンテンツ上の対応する属性もセットもしくは削除されます。テンプレートのどの無名コンテンツ要素上でも、<code>inherits</code> 属性は継承されるべき属性のカンマ (,) で区切られたリストで定義するために使うことができます。名前空間をともなう属性は、名前空間接頭辞を使って定義されることができ、属性名はコロン (:) で区切られます。</p>

<p>例えば、HTML ファイルアップロードコントロール上で、無名テキストフィールドは自動的にバウンド要素から <code>value</code> 属性を継承するために組み立てられます。</p>

<pre>&lt;xbl:binding id="fileUploadControl"&gt;
  &lt;xbl:content&gt;
    &lt;html:input type="text" xbl:inherits="value"/&gt;
    &lt;html:input type="button" value="Browse..."/&gt;
  &lt;/xbl:content&gt;
&lt;/xbl:binding&gt;
</pre>

<p><code>inherits</code> リストのどのエントリも、属性を単にリストする (上記例の <code>value</code> のように) ことや、バウンド要素上の属性に結び付けるべき無名コンテンツ上の属性で構成されるイコール (=) で区切られたペアの中で定義することができます。無名コンテンツ属性は最初にならべられます。</p>

<p><code>xbl:text</code> という特別な値を = で区切られたペア中で使用することができます。ここで定義されている接頭辞は XBL 名前空間のことです。ペアの左辺値として定義された時、<code>xbl:text</code> は右辺値の属性は無名要素の下のテキストノードとして貯えられるべきだということを示します。右辺値として使われた時、<code>xbl:text</code> はバウンド要素の明示的な子供の生のテキストノードは融合すべきで、戻り値は左辺値の属性として貯えられるべきだということを示します。</p>

<p><code>xbl:text</code> 値はそれ自身でリストの中に現れることはできません。<code>xbl:text</code> はイコール (=) で区切られたペアの中でだけ使われます。</p>

<p>コンテンツがテンプレートから生成された時、<code>inherits</code> 属性は複製されないことを注意してください。</p>

<h2 id=".E6.8C.BF.E5.85.A5.E7.82.B9" name=".E6.8C.BF.E5.85.A5.E7.82.B9">挿入点</h2>

<h3 id=".3Cchildren.3E_.E3.81.A8_.3Celement.3E" name=".3Cchildren.3E_.E3.81.A8_.3Celement.3E">&lt;children&gt; と &lt;element&gt;</h3>

<div class="note">
<p><strong>Note:</strong> The <code>element</code> tag is not implemented (yet?); see {{bug(98712)}}.</p>
</div>

<p><img alt="無名コンテンツの交互配置" class="internal" src="/@api/deki/files/974/=Xbl_image_1.png"></p>

<p>XBL バインディングは、無名コンテンツをバウンド要素とその明示的子供との間に綴じ込みます。それらは XBL の <code>children</code> タグや <code>element</code> タグを使うことでそのようにできます。いくつかの <code>children</code> タグはバインディングの無名コンテンツテンプレートで使われるでしょう。<code>children</code> が使われている場所は「挿入点」と呼ばれます。</p>

<p>挿入点には二種類あります。明示的なそれと、継承されたそれです。明示された挿入点はバウンド要素の明示的な子供が挿入された場所を指定します。明示的な挿入点は、第一生成バインディング上で見つかった時にだけ使われます。他のバインディング上の明示的な挿入点は無視されます。</p>

<p>継承された挿入点は、無名コンテンツを導くつながりの次のバインディングによって生成された無名コンテンツを置くのに使われます。そのバインディングは基底バインディングのための継承された挿入点を定義することもできます。このパターンはバインディングのつながりのすべての段階で同様です。</p>

<p><code>includes</code> 属性を使って定義された XPath セレクタはどの挿入点の下に与えられた子供を置くべきかを決めます。どの属性も定義されていない時、挿入点は一般のものと考えられ、すべてのコンテンツに一致します。</p>

<p>与えられたコンテンツの断片のために使われた挿入点は、コンテンツテンプレートの第一階層であるとき、要素に合致するノードセットのセレクタに、はじめて遭遇しました。</p>

<p><code>element</code> タグは無名コンテンツを生成する要素に関係するバウンド要素の位置を定義します。たった一つの <code>element</code> タグだけが無名コンテンツテンプレートに存在することができます。第一生成バインディングでないバインディング上に働きかけるどの <code>element</code> タグも無視されます。もし、バウンド要素がそれを生成する無名コンテンツの下などに再配置されると、第一バインディングに生成されたすべてのルート無名要素は修正されたツリーのバウンド要素のために使われる挿入点に配置されます。</p>

<p><code>element</code> 要素と <code>children</code> 要素は、コンテンツがテンプレートから生成された時、決して複製されないことに注意してください。</p>

<h3 id="DOM_.E3.81.AE.E5.A4.89.E6.9B.B4.E3.81.AE.E5.87.A6.E7.90.86" name="DOM_.E3.81.AE.E5.A4.89.E6.9B.B4.E3.81.AE.E5.87.A6.E7.90.86">DOM の変更の処理</h3>

<p>挿入点は、要素が DOM へ挿入されたり、DOM から切り離されたりする時に、使われるために続きます。要素が挿入または追加される時、すべての挿入点は無名コンテンツ生成の間明示された子供を最初に配置する時に適用されるのとまったく同じ規則に従ってチェックされます。新しく挿入された子供に、挿入点が見つからなければ、バインディングはもうバウンド要素にはめ込まれず、すべての無名コンテンツは破棄されます。</p>

<p>要素が取り除かれた時はいつでも、それは単に要素に生成されたすべての無名コンテンツに従ってその挿入点から見えなくなります。</p>

<p>標準 DOM API を使ってバウンド要素の下に含まれる無名コンテンツを操作することは可能です。もし、挿入点を含んだ無名コンテンツが削除されると、挿入点の下で見つかったどの明示された子供も一致する他の挿入点に再配置されます。繰り返しますが、もしすべての子供が再配置されなければ、無名コンテンツは破棄されます。</p>

<p>{{ mediawiki.external('編集者メモ: 挿入点回収、動的挿入点新規作成、挿入点削除といった API は必要か？ ElementXBL 上ではどうか？') }}</p>

<h2 id=".E3.82.A4.E3.83.99.E3.83.B3.E3.83.88.E3.83.95.E3.83.AD.E3.83.BC.E3.81.A8.E3.82.BF.E3.83.BC.E3.82.B2.E3.83.83.E3.83.88" name=".E3.82.A4.E3.83.99.E3.83.B3.E3.83.88.E3.83.95.E3.83.AD.E3.83.BC.E3.81.A8.E3.82.BF.E3.83.BC.E3.82.B2.E3.83.83.E3.83.88">イベントフローとターゲット</h2>

<h3 id=".E3.83.95.E3.83.AD.E3.83.BC.E3.81.A8.E3.82.B9.E3.82.B3.E3.83.BC.E3.83.97.E3.82.92.E8.B6.85.E3.81.88.E3.81.9F.E3.82.BF.E3.83.BC.E3.82.B2.E3.83.83.E3.83.88.E8.A8.AD.E5.AE.9A" name=".E3.83.95.E3.83.AD.E3.83.BC.E3.81.A8.E3.82.B9.E3.82.B3.E3.83.BC.E3.83.97.E3.82.92.E8.B6.85.E3.81.88.E3.81.9F.E3.82.BF.E3.83.BC.E3.82.B2.E3.83.83.E3.83.88.E8.A8.AD.E5.AE.9A">フローとスコープを超えたターゲット設定</h3>

<p>DOM イベントは、明示された対象上で可能に発生するのと同様に、無名対象上で発生します。イベントフローが同じスコープの中にある限り、<a class="external" href="http://www.w3.org/TR/2000/PR-DOM-Level-2-Events-20000927/">DOM Level 2 Events 仕様書</a> で概説されている振る舞いと違いはありません。</p>

<p>イベントは、全要素が <code>children</code> タグと <code>element</code> タグによって再配置された後の最終的な変換後のコンテンツモデルを流れていきます。</p>

<p>バウンド要素のスコープにある無名要素からバウンド要素自身へイベントがフローする (流れる) ときはいつでも、二つのうちいずれかの動きが発生します。一方のイベントはバウンド要素が対象になるための対象変更で、もう一方のイベントは停止と次のフェーズへの移行です。イベントが対象変更となると、イベントの <code>target</code> フィールドはバウンド要素に設定されます。イベントの発生源である元の無名コンテンツはイベントオブジェクトの新しいフィールドである <code>originalTarget</code> から得ることができます。</p>

<pre class="eval">(対象変更か停止か) いずれの動きが起きるかは、イベント型により限定されます。一般に、UI イベントは対象変更し、変異イベントは停止します。この規則の例外を後述します。
</pre>

<h3 id="focus_.E3.81.A8_blur_.E3.82.A4.E3.83.99.E3.83.B3.E3.83.88" name="focus_.E3.81.A8_blur_.E3.82.A4.E3.83.99.E3.83.B3.E3.83.88">focus と blur イベント</h3>

<p>focus イベントや blur イベントがスコープの境界を横切るとき、バウンド要素はフォーカス可能かどうか確かめられます。例えば、ユーザエージェントは通常、要素上でフォーカスを得るイベントやフォーカスが離れるイベントを起こします。もし、バウンド要素がフォーカス設定可能なら、そのイベントは目標再設定します。もし、フォーカス設定不能なら、イベントは停止します。フォーカス可能なバウンド要素の下の無名コンテンツのフォーカスが外れ、バウンド要素の無名コンテンツがまたフォーカスを得たとき、フォーカスの離れとフォーカスを得るの両方のイベントは停止します。バウンド要素に関する限り、二つのイベントを通してフォーカスは保たれます。</p>

<p>無名コンテンツはユーザがドキュメントを通してタブで指定したときにフォーカスを受け取ります。同じルールが当てはまります。もし、無名コンテンツがフォーカス設定可能なら、タブでの指定も可能です。しかし、バウンド要素がフォーカス設定不可能なら、イベントはそのバウンド要素に届く前に停止するでしょう。</p>

<p>HTML 4 では、<code>tabindex</code> 属性をフォーカス設定可能な要素のタブ順序を指定するために使うことが出来ます。この属性は無名コンテンツ上にも指定可能です。スコープそれぞれが固有のタブ順序を持っています。あるのスコープ内でのtabindex 値は、他のスコープでは無視されます。</p>

<p>例として、upload (アップロード) コントロールの HTML を考えてみます。これは textfield (テキストフィールド) と button (ボタン) という、二つの交互のフォーカス可能な無名要素からなるフォーカス可能な要素です。テキストフィールドとボタン上では、タブは順序は、タブ押下時に file (ファイル) コントロールのコンポーネントがアクセスされるべき順番を決定するために指定されるべきです。</p>

<p>ユーザが file (ファイル) コントロールがフォーカスを得るようタブを押下したとき、ユーザエージェントは、無名コンテンツ要素によって指定されるタブ順序を使って、いずれかの無名コンテンツもフォーカスを得たのかを決定しなければなりません。そして、file コントロール内部でテキストフィールド上でフォーカスイベントが生成されます。このイベントの流れがスコープを横切ったとき、file コントロール自身の上でフォーカスイベントとなるよう対象が再設定されます。</p>

<p>バウンド要素がすでにフォーカスを得ている場合も、フォーカスイベントは停止されます。たとえば、もしユーザがすでに HTML ファイルアップロードコントロール内部のテキストフィールドにフォーカスを得ているならば、そのファイルアップロードコントロールは今、フォーカスを得ています。もしユーザがまた、ファイルアップロードコントロールの内部のボタンにフォーカスを合わせたとき、そのボタンのために生成されたフォーカスイベントはファイルコントロールに届く前に停止します。それは、ファイルコントロールがすでにフォーカスを得ているからです。</p>

<p>複数のスコープの中のコンテンツがフォーカス可能なため、CSS <code>:focus</code> 疑似要素は階層的です。スタイルルールは、(上記の例の中の) ファイルコントロールとファイルコントロール内部のフォーカスを得た要素の両方にマッチすると仮定して書くことができます。言い換えれば、要素の任意のつながりが、<code>:focus</code> 状態の中に同時にあることができます。</p>

<h3 id="mouseover_.E3.81.A8_mouseout_.E3.82.A4.E3.83.99.E3.83.B3.E3.83.88" name="mouseover_.E3.81.A8_mouseout_.E3.82.A4.E3.83.99.E3.83.B3.E3.83.88">mouseover と mouseout イベント</h3>

<p>mouseover イベントと mouseout イベントは、マウスが本当に (ある無名コンテンツに入っていくか出ていくのに加えて) バウンド要素に入ってくか出ていく時にターゲットを新たに定めます。もし、しかし、ユーザがバウンド要素自身から出入りすることなく単に無名要素から他へマウスを動かしたとすると、イベントは停止します。</p>

<p>例えば、もしユーザが左から HTML ファイルアップロードコントロールに入ると、mouseover イベントは無名の textfield に対して生成されます。このイベントはまた、file コントロール自身の mouseover も構成要素としているため、このイベントはスコープをまたいで流れるとき、対象が再設定されます。もし、ユーザが textfield から button へマウスを動かせば、mouseout は textfield に生成され、button の mouseover が後を追います。</p>

<p>これらのいずれのイベントも file コントロール自身の mouseover か mouseout で構成されるため、このイベントは file コントロール自身を流れることは許されません。もし、ユーザが右へマウスを動かし続け、button を離れたら、file コントロールをも出てしまっているため、そのとき生成された mouseout は対象を再設定されます。</p>

<h2 id=".E7.84.A1.E5.90.8D.E3.82.B3.E3.83.B3.E3.83.86.E3.83.B3.E3.83.84.E3.81.A8_CSS" name=".E7.84.A1.E5.90.8D.E3.82.B3.E3.83.B3.E3.83.86.E3.83.B3.E3.83.84.E3.81.A8_CSS">無名コンテンツと CSS</h2>

<h3 id=".E3.82.BB.E3.83.AC.E3.82.AF.E3.82.BF.E3.81.A8.E3.82.B9.E3.82.B3.E3.83.BC.E3.83.97" name=".E3.82.BB.E3.83.AC.E3.82.AF.E3.82.BF.E3.81.A8.E3.82.B9.E3.82.B3.E3.83.BC.E3.83.97">セレクタとスコープ</h3>

<p>バインディングは無名要素をバウンド要素とその明示的な子供との間に綴じ込みます。詳細は <a href="#Insertion_Points">挿入点</a> を参照のこと。この状況では、明示的コンテンツのノードツリーとは違った新しいツリーが現れます。単独の明示的な親 (バウンド要素) を持つのに加えて、明示的な子供は (子供の挿入点もしくは <code>element</code> タグが使われたときバインディングに生成される) 任意の無名な親のセットをも持ちます。子供、子孫、そして兄弟のセレクタは無名もしくは明示的な要素のパスにマッチします。</p>

<p>CSS に関する限り、無名コンテンツのノードはバウンド要素の子供 (もしくは子孫) です。これらは明示的コンテンツの先祖で、明示的コンテンツの兄弟です。子供、子孫、兄弟セレクタに適用されるスタイルルールは透過してバインディングのスコープを横切り、変更されたもしくはオリジナルのままのコンテンツモデル上で操作されます。</p>

<p>最後に修正されたコンテンツツリーはどのように CSS プロパティ (例：font や color) が継承されるかを決定します。要素は、(ちょうどコンテンツモデルにおいて見られるように) その明示的な親の下になるに至るか、挿入点のつながりを通すネストになるに至ります。ネストになった場合、もっとも内側の無名の親から継承します。</p>

<h3 id=".E3.83.90.E3.82.A4.E3.83.B3.E3.83.87.E3.82.A3.E3.83.B3.E3.82.B0.E3.82.B9.E3.82.BF.E3.82.A4.E3.83.AB.E3.82.B7.E3.83.BC.E3.83.88" name=".E3.83.90.E3.82.A4.E3.83.B3.E3.83.87.E3.82.A3.E3.83.B3.E3.82.B0.E3.82.B9.E3.82.BF.E3.82.A4.E3.83.AB.E3.82.B7.E3.83.BC.E3.83.88">バインディングスタイルシート</h3>

<p>バインディングファイルは <code>stylesheet</code> 要素を使ってスタイルシートを読み込むことができます。デフォルトでは、これらのスタイルシートはバウンド要素と、そしてバウンド要素へ結び付けられたすべてのバインディングから生成されたすべての無名コンテンツに適用されます。これらのシートはバインディングが担うルールをともなうシート同様の同じ起源を持っています。DOM を使って結び付けられたバインディングによって読み込まれたスタイルシートは author レベルのシートとして扱われます。</p>

<p>{{ mediawiki.external('編集者メモ: バインディングの継承がこのカスケード適用を複雑にしています。author レベルの DOM バインディングは user レベルのバインディングから継承されることもあるからです。もし、両方がシートを読み込んだら、連鎖的適用の中でそれらのシートがどのレベルに属するのか？') }}</p>

<p>シートはいつももっとも内側のスコープからもっとも外側のスコープへ向かって進みます。この順序であることにより、ウィジェットを定義するバインディングは、ウィジェットのクライアントによって簡単に上書きされうるウィジェットのためのデフォルトの見た目を定義することが出来ます。複数のバインディングが同じ要素に結びつけられたために、シートは基底バインディングからもっとも派生したバインディングにかけて下って進みます。</p>

<p>バインディングでは二つの属性によってスタイルシートのスコープを微調整することができます。一つは <code>inheritstyle</code> で、外のスコープで定義された author シートがインディングに生成された無名コンテンツに影響を与えるかどうかを指定します。第一生成バインディングのみのため、この属性は、スコープが外側のレベルであるいずれかの author シートがバウンド要素に結びつけられたバインディングによって生成された無名コンテンツへ適用されるべきかをみるためにチェックされます。もしこの属性がセットされていれば、外のスコープの author シートで定義されたルールまでたどり着きません。</p>

<p>デフォルトでは、バインディングファイルで定義されたスタイルシートはバウンド要素と要素に結びつけられたバインディングによって生成された無名コンテンツにだけ適用されます。</p>

<p>ユーザエージェントシートとユーザシートは、いつでもすべてのスコープに適用されます。</p>
