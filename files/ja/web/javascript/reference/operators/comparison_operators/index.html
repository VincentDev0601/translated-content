---
title: 比較演算子
slug: Web/JavaScript/Reference/Operators/Comparison_Operators
tags:
  - JavaScript
  - Operator
  - Reference
  - 演算子
translation_of: Web/JavaScript/Reference/Operators
translation_of_original: Web/JavaScript/Reference/Operators/Comparison_Operators
---
<div>{{jsSidebar("Operators")}}</div>

<p>JavaScript には、厳密な比較と型変換の比較の両方があります。厳密な比較 (例: <code>===</code>) は、オペランドが同じ型で、内容も一致している場合にのみ真になります。もっとよく使用される抽象的な比較 (例: <code>==</code>) は、比較する前にオペランドを同じ型に変換します。抽象的な関係比較 (例: <code>&lt;=</code>) では、比較前にまずオペランドがプリミティブ型に変換され、それから同じ型に変換されます。</p>

<p>文字列は Unicode 値を使用した標準的な辞書順に基づいて比較されます。</p>

<div>{{EmbedInteractiveExample("pages/js/expressions-equality.html")}}</div>

<div>
<div>{{EmbedInteractiveExample("pages/js/expressions-strict-equality.html")}}</div>
</div>

<div></div>

<p class="hidden">このデモのソースファイルは GitHub リポジトリに格納されています。デモプロジェクトに協力したい場合は、 <a href="https://github.com/mdn/interactive-examples">https://github.com/mdn/interactive-examples</a> をクローンしてプルリクエストを送信してください。</p>

<p>比較の機能は以下のとおりです。</p>

<ul>
 <li>2 つの文字列が厳密に等しくなるのは、字の順序が等しく、長さが等しく、対応する位置の文字が等しいときです。</li>
 <li>2 つの数字が厳密に等しくなるのは、数値的に等しいとき (数字の値が等しいとき) です。<a href="/ja/docs/Web/JavaScript/Reference/Global_Objects/NaN" title="NaN">NaN</a> は、どんなものとも (Nan とさえも) 等しくなりません。プラスゼロとマイナスゼロは互いと等しくなります。</li>
 <li>2 つの論理オペランドが厳密に等しくなるのは、どちらも <code>true</code> か、どちらも <code>false</code> のときです。</li>
 <li>2 つの異なるオブジェクトは、厳密な比較でも抽象的な比較でも等しくなりません。</li>
 <li>オブジェクト比較が等しくなるのは、オペランドが同じオブジェクトを参照しているときだけです。</li>
 <li>Null と Undefined 型は、自分自身と厳密に等しく、また互いに抽象的に等しくなります。</li>
</ul>

<h2 id="Equality_operators" name="Equality_operators">等価演算子</h2>

<h3 id="Equality" name="Equality">等価 (==)</h3>

<p>等価演算子は、2 つのオペランドが<strong>同じ型でないならば</strong>オペランドを変換して、それから厳密な比較を行います。<strong>両方のオペランドがオブジェクトならば</strong>、 JavaScript は内部参照を比較するので、オペランドがメモリ内の同じオブジェクトを参照するときに等しくなります。</p>

<h4 id="Syntax" name="Syntax">構文</h4>

<pre class="syntaxbox notranslate">x == y
</pre>

<h4 id="Examples" name="Examples">例</h4>

<pre class="brush: js notranslate">1    ==  1         // true
'1'  ==  1         // true
1    == '1'        // true
0    == false      // true
0    == null       // false
var object1 = {'key': 'value'}, object2 = {'key': 'value'};
object1 == object2 // false
0    == undefined  // false
null == undefined  // true
</pre>

<h3 id="Inequality" name="Inequality">不等価 (!=)</h3>

<p>不等価演算子は、オペランド同士が等しくないならば真を返します。2 つのオペランドが<strong>同じ型でないならば</strong>、JavaScript は適切な型にオペランドを変換して比較しようとします。<strong>両方のオペランドがオブジェクトならば</strong>、JavaScript は内部参照を比較するので、オペランドがメモリ内の異なるオブジェクトを参照するときには等しくなりません。</p>

<h4 id="Syntax_2" name="Syntax_2">構文</h4>

<pre class="syntaxbox notranslate">x != y</pre>

<h4 id="Examples_2" name="Examples_2">例</h4>

<pre class="brush: js notranslate">1 !=   2     // true
1 !=  '1'    // false
1 !=  "1"    // false
1 !=  true   // false
0 !=  false  // false
</pre>

<h3 id="Identity" name="Identity">一致 / 厳密等価 (===)</h3>

<p>厳密等価演算子は、<strong>型変換なしで</strong>オペランド同士が (上に示した通り) 厳密に等しければ真を返します。</p>

<h4 id="Syntax_3" name="Syntax_3">構文</h4>

<pre class="syntaxbox notranslate">x === y</pre>

<h4 id="Examples_3" name="Examples_3">例</h4>

<pre class="brush: js  notranslate">3 === 3   // true
3 === '3' // false
var object1 = {'key': 'value'}, object2 = {'key': 'value'};
object1 === object2 //false</pre>

<h3 id="Nonidentity" name="Nonidentity">不一致 / 厳密不等価 (!==)</h3>

<p>厳密不等価演算子は、<strong>オペランド同士が等しくないか、型が等しくない、あるいはその両方</strong>ならば真を返します。</p>

<h4 id="Syntax_4" name="Syntax_4">構文</h4>

<pre class="syntaxbox notranslate">x !== y</pre>

<h4 id="Examples_4" name="Examples_4">例</h4>

<pre class="brush: js notranslate">3 !== '3' // true
4 !== 3   // true
</pre>

<h2 id="Relational_operators" name="Relational_operators">関係演算子</h2>

<p>これらの演算子のそれぞれは、比較が行われる前に、そのオペランドをプリミティブに{{Glossary("Type_coercion", "型強制")}}します。両方とも文字列として終わる場合は、辞書順で比較され、そうでない場合は数値に変換されて比較されます。 <code>NaN</code> との比較は常に <code>false</code> を生み出します。</p>

<h3 id="Greater_than_operator" name="Greater_than_operator">大なり演算子 (&gt;)</h3>

<p>大なり演算子は、左オペランドが右オペランドより大きければ、真を返します。</p>

<h4 id="Syntax_5" name="Syntax_5">構文</h4>

<pre class="syntaxbox notranslate">x &gt; y</pre>

<h4 id="Examples_5" name="Examples_5">例</h4>

<pre class="brush: js notranslate">4 &gt; 3 // true
</pre>

<h3 id="Greater_than_or_equal_operator" name="Greater_than_or_equal_operator">大なりイコール演算子 (&gt;=)</h3>

<p>大なりイコール演算子は、左オペランドが右オペランド以上ならば、真を返します。</p>

<h4 id="Syntax_6" name="Syntax_6">構文</h4>

<pre class="syntaxbox notranslate"> x &gt;= y</pre>

<h4 id="Examples_6" name="Examples_6">例</h4>

<pre class="brush: js notranslate">4 &gt;= 3 // true
3 &gt;= 3 // true
</pre>

<h3 id="Less_than_operator" name="Less_than_operator">小なり演算子 (&lt;)</h3>

<p>小なり演算子は、左オペランドが右オペランドより小さければ、真を返します。</p>

<h4 id="Syntax_7" name="Syntax_7">構文</h4>

<pre class="syntaxbox notranslate"> x &lt; y</pre>

<h4 id="Examples_7" name="Examples_7">例</h4>

<pre class="brush: js notranslate">3 &lt; 4 // true
</pre>

<h3 id="Less_than_or_equal_operator" name="Less_than_or_equal_operator">小なりイコール演算子 (&lt;=)</h3>

<p>小なりイコール演算子は、左オペランドが右オペランド以下ならば、真を返します。</p>

<h4 id="Syntax_8" name="Syntax_8">構文</h4>

<pre class="syntaxbox notranslate"> x &lt;= y</pre>

<h4 id="Examples_8" name="Examples_8">例</h4>

<pre class="brush: js notranslate">3 &lt;= 4 // true
3 &lt;= 3 // true
</pre>

<h2 id="Using_the_equality_operators" name="Using_the_equality_operators">等価演算子の使用</h2>

<p>標準等価演算子 (<code>==</code> と <code>!=</code>) は 2 つのオペランドの比較に<a href="http://www.ecma-international.org/ecma-262/5.1/#sec-11.9.3">抽象的等価比較アルゴリズム</a>を使用します。オペランドの型が異なる場合は、比較を行う前にそれらを同じ型に変換しようとします。例えば <code>5 == '5'</code> という式では、比較を行う前に右オペランドの文字列を数値に変換します。</p>

<p>厳密等価演算子 (<code>===</code> と <code>!==</code>) は<a href="http://www.ecma-international.org/ecma-262/5.1/#sec-11.9.6">厳密等価比較アルゴリズム</a>を使用して、オペランドの型が同一かどうかに関する比較も行います。オペランドの型が異なれば、例えば <code>5</code> と <code>'5'</code> の比較では、同一性比較 <code>5 !== '5'</code> は <code>true</code> と評価され、 <code>5 === '5'</code> のチェックは <code>false</code> 評価されます。</p>

<p>厳密等価演算子を使うのは、オペランドが特定の型の特定の値でなければならない場合、言い換えればオペランドの正確な型が重要な場合です。それ以外では、2 つのオペランドが同じ型でなくても比較が可能になる、標準的な等価演算子を使えます。</p>

<p>比較に型の変換が関わるとき (つまり厳密でない比較のとき)、 JavaScript は以下のように {{jsxref("String")}}, {{jsxref("Number")}}, {{jsxref("Boolean")}}, {{jsxref("Object")}} 型のオペランドを変換します。</p>

<ul>
 <li>数値と文字列を比較するとき、文字列は数値に変換されます。 JavaScript は文字列の数値リテラルを <code>Number</code> 型の値に変換しようとします。まず、文字列の数値リテラルから数学的な値を引き出します。次に、その値を最も近い <code>Number</code> 型に丸めます。</li>
 <li>もしオペランドの片方が <code>Boolean</code> ならば、その Boolean オペランドが <code>true</code> の場合 1 に、<code>false</code> の場合は +0 に変換されます。</li>
 <li>オブジェクトを数値または文字列と比較すると、 JavaScript はそのオブジェクトの既定値を返そうとします。演算子は、オブジェクトの <code>valueOf</code> や <code>toString</code> といったメソッドを用いて、プリミティブな値、 <code>String</code> か <code>Number</code> の値に変換しようとします。変換に失敗したら、ランタイムエラーが発生します。</li>
 <li>オブジェクトがプリミティブ値に変換されるのは、比較対象がプリミティブ値であるときだけです。両方のオペランドがオブジェクトなら、オブジェクトとして比較され、両方が同じオブジェクトを参照するときだけ真となります。</li>
</ul>

<div class="note"><strong>メモ:</strong> String オブジェクトはオブジェクト型であり、文字列型ではありません！ String オブジェクトはほとんど使わないので、次の結果に驚くかもしれません。</div>

<pre class="brush:js notranslate">// 両方のオペランドが文字列型 (すなわちプリミティブな文字列) なので、true
'foo' === 'foo'

var a = new String('foo');
var b = new String('foo');

// a と b はオブジェクト型で、異なるオブジェクトを参照しているので、false
a == b

// a と b はオブジェクト型で、異なるオブジェクトを参照しているので、false
a === b

// a と 'foo' は異なる型で、比較前にオブジェクト (a) は
// 文字列 'foo' に変換されるので、真
a == 'foo'</pre>

<h2 id="Specifications" name="Specifications">仕様書</h2>

<table class="standard-table">
 <thead>
  <tr>
   <th scope="col">仕様書</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>{{SpecName('ESDraft', '#sec-equality-operators', 'Equality Operators')}}</td>
  </tr>
  <tr>
   <td>{{SpecName('ESDraft', '#sec-relational-operators', 'Relational Operators')}}</td>
  </tr>
 </tbody>
</table>

<h2 id="Browser_compatibility" name="Browser_compatibility">ブラウザーの互換性</h2>

<div class="hidden">このページの互換性一覧表は構造化データから生成されています。データに協力していただけるのであれば、 <a class="external" href="https://github.com/mdn/browser-compat-data">https://github.com/mdn/browser-compat-data</a> をチェックアウトしてプルリクエストを送信してください。</div>

<p>{{Compat("javascript.operators.comparison")}}</p>

<h2 id="See_also" name="See_also">関連情報</h2>

<ul>
 <li>{{jsxref("Object.is()")}}</li>
 <li>{{jsxref("Math.sign()")}}</li>
 <li><a href="/ja/docs/Web/JavaScript/Equality_comparisons_and_sameness">等価性の比較とその使いどころ</a></li>
</ul>
