---
title: HTTP Pipelining FAQ
slug: conflicting/Web/HTTP/Connection_management_in_HTTP_1.x
tags:
  - Necko
translation_of: Web/HTTP/Connection_management_in_HTTP_1.x
translation_of_original: Web/HTTP/Pipelining_FAQ
original_slug: HTTP_Pipelining_FAQ
---
<p><b>HTTP/1.1 パイプライン化 FAQ</b>
</p>
<h3 id="HTTP_.E3.83.91.E3.82.A4.E3.83.97.E3.83.A9.E3.82.A4.E3.83.B3.E5.8C.96.E3.81.A8.E3.81.AF.EF.BC.9F"> HTTP パイプライン化とは？ </h3>
<p>通常、HTTP リクエストは、次のリクエストは完全に受け取られた現在のリクエストに対するレスポンスのあとにだけ発行されるという形で、連続して発行されます。ネットワークの待ち時間と帯域幅の制限により、次のリクエストがサーバによって受け取られるまでに、著しい遅れを生じさせることもあります。
</p><p>HTTP/1.1 では、複数 HTTP リクエストを対応するレスポンスを待つことなくソケットに同時に書き出すことを許しています。リクエスト発行者は、リクエストされた順序での到着のためのレスポンスを待っています。リクエストの「パイプライン化」の作用でページ読み込み時に劇的に改善をみせることもあります。高い待ち時間をともなう接続においては特にそうです。
</p><p>パイプライン化はまた、TCP/IP パケットの数を劇的に減少させることもあります。536 ～ 1460 バイトの典型的な MSS (最大セグメントサイズ) で、1 つの TCP/IP パケットにいくつかの HTTP リクエストが可能です。少ないパケットは通常、IP ルータとネットワークの負荷を減らすため、読み込みに必要なパケットの数を減らすことは、全体としてはインターネットに利益になります。
</p><p>HTTP/1.1 に合致するサーバはパイプライン化のサポートが必要とされています。これはサーバにパイプライン化したレスポンスが必要とされることを意味するわけではありません。しかし、クライアントがパイプライン化したリクエストを選択した時に失敗してはいけないことを要求します。著名な Mozilla 以外のブラウザがパイプライン化を実装していないため、これは明らかにエバンジェリズム (啓蒙) に関する新しいカテゴリのバグとなる可能性があります。
</p>
<h3 id=".E3.83.91.E3.82.A4.E3.83.97.E3.83.A9.E3.82.A4.E3.83.B3.E5.8C.96.E3.81.97.E3.81.9F.E3.83.AA.E3.82.AF.E3.82.A8.E3.82.B9.E3.83.88.E3.82.92.E3.81.84.E3.81.A4.E3.81.99.E3.81.B9.E3.81.8D.E3.81.A7.E3.81.99.E3.81.8B.EF.BC.9F"> パイプライン化したリクエストをいつすべきですか？ </h3>
<p>GET や HEAD といったリクエストのように独立したリクエストだけが、パイプライン化可能です。POST と PUT といったリクエストはパイプライン化すべきではありません。新しいコネクションの上でもまた、パイプライン化したリクエストをすべきではありません。なぜなら、相手のサーバ (もしくはプロキシ) が HTTP/1.1 をサポートしているかどうかまだわからないからです。そのために、パイプライン化は存在する「keep-alive」接続の再利用時のみ可能です。
</p>
<h3 id=".E3.81.A9.E3.81.AE.E3.81.8F.E3.82.89.E3.81.84.E3.81.AE.E6.95.B0.E3.81.AE.E3.83.AA.E3.82.AF.E3.82.A8.E3.82.B9.E3.83.88.E3.81.AE.E3.83.91.E3.82.A4.E3.83.97.E3.83.A9.E3.82.A4.E3.83.B3.E5.8C.96.E3.82.92.E3.81.99.E3.81.B9.E3.81.8D.E3.81.A7.E3.81.97.E3.82.87.E3.81.86.E3.81.8B.EF.BC.9F"> どのくらいの数のリクエストのパイプライン化をすべきでしょうか？ </h3>
<p>うーん。多くのリクエストのパイプライン化は、もし早い時点でコネクションが切断された場合コストが高くつきます。新しいコネクションの上でだけ繰り返せばいいのに、ネットワークへリクエストを書き出す時間を浪費するからです。そのうえ、最初のリクエストが完了するのに長い時間がかかると、長いパイプライン化は実際にユーザに知覚されてしまうほどの遅れを引き起こします。サーバあたり、2 つの「keep-alive」接続を超えないという制限を勧めます。明らかに、それはアプリケーションに依存します。Web ブラウザはたぶん、前述の理由のためにあまりに長いパイプライン化は望まないでしょう。2 というのは適切な値でしょう。しかし、この数値にはまだ試行により変えられる余地があります。
</p>
<h3 id=".E3.82.82.E3.81.97.E3.80.81.E3.83.AA.E3.82.AF.E3.82.A8.E3.82.B9.E3.83.88.E3.81.8C.E3.82.AD.E3.83.A3.E3.83.B3.E3.82.BB.E3.83.AB.E3.81.95.E3.82.8C.E3.81.9F.E3.82.89.E3.81.A9.E3.81.86.E3.81.AA.E3.82.8B.E3.81.AE.E3.81.A7.E3.81.97.E3.82.87.E3.81.86.E3.81.8B.EF.BC.9F"> もし、リクエストがキャンセルされたらどうなるのでしょうか？ </h3>
<p>もし、リクエストがキャンセルされたとき、パイプライン全体がキャンセルされるのでしょうか？ それとも、パイプラインに属する他のリクエストを繰り返すことを強いてはいけないので、キャンセルされたリクエストだけがただ単に捨てられるべきなのでしょうか？ 答えは、受け取られていないままキャンセルされたリクエストに対するレスポンスの破片のサイズを含むいくつかの要素に依存します。実直なアプローチでは、ただパイプラインをキャンセルし、すべてのリクエストを再発行するというのもあるでしょう。これは、リクエストが一度の発行で何度も利用できるときだけできることです。パイプライン化さているリクエストは大抵、キャンセルされている同じ読み込みのグループ (ページ) に属するので、この実直なアプローチはよく筋が通っています。
</p>
<h3 id=".E3.82.B3.E3.83.8D.E3.82.AF.E3.82.B7.E3.83.A7.E3.83.B3.E3.81.AB.E5.A4.B1.E6.95.97.E3.81.99.E3.82.8B.E3.81.A8.E3.81.A9.E3.81.86.E3.81.AA.E3.82.8B.E3.81.AE.E3.81.A7.E3.81.97.E3.82.87.E3.81.86.E3.81.8B.EF.BC.9F"> コネクションに失敗するとどうなるのでしょうか？ </h3>
<p>もし、コネクションが失敗するか、サーバによってパイプライン化されたレスポンスのダウンロードの一部へ放り込まれた時、Web ブラウザは失ったリクエストの再開始の能力がなくてはなりません。この場合、単純にも、上述の取り消された場合と等価にハンドリンクされているでしょう。
</p>
<div class="originaldocinfo">
<h2 id=".E5.8E.9F.E6.96.87.E6.9B.B8.E3.81.AE.E6.83.85.E5.A0.B1"> 原文書の情報 </h2>
<ul><li> 著者: <a class="link-mailto" href="mailto:darin@meer.net">Darin Fisher</a>
</li><li> 最終更新日: March 20, 2005
</li><li> 著作権: Portions of this content are © 1998–2007 by individual mozilla.org contributors; content available under a Creative Commons license | <a class="external" href="http://www.mozilla.org/foundation/licensing/website-content.html">詳細</a>
</li></ul>
</div>
<div class="noinclude">
</div>
{{ languages( { "en": "en/HTTP_Pipelining_FAQ" } ) }}
