---
title: Shell のグローバルオブジェクト
slug: Mozilla/Projects/SpiderMonkey/Shell_global_objects
tags:
  - JavaScript
  - NeedsContent
  - SpiderMonkey
translation_of: Mozilla/Projects/SpiderMonkey/Shell_global_objects
---
<p>これらは、プログラムを起動したときに SpiderMonkey <code>js</code> コマンドラインインタプリタによって自動的に設定される<strong>グローバルオブジェクト</strong>です。</p>

<p><strong>メモ</strong>: このリストは、<a href="/ja/docs/Mozilla/Projects/SpiderMonkey/Introduction_to_the_JavaScript_shell">JavaScript シェルの紹介</a>の「<a href="/ja/docs/Mozilla/Projects/SpiderMonkey/Introduction_to_the_JavaScript_shell#Built-in_functions">組み込み関数</a>」と重複しているため、おそらく完全ではありません。詳しくは <code>js/src/shell/js.cpp</code> (<code>shell_functions</code> 周辺) をご覧ください。</p>

<p>このページには SpiderMonkey 53 で利用可能な変数と関数がリストされています。各バージョン間には多少の違いがあるかもしれません。js シェルの <code>help()</code> 関数で関数の一覧を見ることができます。</p>

<h2 id="変数">変数</h2>

<dl>
 <dt><code>scriptArgs</code></dt>
 <dd>js シェルに渡された引数を含む配列。</dd>
 <dt><code>scriptPath</code></dt>
 <dd>スクリプトのパスである文字列。</dd>
 <dt><code>console</code></dt>
 <dd>以下のプロパティを持つオブジェクト:
 <dl>
  <dt><code>log</code></dt>
  <dd>式を評価して <code>stdout</code> に出力します。この関数は <code>print()</code> 関数のエイリアスです。</dd>
 </dl>
 </dd>
 <dt><code>timesAccessed</code></dt>
 <dd>この変数が何回アクセスされたかを示す数を返します</dd>
 <dt>PerfMeasurement</dt>
 <dd><a href="/ja/docs/Mozilla/JavaScript_code_modules/PerfMeasurement.jsm">PerfMeasurement.jsm</a> を参照してください。</dd>
</dl>

<h2 id="シェルのみの関数">シェルのみの関数</h2>

<h3 id="Functions_always_available">Functions always available</h3>

<dl>
 <dt><code>version([number])</code></dt>
 <dd>Get or force a script compilation version number.</dd>
 <dt><code>options([option ...])</code></dt>
 <dd>Get or toggle JavaScript options.</dd>
 <dt><code>load(['foo.js' ...])</code></dt>
 <dd>Load files named by string arguments. Filename is relative to the current working directory.</dd>
 <dt><code>loadRelativeToScript(['foo.js' ...])</code></dt>
 <dd>Load files named by string arguments. Filename is relative to the calling script.</dd>
 <dt><code>evaluate(code[, options])</code></dt>
 <dd>Evaluate code as though it were the contents of a file. <code>options</code> is an optional object that may have these properties:
 <dl>
  <dt><code>isRunOnce</code></dt>
  <dd>use the <code>isRunOnce</code> compiler option (default: <code>false</code>)</dd>
  <dt><code>noScriptRval</code></dt>
  <dd>use the no-script-rval compiler option (default: <code>false</code>)</dd>
  <dt><code>fileName</code></dt>
  <dd>filename for error messages and debug info</dd>
  <dt><code>lineNumber</code></dt>
  <dd>starting line number for error messages and debug info</dd>
  <dt><code>columnNumber</code></dt>
  <dd>starting column number for error messages and debug info</dd>
  <dt><code>global</code></dt>
  <dd>global in which to execute the code</dd>
  <dt><code>newContext</code></dt>
  <dd>if <code>true</code>, create and use a new <code>cx</code> (default: <code>false</code>)</dd>
  <dt><code>catchTermination</code></dt>
  <dd>if <code>true</code>, catch termination (failure without an exception value, as for slow scripts or out-of-memory) and return <code>'terminated'</code></dd>
  <dt><code>element</code></dt>
  <dd>if present with value <code>v</code>, convert <code>v</code> to an object <code>o</code> and mark the source as being attached to the DOM element <code>o</code>. If the property is omitted or <code>v</code> is <code>null</code>, don't attribute the source to any DOM element.</dd>
  <dt><code>elementAttributeName</code></dt>
  <dd>if present and not <code>undefined</code>, the name of property of <code>element</code> that holds this code. This is what <code>Debugger.Source.prototype.elementAttributeName</code> returns.</dd>
  <dt><code>sourceMapURL</code></dt>
  <dd>if present with value <code>v</code>, convert <code>v</code> to a string, and provide that as the code's source map URL. If omitted, attach no source map URL to the code (although the code may provide one itself, via a <code>//#sourceMappingURL</code> comment).</dd>
  <dt><code>sourceIsLazy</code></dt>
  <dd>if present and <code>true</code>, indicates that, after compilation, script source should not be cached by the JS engine and should be lazily loaded from the embedding as-needed.</dd>
  <dt><code>loadBytecode</code></dt>
  <dd>if <code>true</code>, and if the source is a <code>CacheEntryObject</code>, the bytecode would be loaded and decoded from the cache entry instead of being parsed, then it would be executed as usual.</dd>
  <dt><code>saveBytecode</code></dt>
  <dd>if <code>true</code>, and if the source is a <code>CacheEntryObject</code>, the bytecode would be encoded and saved into the cache entry after the script execution.</dd>
  <dt><code>assertEqBytecode</code></dt>
  <dd>if <code>true</code>, and if both <code>loadBytecode</code> and <code>saveBytecode</code> are <code>true</code>, then the loaded bytecode and the encoded bytecode are compared. and an assertion is raised if they differ.</dd>
 </dl>
 </dd>
 <dt><code>run('foo.js')</code></dt>
 <dd>Run the file named by the first argument, returning the number of of milliseconds spent compiling and executing it.</dd>
</dl>

<dl>
 <dt><code>read('bar.js')</code></dt>
 <dd>Reads the file named by the first argument, returning the content of the file as string.</dd>
</dl>

<dl>
 <dt><code>readline()</code></dt>
 <dd>Read a single line from <code>stdin</code>.</dd>
 <dt><code>readlineBuf([ buf ])</code></dt>
 <dd>Emulate <code>readline()</code> on the specified string. The first call with a string argument sets the source buffer. Subsequent calls without an argument then read from this buffer line by line.</dd>
 <dt><code>print([exp ...])</code></dt>
 <dd>Evaluate and print expressions to <code>stdout</code>.</dd>
 <dt><code>printErr([exp ...])</code></dt>
 <dd>Evaluate and print expressions to <code>stderr</code>.</dd>
 <dt><code>putstr([exp])</code></dt>
 <dd>Evaluate and print expression without newline.</dd>
 <dt><code>dateNow()</code></dt>
 <dd>Return the current time with sub-ms precision.</dd>
 <dt><code>help([name ...])</code></dt>
 <dd>Display usage and help messages.</dd>
 <dt><code>quit()</code></dt>
 <dd>Quit the shell.</dd>
 <dt><code>assertEq(actual, expected[, msg])</code></dt>
 <dd>Throw if the first two arguments are not the same (both <code>+0</code> or both <code>-0</code>, both <code>NaN</code>, or non-zero and <code>===</code>).</dd>
 <dt><code>startTimingMutator()</code></dt>
 <dd>Start accounting time to mutator vs GC.</dd>
 <dt><code>stopTimingMutator()</code></dt>
 <dd>Stop accounting time to mutator vs GC and dump the results.</dd>
 <dt><code>throwError()</code></dt>
 <dd>Throw an error from <code>JS_ReportError</code>.</dd>
 <dt><code>intern(str)</code></dt>
 <dd>Internalize <code>str</code> in the atom table.</dd>
 <dt><code>getslx(obj)</code></dt>
 <dd>Get script line extent.</dd>
 <dt><code>evalcx(s[, o])</code></dt>
 <dd>Evaluate <code>s</code> in optional sandbox object <code>o</code>. if <code>(s == '' &amp;&amp; !o)</code> return new <code>o</code> with eager standard classes, if <code>(s == 'lazy' &amp;&amp; !o)</code> return new <code>o</code> with lazy standard classes</dd>
 <dt><code>evalInWorker(str)</code></dt>
 <dd>Evaluate <code>str</code> in a separate thread with its own runtime.</dd>
 <dt><code>getSharedArrayBuffer()</code></dt>
 <dd>Retrieve the <code>SharedArrayBuffer</code> object from the cross-worker mailbox. The object retrieved may not be identical to the object that was installed, but it references the same shared memory. <code>getSharedArrayBuffer</code> performs an ordering memory barrier.</dd>
 <dt><code>setSharedArrayBuffer()</code></dt>
 <dd>Install the <code>SharedArrayBuffer</code> object in the cross-worker mailbox. <code>setSharedArrayBuffer</code> performs an ordering memory barrier.</dd>
 <dt><code>shapeOf(obj)</code></dt>
 <dd>Get the shape of <code>obj</code> (an implementation detail).</dd>
 <dt><code>groupOf(obj)</code></dt>
 <dd>Get the group of <code>obj</code> (an implementation detail).</dd>
 <dt><code>unwrappedObjectsHaveSameShape(obj1, obj2)</code></dt>
 <dd>Returns <code>true</code> iff <code>obj1</code> and <code>obj2</code> have the same shape, <code>false</code> otherwise. Both objects are unwrapped first, so this can be used on objects from different globals.</dd>
 <dt><code>sleep(dt)</code></dt>
 <dd>Sleep for <code>dt</code> seconds.</dd>
 <dt><code>compile(code)</code></dt>
 <dd>Compiles a string to bytecode, potentially throwing.</dd>
 <dt><code>parseModule(code)</code></dt>
 <dd>Parses source text as a module and returns a <code>Module</code> object.</dd>
 <dt><code>setModuleResolveHook(function(module, specifier) {})</code></dt>
 <dd>Set the <code>HostResolveImportedModule</code> hook to <code>function</code>. This hook is used to look up a previously loaded module object. It should be implemented by the module loader.</dd>
 <dt><code>getModuleLoadPath()</code></dt>
 <dd>Return any <code>--module-load-path</code> argument passed to the shell. Used by the module loader.</dd>
 <dt><code>parse(code)</code></dt>
 <dd>Parses a string, potentially throwing.</dd>
 <dt><code>syntaxParse(code)</code></dt>
 <dd>Check the syntax of a string, returning success value</dd>
 <dt><code>offThreadCompileScript(code[, options])</code></dt>
 <dd>Compile <code>code</code> on a helper thread. To wait for the compilation to finish and run the code, call <code>runOffThreadScript</code>. If present, <code>options</code> may have properties saying how the code should be compiled:
 <dl>
  <dt><code>noScriptRval</code></dt>
  <dd>use the no-script-rval compiler option (default: <code>false</code>)</dd>
  <dt><code>fileName</code></dt>
  <dd>filename for error messages and debug info</dd>
  <dt><code>lineNumber</code></dt>
  <dd>starting line number for error messages and debug info</dd>
  <dt><code>columnNumber</code></dt>
  <dd>starting column number for error messages and debug info</dd>
  <dt><code>element</code></dt>
  <dd>if present with value <code>v</code>, convert <code>v</code> to an object <code>o</code> and mark the source as being attached to the DOM element <code>o</code>. If the property is omitted or <code>v</code> is <code>null</code>, don't attribute the source to any DOM element.</dd>
  <dt><code>elementAttributeName</code></dt>
  <dd>if present and not <code>undefined</code>, the name of property of <code>element</code> that holds this code. This is what <code>Debugger.Source.prototype.elementAttributeName</code> returns.</dd>
 </dl>
 </dd>
 <dt><code>runOffThreadScript()</code></dt>
 <dd>Wait for off-thread compilation to complete. If an error occurred, throw the appropriate exception; otherwise, run the script and return its value.</dd>
 <dt><code>offThreadCompileModule(code)</code></dt>
 <dd>Compile <code>code</code> on a helper thread. To wait for the compilation to finish and get the module object, call <code>finishOffThreadModule</code>.</dd>
 <dt><code>finishOffThreadModule()</code></dt>
 <dd>Wait for off-thread compilation to complete. If an error occurred, throw the appropriate exception; otherwise, return the module object</dd>
 <dt><code>timeout([seconds], [func])</code></dt>
 <dd>Get/Set the limit in seconds for the execution time for the current context. A negative value (default) means that the execution time is unlimited. If a second argument is provided, it will be invoked when the timer elapses. Calling this function will replace any callback set by <code>setInterruptCallback</code>.</dd>
 <dt><code>interruptIf(cond)</code></dt>
 <dd>Requests interrupt callback if cond is <code>true</code>. If a callback function is set via <code>timeout</code> or <code>setInterruptCallback</code>, it will be called. No-op otherwise.</dd>
 <dt><code>invokeInterruptCallback(fun)</code></dt>
 <dd>Forcefully set the interrupt flag and invoke the interrupt handler. If a callback function is set via <code>timeout</code> or <code>setInterruptCallback</code>, it will be called. Before returning, fun is called with the return value of the interrupt handler.</dd>
 <dt><code>setInterruptCallback(func)</code></dt>
 <dd>Sets <code>func</code> as the interrupt callback function. Calling this function will replace any callback set by <code>timeout</code>.</dd>
 <dt><code>enableLastWarning()</code></dt>
 <dd>Enable storing the last warning.</dd>
 <dt><code>disableLastWarning()</code></dt>
 <dd>Disable storing the last warning.</dd>
 <dt><code>getLastWarning()</code></dt>
 <dd>Returns an object that represents the last warning.</dd>
 <dt><code>clearLastWarning()</code></dt>
 <dd>Clear the last warning.</dd>
 <dt><code>elapsed()</code></dt>
 <dd>Execution time elapsed for the current thread.</dd>
 <dt><code>decompileFunction(func)</code></dt>
 <dd>Decompile a function.</dd>
 <dt><code>decompileThis()</code></dt>
 <dd>Decompile the currently executing script.</dd>
 <dt><code>thisFilename()</code></dt>
 <dd>Return the filename of the current script</dd>
 <dt><code>newGlobal([options])</code></dt>
 <dd>Return a new global object in a new compartment. If options is given, it may have any of the following properties:
 <dl>
  <dt><code>sameZoneAs</code></dt>
  <dd>the compartment will be in the same zone as the given object (defaults to a new zone)</dd>
  <dt><code>invisibleToDebugger</code></dt>
  <dd>the global will be invisible to the debugger (default <code>false</code>)</dd>
  <dt><code>principal</code></dt>
  <dd>if present, its value converted to a number must be an integer that fits in 32 bits; use that as the new compartment's principal. Shell principals are toys, meant only for testing; one shell principal subsumes another if its set bits are a superset of the other's. Thus, a principal of <code>0</code> subsumes nothing, while a principals of <code>~0</code> subsumes all other principals. The absence of a principal is treated as if its bits were <code>0xffff</code>, for subsumption purposes. If this property is omitted, supply no principal.</dd>
 </dl>
 </dd>
 <dt><code>createMappedArrayBuffer(filename, [offset, [size]])</code></dt>
 <dd>Create an array buffer that mmaps the given file.</dd>
 <dt><code>addPromiseReactions(promise, onResolve, onReject)</code></dt>
 <dd>Calls the <code>JS::AddPromiseReactions</code> JSAPI function with the given arguments.</dd>
 <dt><code>getMaxArgs()</code></dt>
 <dd>Return the maximum number of supported args for a call.</dd>
 <dt><code>objectEmulatingUndefined()</code></dt>
 <dd>Return a new object <code>obj</code> for which <code>typeof obj === "undefined"</code>, <code>obj == null</code> and <code>obj == undefined</code> (and vice versa for <code>!=</code>), and <code>ToBoolean(obj) === false</code>.</dd>
 <dt><code>isCachingEnabled()</code></dt>
 <dd>Return whether JS caching is enabled.</dd>
 <dt><code>setCachingEnabled(b)</code></dt>
 <dd>Enable or disable JS caching.</dd>
 <dt><code>cacheEntry(code)</code></dt>
 <dd>Return a new opaque object which emulates a cache entry of a script. This object encapsulates the code and its cached content. The cache entry is filled and read by the <code>evaluate</code> function by using it in place of the source, and by setting <code>saveBytecode</code> and <code>loadBytecode</code> options.</dd>
 <dt><code>printProfilerEvents()</code></dt>
 <dd>Register a callback with the profiler that prints javascript profiler events to <code>stderr</code>. Callback is only registered if profiling is enabled.</dd>
 <dt><code>enableSingleStepProfiling()</code></dt>
 <dd>This function will fail on platforms that don't support single-step profiling (currently everything but ARM-simulator). When enabled, at every instruction a backtrace will be recorded and stored in an array. Adjacent duplicate backtraces are discarded.</dd>
 <dt><code>disableSingleStepProfiling()</code></dt>
 <dd>Return the array of backtraces recorded by <code>enableSingleStepProfiling</code>.</dd>
 <dt><code>enableSPSProfiling()</code></dt>
 <dd>Enables SPS instrumentation and corresponding assertions, with slow assertions disabled.</dd>
 <dt><code>enableSPSProfilingWithSlowAssertions()</code></dt>
 <dd>Enables SPS instrumentation and corresponding assertions, with slow assertions enabled.</dd>
 <dt><code>disableSPSProfiling()</code></dt>
 <dd>Disables SPS instrumentation</dd>
 <dt><code>isLatin1(s)</code></dt>
 <dd>Return true iff the string's characters are stored as Latin1.</dd>
 <dt><code>stackPointerInfo()</code></dt>
 <dd>Return an <code>int32</code> value which corresponds to the offset of the latest stack pointer, such that one can take the differences of 2 to estimate a frame-size.</dd>
 <dt><code>entryPoints(params)</code></dt>
 <dd>Carry out some JSAPI operation as directed by <code>params</code>, and return an array of objects describing which JavaScript entry points were invoked as a result. <code>params</code> is an object whose properties indicate what operation to perform. Here are the recognized groups of properties:
 <dl>
  <dt><code>{ function }</code></dt>
  <dd>Call the object <code>params.function</code> with no arguments.</dd>
  <dt><code>{ object, property }</code></dt>
  <dd>Fetch the property named <code>params.property</code> of <code>params.object</code>.</dd>
  <dt><code>{ ToString }</code></dt>
  <dd>Apply <code>JS::ToString</code> to <code>params.toString</code>.</dd>
  <dt><code>{ ToNumber }</code></dt>
  <dd>Apply <code>JS::ToNumber</code> to <code>params.toNumber</code>.</dd>
  <dt><code>{ eval }</code></dt>
  <dd>Apply <code>JS::Evaluate</code> to <code>params.eval</code>.</dd>
 </dl>
 The return value is an array of strings, with one element for each JavaScript invocation that occurred as a result of the given operation. Each element is the name of the function invoked, or the string <code>'eval:FILENAME'</code> if the code was invoked by <code>eval</code> or something similar.</dd>
 <dt><code>drainJobQueue()</code></dt>
 <dd>Take jobs from the shell's job queue in FIFO order and run them until the queue is empty.</dd>
 <dt><code>setPromiseRejectionTrackerCallback()</code></dt>
 <dd>Sets the callback to be invoked whenever a Promise rejection is unhandled or a previously-unhandled rejection becomes handled.</dd>
</dl>

<h3 id="Functions_available_only_in_DEBUG_build">Functions available only in DEBUG build</h3>

<dl>
 <dt><code>disassemble([fun/code])</code></dt>
 <dd>Return the disassembly for the given function or code. All disassembly functions take these options as leading string arguments:
 <dl>
  <dt><code>-r</code></dt>
  <dd>disassemble recursively</dd>
  <dt><code>-l</code></dt>
  <dd>show line numbers</dd>
  <dt><code>-S</code></dt>
  <dd>omit source notes</dd>
 </dl>
 </dd>
 <dt><code>dis([fun/code])</code></dt>
 <dd>Disassemble functions into bytecodes.</dd>
 <dt><code>disfile('foo.js')</code></dt>
 <dd>Disassemble script file into bytecodes.</dd>
 <dt><code>dissrc([fun/code])</code></dt>
 <dd>Disassemble functions with source lines.</dd>
 <dt><code>notes([fun])</code></dt>
 <dd>Show source notes for functions.</dd>
 <dt><code>stackDump(showArgs, showLocals, showThisProps)</code></dt>
 <dd>Tries to print a lot of information about the current stack. Similar to the <code>DumpJSStack()</code> function in the browser.</dd>
 <dt><code>arrayInfo(a1, a2, ...)</code></dt>
 <dd>Report statistics about arrays.</dd>
</dl>

<h3 id="Functions_available_only_if_ENABLE_INTL_API_is_defined">Functions available only if ENABLE_INTL_API is defined</h3>

<dl>
 <dt><code>addIntlExtras(obj)</code></dt>
 <dd>Adds various not-yet-standardized Intl functions as properties on the provided object (this should generally be <code>Intl</code> itself). The added functions and their behavior are experimental: don't depend upon them unless you're willing to update your code if these experimental APIs change underneath you.</dd>
</dl>

<h3 id="Functions_available_if_--fuzzing-safe_is_not_specified">Functions available if <code>--fuzzing-safe</code> is not specified</h3>

<dl>
 <dt><code>clone(fun[, scope])</code></dt>
 <dd>Clone function object.</dd>
 <dt><code>getSelfHostedValue()</code></dt>
 <dd>Get a self-hosted value by its name. Note that these values don't get cached, so repeatedly getting the same value creates multiple distinct clones.</dd>
 <dt><code>line2pc([fun,] line)</code></dt>
 <dd>Map line number to PC.</dd>
 <dt><code>pc2line(fun[, pc])</code></dt>
 <dd>Map PC to line number.</dd>
 <dt><code>nestedShell(shellArgs...)</code></dt>
 <dd>Execute the given code in a new JS shell process, passing this nested shell the arguments passed to <code>nestedShell</code>. <code>argv[0]</code> of the nested shell will be <code>argv[0]</code> of the current shell (which is assumed to be the actual path to the shell. <code>arguments[0]</code> (of the call to <code>nestedShell</code>) will be <code>argv[1]</code>, <code>arguments[1]</code> will be <code>argv[2]</code>, etc.</dd>
 <dt><code>assertFloat32(value, isFloat32)</code></dt>
 <dd>In IonMonkey only, asserts that <code>value</code> has (resp. hasn't) the <code>MIRType::Float32</code> if <code>isFloat32</code> is <code>true</code> (resp. <code>false</code>).</dd>
 <dt><code>assertRecoveredOnBailout(var)</code></dt>
 <dd>In IonMonkey only, asserts that variable has <code>RecoveredOnBailout</code> flag.</dd>
 <dt><code>withSourceHook(hook, fun)</code></dt>
 <dd>Set this JS runtime's lazy source retrieval hook (that is, the hook used to find sources compiled with <code>CompileOptions::LAZY_SOURCE</code>) to <code>hook</code>; call <code>fun</code> with no arguments; and then restore the runtime's original hook. Return or throw whatever <code>fun</code> did. <code>hook</code> gets passed the requested code's URL, and should return a string.
 <p>Notes:</p>

 <ol>
  <li>SpiderMonkey may assert if the returned code isn't close enough to the script's real code, so this function is not fuzzer-safe.</li>
  <li>The runtime can have only one source retrieval hook active at a time. If <code>fun</code> is not careful, <code>hook</code> could be asked to retrieve the source code for compilations that occurred long before it was set, and that it knows nothing about. The reverse applies as well: the original hook, that we reinstate after the call to <code>fun</code> completes, might be asked for the source code of compilations that <code>fun</code> performed, and which, presumably, only <code>hook</code> knows how to find.</li>
 </ol>
 </dd>
 <dt><code>wrapWithProto(obj)</code></dt>
 <dd>Wrap an object into a noop wrapper with prototype semantics. Note: This is not fuzzing safe because it can be used to construct deeply nested wrapper chains that cannot exist in the wild.</dd>
 <dt><code>trackedOpts(fun)</code></dt>
 <dd>Returns an object describing the tracked optimizations of <code>fun</code>, if any. If <code>fun</code> is not a scripted function or has not been compiled by Ion, <code>null</code> is returned.</dd>
 <dt><code>dumpScopeChain(obj)</code></dt>
 <dd>Prints the scope chain of an interpreted function or a module.</dd>
 <dt><code>crash([message])</code></dt>
 <dd>Crashes the process with a <code>MOZ_CRASH</code>.</dd>
 <dt><code>setARMHwCapFlags("flag1,flag2 flag3")</code></dt>
 <dd>On non-ARM, no-op. On ARM, set the hardware capabilities. The list of flags is available by calling this function with <code>help</code> as the flag's name</dd>
 <dt><code>wasmLoop(filename, imports)</code></dt>
 <dd>Performs an AFL-style persistent loop reading data from the given file and passing it to the<code>wasmEval</code> function together with the specified imports object.</dd>
</dl>

<h2 id="テスト用関数">テスト用関数</h2>

<p>Testing functions are available also on Firefox via <code>Components.utils.getJSTestingFunctions()</code></p>

<h3 id="Functions_always_available_2">Functions always available</h3>

<dl>
 <dt><code>gc([obj] | 'zone' [, 'shrinking'])</code></dt>
 <dd>Run the garbage collector. When obj is given, GC only its zone. If <code>zone</code> is given, GC any zones that were scheduled for GC via schedulegc. If <code>shrinking</code> is passed as the optional second argument, perform a shrinking GC rather than a normal GC.</dd>
 <dt><code>minorgc([aboutToOverflow])</code></dt>
 <dd>Run a minor collector on the Nursery. When <code>aboutToOverflow</code> is true, marks the store buffer as about-to-overflow before collecting.</dd>
 <dt><code>gcparam(name [, value])</code></dt>
 <dd>Wrapper for <code>JS_[GS]etGCParameter</code>. The name is one of:
 <ul>
  <li>maxBytes</li>
  <li>maxMallocBytes</li>
  <li>gcBytes</li>
  <li>gcNumber</li>
  <li>mode</li>
  <li>unusedChunks</li>
  <li>totalChunks</li>
  <li>sliceTimeBudget</li>
  <li>markStackLimit</li>
  <li>highFrequencyTimeLimit</li>
  <li>highFrequencyLowLimit</li>
  <li>highFrequencyHighLimit</li>
  <li>highFrequencyHeapGrowthMax</li>
  <li>highFrequencyHeapGrowthMin</li>
  <li>lowFrequencyHeapGrowth</li>
  <li>dynamicHeapGrowth</li>
  <li>dynamicMarkSlice</li>
  <li>allocationThreshold</li>
  <li>minEmptyChunkCount</li>
  <li>maxEmptyChunkCount</li>
  <li>compactingEnabled</li>
  <li>refreshFrameSlicesEnabled</li>
 </ul>
 </dd>
 <dt><code>relazifyFunctions(...)</code></dt>
 <dd>Perform a GC and allow relazification of functions. Accepts the same arguments as <code>gc()</code>.</dd>
 <dt><code>getBuildConfiguration()</code></dt>
 <dd>Return an object describing some of the configuration options SpiderMonkey was built with.</dd>
 <dt><code>hasChild(parent, child)</code></dt>
 <dd>Return <code>true</code> if <code>child</code> is a child of <code>parent</code>, as determined by a call to <code>TraceChildren</code></dd>
 <dt><code>setSavedStacksRNGState(seed)</code></dt>
 <dd>Set this compartment's <code>SavedStacks</code>' RNG state.</dd>
 <dt><code>getSavedFrameCount()</code></dt>
 <dd>Return the number of <code>SavedFrame</code> instances stored in this compartment's <code>SavedStacks</code> cache.</dd>
 <dt><code>saveStack([maxDepth [, compartment]])</code></dt>
 <dd>Capture a stack. If <code>maxDepth</code> is given, capture at most <code>maxDepth</code> number of frames. If <code>compartment</code> is given, allocate the <code>js::SavedFrame</code> instances with the given object's compartment.</dd>
 <dt><code>saveStack(object [, shouldIgnoreSelfHosted = true]])</code></dt>
 <dd>Capture a stack back to the first frame whose principals are subsumed by the object's compartment's principals. If <code>shouldIgnoreSelfHosted</code> is given, control whether self-hosted frames are considered when checking principals.</dd>
 <dt><code>callFunctionFromNativeFrame(function)</code></dt>
 <dd>Call <code>function</code> with a (C++-)native frame on stack. Required for testing that <code>SaveStack</code> properly handles native frames.</dd>
 <dt><code>callFunctionWithAsyncStack(function, stack, asyncCause)</code></dt>
 <dd>Call <code>function</code>, using the provided stack as the async stack responsible for the call, and propagate its return value or the exception it throws. The function is called with no arguments, and <code>this</code> is <code>undefined</code>. The specified <code>asyncCause</code> is attached to the provided stack frame.</dd>
 <dt><code>enableTrackAllocations()</code></dt>
 <dd>Start capturing the JS stack at every allocation. Note that this sets an object metadata callback that will override any other object metadata callback that may be set.</dd>
 <dt><code>disableTrackAllocations()</code></dt>
 <dd>Stop capturing the JS stack at every allocation.</dd>
 <dt><code>makeFinalizeObserver()</code></dt>
 <dd>Get a special object whose finalization increases the counter returned by the <code>finalizeCount</code> function.</dd>
 <dt><code>finalizeCount()</code></dt>
 <dd>Return the current value of the finalization counter that is incremented each time an object returned by the <code>makeFinalizeObserver</code> is finalized.</dd>
 <dt><code>resetFinalizeCount()</code></dt>
 <dd>Reset the value returned by <code>finalizeCount()</code>.</dd>
 <dt><code>gcPreserveCode()</code></dt>
 <dd>Preserve JIT code during garbage collections.</dd>
 <dt><code>startgc([n [, 'shrinking']])</code></dt>
 <dd>Start an incremental GC and run a slice that processes about <code>n</code> objects. If <code>shrinking</code> is passesd as the optional second argument, perform a shrinking GC rather than a normal GC.</dd>
 <dt><code>gcslice([n])</code></dt>
 <dd>Start or continue an an incremental GC, running a slice that processes about <code>n</code> objects.</dd>
 <dt><code>abortgc()</code></dt>
 <dd>Abort the current incremental GC.</dd>
 <dt><code>fullcompartmentchecks(true|false)</code></dt>
 <dd>If <code>true</code>, check for compartment mismatches before every GC.</dd>
 <dt><code>nondeterministicGetWeakMapKeys(weakmap)</code></dt>
 <dd>Return an array of the keys in the given WeakMap.</dd>
 <dt><code>internalConst(name)</code></dt>
 <dd>Query an internal constant for the engine. See <code>InternalConst</code> source for the list of constant names.</dd>
 <dt><code>isProxy(obj)</code></dt>
 <dd>If <code>true</code>, <code>obj</code> is a proxy of some sort</dd>
 <dt><code>dumpHeap(['collectNurseryBeforeDump'], [filename])</code></dt>
 <dd>Dump reachable and unreachable objects to the named file, or to <code>stdout</code>. If <code>collectNurseryBeforeDump</code> is specified, a minor GC is performed first, otherwise objects in the nursery are ignored.</dd>
 <dt><code>terminate()</code></dt>
 <dd>Terminate JavaScript execution, as if we had run out of memory or been terminated by the slow script dialog.</dd>
 <dt><code>readSPSProfilingStack()</code></dt>
 <dd>Reads the jit stack using <code>ProfilingFrameIterator</code>.</dd>
 <dt><code>enableOsiPointRegisterChecks()</code></dt>
 <dd>Emit extra code to verify live regs at the start of a VM call are not modified before its <code>OsiPoint</code>.</dd>
 <dt><code>displayName(fn)</code></dt>
 <dd>Gets the display name for a function, which can possibly be a guessed or inferred name based on where the function was defined. This can be different from the <code>name</code> property on the function.</dd>
 <dt><code>isAsmJSCompilationAvailable</code></dt>
 <dd>Returns whether asm.js compilation is currently available or whether it is disabled (e.g., by the debugger).</dd>
 <dt><code>isSimdAvailable</code></dt>
 <dd>Returns <code>true</code> if SIMD extensions are supported on this platform.</dd>
 <dt><code>getCompilerOptions()</code></dt>
 <dd>Return an object describing some of the JIT compiler options.</dd>
 <dt><code>isAsmJSModule(fn)</code></dt>
 <dd>Returns whether the given value is a function containing <code>"use asm"</code> that has been validated according to the asm.js spec.</dd>
 <dt><code>isAsmJSModuleLoadedFromCache(fn)</code></dt>
 <dd>Return whether the given asm.js module function has been loaded directly from the cache. This function throws an error if fn is not a validated asm.js module.</dd>
 <dt><code>isAsmJSFunction(fn)</code></dt>
 <dd>Returns whether the given value is a nested function in an asm.js module that has been both compile- and link-time validated.</dd>
 <dt><code>wasmIsSupported()</code></dt>
 <dd>Returns a boolean indicating whether WebAssembly is supported on the current device.</dd>
 <dt><code>wasmTextToBinary(str)</code></dt>
 <dd>Translates the given text wasm module into its binary encoding.</dd>
 <dt><code>wasmBinaryToText(bin)</code></dt>
 <dd>Translates binary encoding to text format</dd>
 <dt><code>wasmExtractCode(module)</code></dt>
 <dd>Extracts generated machine code from WebAssembly.Module.</dd>
 <dt><code>isLazyFunction(fun)</code></dt>
 <dd><code>True</code> if fun is a lazy <code>JSFunction</code>.</dd>
 <dt><code>isRelazifiableFunction(fun)</code></dt>
 <dd><code>Ture</code> if fun is a <code>JSFunction</code> with a relazifiable <code>JSScript</code>.</dd>
 <dt><code>enableShellAllocationMetadataBuilder()</code></dt>
 <dd>Use <code>ShellAllocationMetadataBuilder</code> to supply metadata for all newly created objects.</dd>
 <dt><code>getAllocationMetadata(obj)</code></dt>
 <dd>Get the metadata for an object.</dd>
 <dt><code>bailout()</code></dt>
 <dd>Force a bailout out of ionmonkey (if running in ionmonkey).</dd>
 <dt><code>bailAfter(number)</code></dt>
 <dd>Start a counter to bail once after passing the given amount of possible bailout positions in ionmonkey.</dd>
 <dt><code>inJit()</code></dt>
 <dd>Returns <code>true</code> when called within (jit-)compiled code. When jit compilation is disabled this function returns an error string. This function returns <code>false</code> in all other cases. Depending on truthiness, you should continue to wait for compilation to happen or stop execution.</dd>
 <dt><code>inIon()</code></dt>
 <dd>Returns <code>true</code> when called within ion. When ion is disabled or when compilation is abnormally slow to start, this function returns an error string. Otherwise, this function returns <code>false</code>. This behaviour ensures that a falsy value means that we are not in ion, but expect a compilation to occur in the future. Conversely, a truthy value means that we are either in ion or that there is litle or no chance of ion ever compiling the current script.</dd>
 <dt><code>assertJitStackInvariants()</code></dt>
 <dd>Iterates the Jit stack and check that stack invariants hold.</dd>
 <dt><code>setCompilerOption(option, number)</code></dt>
 <dd>Set a compiler option indexed in JSCompileOption enum to a number.</dd>
 <dt><code>setIonCheckGraphCoherency(bool)</code></dt>
 <dd>Set whether Ion should perform graph consistency (DEBUG-only) assertions. These assertions are valuable and should be generally enabled, however they can be very expensive for large (wasm) programs.</dd>
 <dt><code>serialize(data, [transferables, [policy]])</code></dt>
 <dd>Serialize <code>data</code> using <code>JS_WriteStructuredClone</code>. Returns a structured clone buffer object. <code>policy</code> must be an object. The following keys' string values will be used to determine whether the corresponding types may be serialized (value <code>allow</code>, the default) or not (value <code>deny</code>). If denied types are encountered a TypeError will be thrown during cloning. Valid keys: <code>SharedArrayBuffer</code>.</dd>
 <dt><code>deserialize(clonebuffer)</code></dt>
 <dd>Deserialize data generated by serialize.</dd>
 <dt><code>detachArrayBuffer(buffer)</code></dt>
 <dd>Detach the given <code>ArrayBuffer</code> object from its memory, i.e. as if it had been transferred to a WebWorker.</dd>
 <dt><code>helperThreadCount()</code></dt>
 <dd>Returns the number of helper threads available for off-main-thread tasks.</dd>
 <dt><code>reportOutOfMemory()</code></dt>
 <dd>Report OOM, then clear the exception and return undefined. For crash testing.</dd>
 <dt><code>throwOutOfMemory()</code></dt>
 <dd>Throw out of memory exception, for OOM handling testing.</dd>
 <dt><code>reportLargeAllocationFailure()</code></dt>
 <dd>Call the large allocation failure callback, as though a large malloc call failed, then return undefined. In Gecko, this sends a memory pressure notification, which can free up some memory.</dd>
 <dt><code>findPath(start, target)</code></dt>
 <dd>Return an array describing one of the shortest paths of GC heap edges from <code>start</code> to <code>target</code>, or <code>undefined</code> if <code>target</code> is unreachable from <code>start</code>. Each element of the array is either of the form: <code>{ node: {object or string}, edge: {string describing edge from node} }</code> , if the node is a JavaScript object or value; or of the form: <code>{ type: {string describing node}, edge: {string describing edge} }</code> , if the node is some internal thing that is not a proper JavaScript value (like a shape or a scope chain element). The destination of the i'th array element's edge is the node of the i+1'th array element; the destination of the last array element is implicitly <code>target</code>.</dd>
 <dt><code>shortestPaths(start, targets, maxNumPaths)</code></dt>
 <dd>Return an array of arrays of shortest retaining paths. There is an array of shortest retaining paths for each object in <code>targets</code>. The maximum number of paths in each of those arrays is bounded by <code>maxNumPaths</code>. Each element in a path is of the form <code>{ predecessor, edge }</code>.</dd>
 <dt><code>sharedMemoryEnabled()</code></dt>
 <dd>Return true if <code>SharedArrayBuffer</code> and Atomics are enabled</dd>
 <dt><code>evalReturningScope(scriptStr, [global])</code></dt>
 <dd>Evaluate the script in a new scope and return the scope. If <code>global</code> is present, clone the script to <code>global</code> before executing.</dd>
 <dt><code>cloneAndExecuteScript(source, global)</code></dt>
 <dd>Compile <code>source</code> in the current compartment, clone it into <code>global</code>'s compartment, and run it there.</dd>
 <dt><code>backtrace()</code></dt>
 <dd>Dump out a brief backtrace.</dd>
 <dt><code>getBacktrace([options])</code></dt>
 <dd>Return the current stack as a string. Takes an optional options object, which may contain any or all of the boolean properties <code>options.args</code> - show arguments to each function <code>options.locals</code> - show local variables in each frame <code>options.thisprops</code> - show the properties of the <code>this</code> object of each frame</dd>
 <dt><code>byteSize(value)</code></dt>
 <dd>Return the size in bytes occupied by <code>value</code>, or <code>undefined</code> if value is not allocated in memory.</dd>
 <dt><code>byteSizeOfScript(f)</code></dt>
 <dd>Return the size in bytes occupied by the function <code>f</code>'s JSScript.</dd>
 <dt><code>setImmutablePrototype(obj)</code></dt>
 <dd>Try to make obj's <code>[[Prototype]]</code> immutable, such that subsequent attempts to change it will fail. Return <code>true</code> if obj's <code>[[Prototype]]</code> was successfully made immutable (or if it already was immutable), <code>false</code> otherwise. Throws in case of internal error, or if the operation doesn't even make sense (for example, because the object is a revoked proxy).</dd>
 <dt><code>setLazyParsingDisabled(bool)</code></dt>
 <dd>Explicitly disable lazy parsing in the current compartment. The default is that lazy parsing is not explicitly disabled.</dd>
 <dt><code>setDiscardSource(bool)</code></dt>
 <dd>Explicitly enable source discarding in the current compartment. The default is that source discarding is not explicitly enabled.</dd>
 <dt><code>getConstructorName(object)</code></dt>
 <dd>If the given object was created with <code>new Ctor</code>, return the constructor's display name. Otherwise, return <code>null</code>.</dd>
 <dt><code>allocationMarker([options])</code></dt>
 <dd>Return a freshly allocated object whose <code>[[Class]]</code> name is <code>AllocationMarker</code>. Such objects are allocated only by calls to this function, never implicitly by the system, making them suitable for use in allocation tooling tests. Takes an optional options object which may contain the following properties: * nursery: bool, whether to allocate the object in the nursery</dd>
 <dt><code>setGCCallback({action:"...", options...})</code></dt>
 <dd>Set the GC callback. action may be:
 <dl>
  <dt><code>minorGC</code></dt>
  <dd>run a nursery collection</dd>
  <dt><code>majorGC</code></dt>
  <dd>run a major collection, nesting up to a given <code>depth</code></dd>
 </dl>
 </dd>
 <dt><code>getLcovInfo(global)</code></dt>
 <dd>Generate LCOV tracefile for the given compartment. If no global are provided then the current global is used as the default one.</dd>
 <dt><code>getModuleEnvironmentNames(module)</code></dt>
 <dd>Get the list of a module environment's bound names for a specified module.</dd>
 <dt><code>getModuleEnvironmentValue(module, name)</code></dt>
 <dd>Get the value of a bound name in a module environment.</dd>
 <dt><code>enableForEach()</code></dt>
 <dd>Enables the deprecated, non-standard for-each.</dd>
 <dt><code>disableForEach()</code></dt>
 <dd>Disables the deprecated, non-standard for-each.</dd>
</dl>

<h3 id="Functions_available_only_if_SPIDERMONKEY_PROMISE_is_defined">Functions available only if SPIDERMONKEY_PROMISE is defined</h3>

<dl>
 <dt><code>settlePromiseNow(promise)</code></dt>
 <dd>'Settle' a <code>promise</code> immediately. This just marks the promise as resolved with a value of <code>undefined</code> and causes the firing of any <code>onPromiseSettled</code> hooks set on <code>Debugger</code> instances that are observing the given promise's global as a debuggee.</dd>
 <dt><code>getWaitForAllPromise(densePromisesArray)</code></dt>
 <dd>Calls the <code>GetWaitForAllPromise</code> JSAPI function and returns the result Promise.</dd>
 <dt><code>resolvePromise(promise, resolution)</code></dt>
 <dd>Resolve a <code>Promise</code> by calling the JSAPI function <code>JS::ResolvePromise</code>.</dd>
 <dt><code>rejectPromise(promise, reason)</code></dt>
 <dd>Reject a <code>Promise</code> by calling the JSAPI function <code>JS::RejectPromise</code>.</dd>
</dl>

<h3 id="Functions_available_only_if_SPIDERMONKEY_PROMISE_is_not_defined">Functions available only if SPIDERMONKEY_PROMISE is not defined</h3>

<dl>
 <dt><code>makeFakePromise()</code></dt>
 <dd>Create an object whose <code>[[Class]]</code> name is <code>'Promise'</code> and call <code>JS::dbg::onNewPromise</code> on it before returning it. It doesn't actually have any of the other behavior associated with promises.</dd>
 <dt><code>settleFakePromise(promise)</code></dt>
 <dd>'Settle' a <code>promise</code> created by <code>makeFakePromise()</code>. This doesn't have any observable effects outside of firing any <code>onPromiseSettled</code> hooks set on <code>Debugger</code> instances that are observing the given promise's global as a debuggee.</dd>
</dl>

<h3 id="Functions_available_only_if_JS_GC_ZEAL_is_defined">Functions available only if JS_GC_ZEAL is defined</h3>

<dl>
 <dt><code>gczeal(level, [N])</code></dt>
 <dd>Specifies how zealous the garbage collector should be. Some of these modes can be set simultaneously, by passing multiple level options, e.g. <code>"2;4"</code> will activate both modes 2 and 4. Modes can be specified by name or number.
 <p>Values:</p>

 <dl>
  <dt><code>0: (None)</code></dt>
  <dd>Normal amount of collection (resets all modes)</dd>
  <dt><code>1: (Poke)</code></dt>
  <dd>Collect when roots are added or removed</dd>
  <dt><code>2: (Alloc)</code></dt>
  <dd>Collect when every <code>N</code> allocations (default: 100)</dd>
  <dt><code>3: (FrameGC)</code></dt>
  <dd>Collect when the window paints (browser only)</dd>
  <dt><code>4: (VerifierPre)</code></dt>
  <dd>Verify pre write barriers between instructions</dd>
  <dt><code>5: (FrameVerifierPre)</code></dt>
  <dd>Verify pre write barriers between paints</dd>
  <dt><code>6: (StackRooting)</code></dt>
  <dd>Verify stack rooting</dd>
  <dt><code>7: (GenerationalGC)</code></dt>
  <dd>Collect the nursery every <code>N</code> nursery allocations</dd>
  <dt><code>8: (IncrementalRootsThenFinish)</code></dt>
  <dd>Incremental GC in two slices: 1) mark roots 2) finish collection</dd>
  <dt><code>9: (IncrementalMarkAllThenFinish)</code></dt>
  <dd>Incremental GC in two slices: 1) mark all 2) new marking and finish</dd>
  <dt><code>10: (IncrementalMultipleSlices)</code></dt>
  <dd>Incremental GC in multiple slices</dd>
  <dt><code>11: (IncrementalMarkingValidator)</code></dt>
  <dd>Verify incremental marking</dd>
  <dt><code>12: (ElementsBarrier)</code></dt>
  <dd>Always use the individual element post-write barrier, regardless of elements size</dd>
  <dt><code>13: (CheckHashTablesOnMinorGC)</code></dt>
  <dd>Check internal hashtables on minor GC</dd>
  <dt><code>14: (Compact)</code></dt>
  <dd>Perform a shrinking collection every N allocations</dd>
  <dt><code>15: (CheckHeapAfterGC)</code></dt>
  <dd>Walk the heap to check its integrity after every GC</dd>
  <dt><code>16: (CheckNursery)</code></dt>
  <dd>Check nursery integrity on minor GC</dd>
 </dl>
 </dd>
 <dt><code>schedulegc([num | obj])</code></dt>
 <dd>If num is given, schedule a GC after num allocations. If obj is given, schedule a GC of obj's zone. Returns the number of allocations before the next trigger.</dd>
 <dt><code>selectforgc(obj1, obj2, ...)</code></dt>
 <dd>Schedule the given objects to be marked in the next GC slice.</dd>
 <dt><code>verifyprebarriers()</code></dt>
 <dd>Start or end a run of the pre-write barrier verifier.</dd>
 <dt><code>verifypostbarriers()</code></dt>
 <dd>Does nothing (the post-write barrier verifier has been remove).</dd>
 <dt><code>gcstate()</code></dt>
 <dd>Report the global GC state.</dd>
 <dt><code>deterministicgc(true|false)</code></dt>
 <dd>If <code>true</code>, only allow determinstic GCs to run.</dd>
</dl>

<h3 id="Functions_available_only_if_JS_TRACE_LOGGING_is_defined">Functions available only if JS_TRACE_LOGGING is defined</h3>

<dl>
 <dt><code>startTraceLogger()</code></dt>
 <dd>Start logging the mainThread. Note: tracelogging starts automatically. Disable it by setting environment variable <code>TLOPTIONS=disableMainThread</code></dd>
 <dt><code>stopTraceLogger()</code></dt>
 <dd>Stop logging the mainThread.</dd>
</dl>

<h3 id="Functions_available_only_in_nightly_build">Functions available only in nightly build</h3>

<dl>
 <dt><code>objectAddress(obj)</code></dt>
 <dd>Return the current address of the object. For debugging only--this address may change during a moving GC.</dd>
 <dt><code>sharedAddress(obj)</code></dt>
 <dd>Return the address of the shared storage of a <code>SharedArrayBuffer</code>.</dd>
</dl>

<h3 id="Functions_available_only_in_DEBUG_build_2">Functions available only in DEBUG build</h3>

<dl>
 <dt><code>dumpObject()</code></dt>
 <dd>Dump an internal representation of an object.</dd>
 <dt><code>dumpStringRepresentation(str)</code></dt>
 <dd>Print a human-readable description of how the string <code>str</code> is represented.</dd>
 <dt><code>setRNGState(seed0, seed1)</code></dt>
 <dd>Set this compartment's RNG state.</dd>
</dl>

<h3 id="Functions_available_only_in_DEBUG_build_or_JS_OOM_BREAKPOINT_is_defined">Functions available only in DEBUG build or JS_OOM_BREAKPOINT is defined</h3>

<dl>
 <dt><code>oomThreadTypes()</code></dt>
 <dd>Get the number of thread types that can be used as an argument for <code>oomAfterAllocations()</code> and <code>oomAtAllocation()</code>.</dd>
 <dt><code>oomAfterAllocations(count [,threadType])</code></dt>
 <dd>After <code>count</code> <code>js_malloc</code> memory allocations, fail every following allocation (return <code>nullptr</code>). The optional thread type limits the effect to the specified type of helper thread.</dd>
 <dt><code>oomAtAllocation(count [,threadType])</code></dt>
 <dd>After <code>count</code> <code>js_malloc</code> memory allocations, fail the next allocation (return <code>nullptr</code>). The optional thread type limits the effect to the specified type of helper thread.</dd>
 <dt><code>resetOOMFailure()</code></dt>
 <dd>Remove the allocation failure scheduled by either <code>oomAfterAllocations()</code> or <code>oomAtAllocation()</code> and return whether any allocation had been caused to fail.</dd>
 <dt><code>oomTest(function, [expectExceptionOnFailure = true])</code></dt>
 <dd>Test that the passed function behaves correctly under OOM conditions by repeatedly executing it and simulating allocation failure at successive allocations until the function completes without seeing a failure. By default this tests that an exception is raised if execution fails, but this can be disabled by passing false as the optional second parameter. This is also disabled when <code>--fuzzing-safe</code> is specified.</dd>
</dl>

<h3 id="Functions_available_only_in_DEBUG_build_if_--fuzzing-safe_is_not_specified_and">Functions available only in DEBUG build if <code>--fuzzing-safe</code> is not specified and</h3>

<dl>
 <dt><code>parseRegExp(pattern[, flags[, match_only])</code></dt>
 <dd>Parses a <code>RegExp</code> pattern and returns a tree, potentially throwing.</dd>
 <dt><code>disRegExp(regexp[, match_only[, input]])</code></dt>
 <dd>Dumps <code>RegExp</code> bytecode.</dd>
</dl>
