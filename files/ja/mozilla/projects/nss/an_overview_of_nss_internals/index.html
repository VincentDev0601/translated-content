---
title: NSS 内部の概要
slug: Mozilla/Projects/NSS/An_overview_of_NSS_Internals
tags:
  - API
  - Intermediate
  - Intro
  - NSS
  - Tools
translation_of: Mozilla/Projects/NSS/An_overview_of_NSS_Internals
---
<p style="margin-left: 40px;"><a href="/ja/docs/Mozilla/Projects/NSS">Network Security Services (NSS)</a> の内部をハイレベルで解説</p>

<p style="margin-left: 40px;">Mozilla.org プロジェクトによって開発されたソフトウェアは、伝統的にセキュリティプロトコルと暗号化アルゴリズムの独自の実装を使用していましたが、元々は Netscape Security Services と呼ばれていましたが、現在では Network Security Services (NSS) と呼ばれています。NSSはC言語で書かれたライブラリです。フリーでオープンソースのソフトウェアであり、多くのソフトウェアプロジェクトが利用を決めています。複数のオペレーティングシステム (OS) をサポートするために、Netscape Portable Runtime (NSPR) と呼ばれるクロスプラットフォーム移植性レイヤーをベースにしており、ファイルシステムアクセス、メモリ管理、ネットワーク通信、マルチスレッドプログラミングなどの OS 固有の API のためのクロスプラットフォームアプリケーションプログラミングインターフェース (API) を提供しています。</p>

<p style="margin-left: 40px;">NSS は多くの機能を提供していますが、ここではモジュールのリスト、設計原理、重要な関連規格について説明します。</p>

<p style="margin-left: 40px;">暗号処理を行うソフトウェアとデバイス間の相互運用性を可能にするため、NSS は PKCS#11 と呼ばれる規格に準拠しています。(11という数字に注目することが重要であることに注意してください。異なる数字で全く異なるトピックを定義する他の PKCS 規格が存在するからです)。</p>

<p style="margin-left: 40px;">PKCS#11 規格に準拠したソフトウェアまたはハードウェアモジュールは、モジュールの特性や提供されるサービスを問い合わせることができるCコールのインターフェースを実装しています。NSS 自身のモジュールの複数の要素がこのインタフェースで実装されており、NSS はそれらのモジュールと話すときにこのインタフェースを利用します。この戦略により、NSSは、PKCS#11インタフェースを実装した多くのハードウェアデバイス(例えば、暗号演算に必要な計算を高速化したり、秘密鍵を安全に保護するスマートカードにアクセスしたり)やソフトウェアモジュール(例えば、追加のアルゴリズムを提供したり、鍵や信頼情報を保存するプラグインとしてそのようなモジュールをロードできるようにする)と連携することが可能になります。</p>

<p style="margin-left: 40px;">NSS の中核となる要素は、ハッシュ関数、大数計算、暗号アルゴリズムを提供するベースライブラリである FreeBL です。<br>
 <br>
 Softoken は、ほとんどの FreeBL の機能を PKCS#11 モジュールとして公開する NSS モジュールです。</p>

<p style="margin-left: 40px;">暗号技術の中には、暗号化と復号化の両方に同じ秘密鍵を使用するものがあり、例えばパスワードベース暗号化 (PBE) などがあります。自分でデータを暗号化する場合はこれで十分な場合が多いですが、通信相手と署名/暗号化されたデータをやり取りする必要が出てきたら、公開鍵暗号化を使うことで鍵の管理が簡単になります。公開鍵暗号化を利用する方法を説明した環境を PKI (Public Key Infrastructure) と呼びます。パーティ間で交換される公開鍵は、コンテナを使って輸送されます。コンテナは、標準の X.509 バージョン 3 に従い、証明書と呼ばれています。例えば、証明書には、証明書の所有関係に対する信頼を表す第三者による署名が含まれている。第三者によって割り当てられた信頼は、証明書に含まれる証明書の拡張子に記載されている特定の用途に制限されている場合があります。</p>

<p style="margin-left: 40px;">NSS によって実行される操作の多く (ほとんどではないにせよ) は、X.509 証明書 (しばしば "cert" と略されますが、残念ながら「コンピュータ緊急対応チーム」という用語と混同されやすいです) の使用を伴います。</p>

<p style="margin-left: 40px;">証明書が信頼されているかどうかをチェックする際には、通常は認証局 (CA) と呼ばれる信頼された第三者の署名能力を表す関連するトラストアンカー (ルート証明書) を見つける必要があります。トラストアンカーとは、ソフトウェアベンダー、組織インフラストラクチャ内の管理者、またはソフトウェアユーザーによって、すでに知られており、意図的に信頼されているとマークされている別の X.509 証明書にすぎません。NSS は、事前に定義された CA 証明書のセットを出荷します。このセットは、信頼の割り当てを含め、NSS が CKBI (組み込みルート証明書) と呼ばれるソフトウェアモジュールとして提供し、PKCS#11 インターフェイスも実装しています。組織レベルでは、セットの内容は Mozilla CA ポリシーに従って管理されています。技術的なレベルでは、セットはバイナリソフトウェアモジュールです。</p>

<p style="margin-left: 40px;">データ交換に関連した暗号化や復号化などの暗号化トランザクションは、通常、通信相手 (ピア) の X.509 認証を使用して行われます。また、自分の証明書に属する秘密鍵を安全に保管しておくことも求められます。秘密鍵の保管場所を PBE で保護したいと思うかもしれません。NSS が提供するデフォルトのトラストを変更することにするかもしれません。これらすべての作業には、データの保存、検索、取得が必要です。NSS はストレージと管理 API を提供することで、これらの操作を簡素化します。NSS は、プログラマーが個々の証明書や鍵を含む個々のファイルを管理する必要はありません。その代わりに、NSS は独自のデータベースを利用することができます。一度 NSS のデータベースに証明書や鍵をインポートしてしまえば、それらを簡単に検索して再利用することができます。</p>

<p style="margin-left: 40px;">NSS は NSS データベースを使って操作することを期待しているため、初期化呼び出しを実行することが必須です。最も単純なシナリオでは、プログラマーはinit関数のパラメータとしてファイルシステム上のディレクトリを提供し、NSSは残りの部分を行うように設計されています。既存のデータベースを検出して開くか、新しいデータベースを作成します。また、証明書の永続的な記録を使用したくないと判断した場合は、データベースなしモードでNSSを初期化することもできます。通常、新しいデータが恒久的なストレージに追加されるとすぐに、NSS はすべてのデータをディスクにフラッシュする。ストレージは複数のファイルで構成されています。鍵データベースファイルには秘密鍵が格納され、証明書データベースファイルには、自分の証明書の公開部分、ピアや認証局の証明書、信頼決定のリスト(組み込みの認証局を信頼しない、他の認証局を明示的に信頼するなど)が格納されています。データベースファイルの例としては、key3.db と cert8.db があります。3番目のファイルには、NSS が使用するために登録された外部 PKCS#11 モジュールのリストが含まれています。このファイルは secmod.db という名前にすることもできますが、新しい世代のデータベースではpkcs11.txtという名前のファイルが使用されます。</p>

<p style="margin-left: 40px;">これらのデータベースファイルに直接アクセスして操作できるのは NSS だけです。NSS を使用するプログラマーは、これらのファイルに保存されているデータを操作するために NSS が提供する API を経由しなければなりません。プログラマーの仕事は、必要なパラメータ (データベースなど) で NSS を初期化することであり、その後 NSS はデータベースファイルを透過的に管理します。</p>

<p style="margin-left: 40px;">ほとんどの場合、証明書や鍵は NSS のデータベースに格納されることになっています。したがって、最初のインポートや作成の後、プログラマーは通常、それらの生のバイトを処理しません。その代わりに、プログラマはルックアップ関数を使用し、NSS はその後アプリケーションのコードで使用されるアクセスハンドルを提供します。これらのハンドルは参照カウントされます。NSS は通常、証明書がネットワークから受信され、ディスクから読み込まれ、データベースから検索されると、証明書のインメモリ (RAM) プレゼンテーションを作成し、証明書のプロパティを含むインメモリデータ構造を準備します。一旦、アプリケーションがハンドルを使用して終了すると、それは解放され、NSS が関連するリソースを解放することができるようになります。秘密鍵のハンドルを扱う場合、通常、アプリケーションが生の鍵データにアクセスすることは困難であり (望ましくない)、そのため NSS からそのようなデータを抽出することは難しいかもしれません。そのため、NSS からそのようなデータを抽出するのは難しいかもしれません。通常の最低限の要件は、秘密鍵を保護層 (パスワードベースの暗号化など) でラップすることです。これは、セキュリティのためのコードのレビューを容易にするための意図があります。生の秘密鍵にアクセスできるコードが少なければ少ないほど、レビューしなければならないコードは少なくなります。</p>

<p style="margin-left: 40px;">NSS には、生の鍵を検索する機能が限られています。好ましいアプローチは証明書を利用することであり、含まれるサブジェクト名 (証明書の所有者を表す情報) などのプロパティで証明書を検索することです。例えば、NSS は新しい公開鍵/秘密鍵ペアのランダム計算 (生成) をサポートしていますが、このような生の鍵ペアを扱うのは難しいです。通常のアプローチは、アプリケーションの作成ステップが完了するとすぐに証明書署名要求 (CSR) を作成し、鍵ペアへのハンドルを作成します。通常のフォローアップ動作は、CA から署名された証明書を受け取ることです。(ただし、NSS の機能を使用して自己署名証明書を作成することも可能ですが、通常は他の当事者から信頼されません)。受信したら、NSS にそのような新しい証明書を NSS データベースにインポートするように指示すれば十分で、NSS は自動的に埋め込まれた公開鍵の検索を行い、関連する秘密鍵を見つけることができ、その後、それを個人証明書として扱うことができます (個人証明書とは、個人の証明書のことです)。(個人証明書とは、秘密鍵を保有している証明書で、データの署名やデータの復号に使用することができます) インポート時に証明書に一意のニックネームを割り当てることができます。</p>

<p style="margin-left: 40px;">NSS が返すすべてのハンドルについて、NSS は厳密なクリーンアップを要求することに注意してください。アプリケーションは、ハンドルが不要になったら、常に適切な参照解除(破棄)関数を呼び出す必要があります。これは、再起動せずにデータベースを閉じ、別のデータベースを使用してNSSを再初期化する必要があるかもしれないアプリケーションにとって特に重要です。データ要素がまだ参照されている場合、このような操作は実行時に失敗する可能性があります。</p>

<p style="margin-left: 40px;">FreeBL、Softoken、CKBI モジュールに加えて、一般的な操作 (データフォーマット間のエンコード/デコード、標準化されたオブジェクト識別子 (OID) のリストなど) のためのユーティリティライブラリがあります。NSS には、Secure Sockets Layer/Transport Layer Security ネットワークプロトコルを実装する SSL/TLS モジュール、セキュアなメールで使用される CMS メッセージングといくつかのインスタントメッセージング実装を実装する S/MIME モジュール、古典的なデータベースストレージを実装する DBM ライブラリ、そして最後に「その他すべて」の大きなセットのためのコア NSS ライブラリがあります。データベースの新世代は、複数のアプリケーションによる同時アクセスを可能にするために SQLite データベースを使用しています。</p>

<p style="margin-left: 40px;">これらはすべて共有ライブラリとして提供されています。特定の種類の証明書要求を生成するために使用される CRMF ライブラリは、スタティックリンク専用のライブラリとして提供されています。</p>

<p style="margin-left: 40px;">証明書 (X.509) 、PKCS#12 (証明書と鍵) 、PKCS#7 (署名データ) などのファイル形式、CMS としてのメッセージ形式を扱う場合、構造化されたデータを非常に効率的に (小さいサイズの) プレゼンテーションで格納するための構文である ASN.1 に言及しなければなりません。元々は通信システムのために開発されたもので、データをできるだけ少なくすることが重要な時代に開発されました (現在でもこの原理を使うことはパフォーマンスを上げるためには意味がありますが)。ASN.1 フォーマットで利用可能なデータを処理するためには、通常のアプローチでは、データを解析して、(入れ子になった) C データ構造のような、より多くのスペースを必要とするが作業しやすいプレゼンテーションに転送します。その間、NSS は3つの異なる ASN.1 パーサの実装を受け取ってきましたが、それぞれに固有の特性、長所と短所があり、それが今でも使われている理由です (副作用のリスクがあるため、古いものを新しいものに置き換える勇気はまだありません)。ASN.1 パーサを使用する場合、テンプレート定義がパーサに渡され、それに応じて ASN.1 データストリームを解析します。テンプレートは通常、RFC 文書に記載されている定義と密接に一致しています。</p>

<p style="margin-left: 40px;">DER として記述されたデータブロックは通常 ASN.1 形式です。どのデータを期待しているかを把握し、ソフトウェアのインタラクションのコンテキストに基づいて、正しいテンプレートを使用して解析する必要があります。PEM として記述されたデータは DER の base64 エンコードされたプレゼンテーションで、通常は人間が読める BEGIN/END 行の間にラップされています。NSS はバイナリ表示を好みますが、特にファイルからデータをインポートする場合には、base64 または ASCII 表示を使用することができます。最近の開発では、秘密鍵を含む外部の PEM ファイルを読み込むためのサポートが追加されました。</p>

<p style="margin-left: 40px;">コードレベルで見ると、NSS は常に生データのブロックを扱っています。このような型なしブロックを格納するための一般的な構造は SECItem で、サイズと型なし C ポインタ変数を含んでいます。</p>

<p style="margin-left: 40px;">メモリを扱うとき、NSS はアリーナを利用しています。これは C 言語の限られた機能で管理を簡単にする試みです (デストラクタがないので)。これは、クリーンアップを簡単にするために、複数のメモリ割り当てをグループ化するという考えです。ある操作を実行すると、多くの個別のデータ項目を割り当てる必要があり、コードはロジック内の多くの位置でタスクを中止する必要があるかもしれません。アリーナはタスクの処理が開始されると要求され、そのタスクに論理的に関連付けられたすべてのメモリ割り当てが関連付けられたアリーナから要求されます。アリーナの実装により、すべての個々のメモリブロックが追跡されます。タスクが完了すると、それが完了したか中止されたかにかかわらず、プログラマはアリーナを解放するだけで、個々に割り当てられたすべてのブロックが自動的に解放されます。解放はしばしば、攻撃者がメモリダンプから鍵を取り出すことをより困難にするために、アリーナに関連するメモリを即座に消去 (ゼロ化、zfree) することと組み合わされます。<br>
 <br>
 NSS は多くの C 言語のデータ構造を使用しています。多くの場合、NSS は同じまたは類似した概念のために複数の実装を持っています。例えば、複数の証明書のプレゼンテーションがあり、NSS 内部 (そして時には NSS を使用するアプリケーション) はそれらの間で変換する必要があるかもしれません。<br>
 <br>
 NSS の鍵となる責任は、署名と証明書の検証です。デジタル署名を検証するためには、アプリケーションデータ (例えば、署名された文書)、署名データブロック (デジタル署名)、公開鍵 (署名者であると考えられる証明書に含まれるもので、署名とともに受信したメタデータによって識別されるものなど) を調べなければなりません。署名データブロックが公開鍵の所有者によって生成されたものでなければならないことを示すことができれば、署名は検証されます (関連する秘密鍵を持っているのはその所有者だけなので)。</p>

<p style="margin-left: 40px;">証明書 (A) を検証するには、いくつかの追加ステップが必要です。まず、証明書 (A) の潜在的な署名者 (B) を特定しなければなりません。これは、証明書 (A) の “issuer name” 属性を読み取り、その発行者証明書(B)を見つけようとすることによって行われます (その名前を “subject name” として使用している証明書を探すことによって)。そして、(A) で見つけた署名を (B) で見つけた公開鍵を使って検証しようとします。同じサブジェクト名を持つ複数の証明書 (B1, B2, ...) をそれぞれ試してみる必要があるかもしれません。<br>
 <br>
 成功した後、この手順を再帰的に繰り返す必要があるかもしれません。最終的には、適切なトラストが割り当てられている証明書 B (または C または...) を見つけることが目的です (例えば、CKBI モジュール内で見つけられ、ユーザがトラストの上書き決定を行っていない場合や、ユーザまたはローカル環境で管理されているNSS データベースファイル内で見つけられる場合など)。</p>

<p style="margin-left: 40px;">(複数の) 発行者証明書の署名の検証に成功した後、証明書 A の検証はまだ終わっていません。例えば、署名が行われた時点で証明書が有効であること、証明書内の名前が予想される署名者と一致していること (サブジェクト名、一般名、メール、アプリケーションに基づくチェック) 、証明書内に記録されている信頼制限 (拡張子) が使用を許可していること (例えば、暗号化は許可されているかもしれないが、署名は許可されていない) 、環境/アプリケーションポリシーに基づいて、失効チェック (OCSP または CRL) を行う必要がある場合があります。<br>
 <br>
 CKBI モジュールに含まれるトラスト・アンカーは、通常、自己署名されたものであり、サブジェクト名と発行者名のフィールドが同一であると定義されます。自己署名付き証明書が明示的に信頼されているとマークされている場合、NSS は自己署名の有効性のチェックをスキップします。</p>

<p style="margin-left: 40px;">NSSには、証明書の検証を行うための複数のAPIがあります。例えば、(B)発行者候補の証明書がすべて同じサブジェクト名と発行者名を持ち、有効期間によって異なる場合など、非常に安定しており、すべての単純なシナリオで問題なく動作する古典的なエンジンがありますが、より高度なシナリオでは限られた範囲でしか動作しません。残念ながら、最近の証明書の世界はより複雑になっています。新規の認証局が世界の PKI 市場に参入し、事業を開始するために、既存の認証局と取引を行い、いわゆる相互署名証明書を受け取ることがある。その結果、(A) から信頼できるアンカー (ルート) 証明書 (Z) への信頼パスを検索する際に、候補となる発行者証明書のセットが異なる発行者名 (2 番目以上の発行者レベルを参照) を持つ可能性があります。その結果、(Z) を検索しながら、再帰的に複数の異なる代替ルートを試す必要がある。新しい検証エンジン (内部的に libPKIX と名付けられています) だけがこれを適切に行うことができます。<br>
 <br>
 これは、ソフトウェアベンダと認証局が、ウェブサイト証明書の証明書を発行するためのより厳格なルールを定義するための努力です。証明書の要求者が希望するウェブサイトのドメインの管理メールアドレスを管理していることを単に検証するのではなく、認証局が実世界の身元確認書類 (国の当局による会社登録書類など) の検証を行うことが要求され、また、ブラウザソフトウェアが証明書の有効性を付与する前に、認証局との失効チェックを行うことが要求されている。EV 証明書を区別するために、CA は証明書にポリシー OID を埋め込み、ブラウザはトラストチェーンがエンドエンティティ (EE) 証明書がポリシーを利用することを許可しているかどうかを検証することが期待されています。ポリシーの検証を実行できるのは、新しい libPKIX エンジンの API だけです。<br>
 <br>
 これを機に、サーバへの SSL/TLS 接続について一般的に (EVに限らず、Web サイトに限らず) 話すことにしましょう。このドキュメントでSSLについて言及している場合は、必ず SSL か TLS のどちらかを指しています。(TLS は SSL の新しいバージョンで、機能が強化されています)。</p>

<p style="margin-left: 40px;">サーバへの SSL 接続を確立する際には、(少なくとも) サーバ証明書 (とそのトラストチェーン) がサーバからクライアント (ブラウザなど) に交換され、クライアントはその証明書が検証可能であることを確認します (期待される宛先サーバの名前と一致することを含む)。両者間のハンドシェイクのもう一つの部分は、鍵の交換です。公開鍵暗号化は (双方が同じ鍵を使用する) 対称暗号化よりもコストがかかる (計算が必要) ため、鍵合意プロトコルが実行され、公開鍵と秘密鍵を使用して、交換された初期情報の証明と検証が行われます。鍵合意が行われると、対称暗号化が使用されます (既存のチャネル上で潜在的な再ハンドシェイクが行われるまで)。SSL 接続に使用されるハッシュと暗号化アルゴリズムの組み合わせは暗号化スイートと呼ばれます。</p>

<p style="margin-left: 40px;">NSS は技術的なレベルでサポートしている暗号化スイートのセットを出荷しています。さらに、NSS はデフォルトでどの暗号化スイートを有効にするかを定義するデフォルトポリシーを持っています。アプリケーションは、有効になっている暗号スイートのセットを変更するための関数呼び出しを使用して、プログラム実行時に使用されるポリシーを変更することができます。</p>

<p style="margin-left: 40px;">プログラマが NSS が証明書を検証する方法や、SSL 接続のハンドシェイクで提示されるデータを検証する方法に影響を与えたい場合、適切な時点で NSS によって呼び出されるアプリケーション定義のコールバック関数を登録することができ、NSS によって行われた決定を上書きするために使用することができます。</p>

<p style="margin-left: 40px;">SSL を実装したツールキットとして NSS を使いたい場合は、まず NSS を init しなければならないことを覚えておいてください。しかし、デフォルトのトラストを恒久的に変更することを気にしない (ディスクに記録されている) 場合は、データベースなしの init コールを使用することができます。データ交換のためのネットワークソケットを作成する際には、NSPR と NSS が提供するオペレーティングシステムに依存しない API を使用しなければならないことに注意してください。NSPR ファイルディスクリプタのプロパティに触れておくと面白いかもしれません。これは、データ処理に関与する複数のレイヤーを定義できることを意味します。ファイル記述子は、データを扱う最初のレイヤーへのポインタを持っています。そのレイヤは、潜在的な第2のレイヤへのポインタを持ち、そのレイヤは第3のレイヤへの別のポインタを持っているかもしれません。各レイヤーは、open/close/read/write/poll/select (など) 関数のための独自の関数を定義しています。SSL ネットワーク接続を使用する場合、基本的な NSPR 層と SSL ライブラリ層の 2 つの層を既に持っています。Mozilla アプリケーションでは、アプリケーション固有の処理が行われる第三のレイヤーを定義しています。詳細は NSPR のリファレンスドキュメントを参照してください。</p>

<p style="margin-left: 40px;">NSS は、アプリケーションから要求された接続に加えて、アウトバウンドネットワーク接続を作成しなければならないことがあります。例としては、OCSP (オンライン証明書ステータスプロトコル) 情報の取得や、CRL (証明書失効リスト) のダウンロードなどがあります。ただし、NSS にはネットワークプロキシを使用するための実装がありません。アプリケーションでプロキシをサポートする必要がある場合は、httpリクエストコールバックインターフェースの独自の実装を登録することができ、NSS はプロキシをサポートするアプリケーションコードを使用することができます。</p>

<p style="margin-left: 40px;">ハッシュ化、暗号化、復号化関数を使用する場合は、(大容量バッファ上で動作するのとは対照的に) データをストリーム化することが可能です。操作に必要なすべてのパラメータを提供しながらコンテキストハンドルを作成し、"update" 関数を複数回呼び出して入力のサブセットを NSS に渡します。データは処理され、直接返されるか、コンテキストに登録されたコールバック関数に送られます。処理が終わったら、保留中のデータをフラッシュアウトしてリソースを解放する最終化関数を呼び出します。</p>

<p style="margin-left: 40px;">この行は、今後のセクションで libpkix がどのように動作し、どのように設計されているかを説明するためのプレースホルダです。</p>

<p style="margin-left: 40px;">NSS を使って作業したい場合は、NSS 開発者が提供しているコマンドラインユーティリティを使うと便利なことが多いです。NSS データベースの管理、証明書のダンプや検証、PKCS#11 モジュールをデータベースに登録するためのツール、CMS の暗号化/署名されたメッセージを処理するためのツールなどがあります。</p>

<p style="margin-left: 40px;">例えば、あなた自身の鍵のペアを作成して CA から新しい証明書を要求したい場合、certutil を使って空のデータベースを作成し、あなたのデータベース上で操作して証明書要求を作成し (これは希望する鍵のペアを作成することを含む)、それをファイルにエクスポートし、要求ファイルを CA に提出し、CA からファイルを受け取り、あなたのデータベースに証明書をインポートすることができます。証明書をインポートする際には、後で参照しやすくするために、良いニックネームを割り当てる必要があります。</p>

<p style="margin-left: 40px;">複数のアプリケーションで同時にアクセスできる最初のデータベース形式は key4.db/cert9.db であることに注意してください。つまり、ブラウザやサーバーが古い NSS のデータベース形式で動作している場合は、他のソフトウェアが実行している間は NSS ツールで操作しないようにしてください。執筆時点では、NSS と Mozilla アプリケーションは、各アプリケーションが独自の NSS データベースを持っている古いデータベースファイル形式をデフォルトで使用しています。</p>

<p style="margin-left: 40px;">秘密鍵を含む NSS データベースに保存された証明書のコピーが必要な場合は、pk12util を使って PKCS#12 ファイル形式にエクスポートすることができます。PEM 形式の証明書が必要な場合は、openssl pkcs12 コマンド (これは NSS ではありません) を使用して PKCS#12 ファイルを PEM に変換することができます。</p>

<p style="margin-left: 40px;">この行は、データベースの準備の仕方、証明書のダンプの仕方、データの変換の仕方のプレースホルダです。</p>

<p style="margin-left: 40px;">Firefox や Thunderbird などの Mozilla アプリケーションで NSS が使われているので、NSS を使って作業する気になったかもしれません。Mozilla アプリケーションをビルドすれば、NSS ライブラリも自動的にビルドされます。しかし、NSS のコマンドラインツールで作業したい場合は、スタンドアロンの NSS のビルド手順に従って、Mozilla アプリケーションのソースの外で NSS をビルドする必要があります。</p>

<p style="margin-left: 40px;">鍵データベースファイルには、少なくとも一つの対称鍵が含まれており、これは必要に応じて NSS が自動的に作成し、秘密鍵 (秘密鍵) を保護するために使用されます。この対称鍵は、データベースにマスターパスワードを設定することで PBE で保護することができます。マスターパスワードを設定するとすぐに、攻撃者がマスターパスワードを盗むことに成功しない限り、 鍵データベースを盗む攻撃者は秘密鍵にアクセスできなくなります。</p>

<p style="margin-left: 40px;">今、あなたは <a href="/ja/docs/Mozilla/Projects/NSS/NSS_Sources_Building_Testing">NSS のソースを取得する方法、NSS を構築し、テストする方法</a>に興味があるかもしれません。</p>
