---
title: XPCOM string guide
slug: Mozilla/Tech/XPCOM/Guide/Mozilla_internal_string_guide
tags:
  - 移行
  - 要更新
translation_of: Mozilla/Tech/XPCOM/Guide/Internal_strings
---
<h2 id=".E5.BA.8F.E6.96.87" name=".E5.BA.8F.E6.96.87">序文</h2>

<div>
<p>by Alec Flett<br>
 Thanks to David Baron for <a class="external" href="http://dbaron.org/mozilla/coding-practices">actual docs</a>,<br>
 Peter Annema for lots of direction,<br>
 Myk Melez for some more docs, and<br>
 David Bradley for a diagram<br>
 Revised by Darin Fisher for Mozilla 1.7<br>
 Revised by Jungshik Shin to clarify character encoding issues</p>
</div>

<p>　このガイドは過剰に存在しているstringクラスについてドキュメント化したものです。これによって「こういう場合、いったいどのstringクラスを使ったらいいの？」という長年の疑問に対する答えとなることを期待しています。</p>

<div style="border: thin solid steelblue; padding: 0.5em;">
<p>　もしあなたがMozillaの組み込み開発者か、もしくはMozillaコードベースとは別個に配布されることを予定しているXPCOMコンポーネントを書いているなら、この文書は多くの場合あなたにとって最適のものとは言えません！もしあなたがMozilla 1.7以降を対象に開発を行っているなら、この文書の代わりに新しい最小版APIである <code><a href="https://dxr.mozilla.org/mozilla-central/source/xpcom/glue/nsStringAPI.h" rel="custom">xpcom/glue/nsStringAPI.h</a></code> とりわけ<code><a href="https://dxr.mozilla.org/mozilla-central/source/xpcom/string/public/nsEmbedString.h" rel="custom">xpcom/string/public/nsEmbedString.h</a></code> クラスを使うべきです。</p>
</div>

<p>　お急ぎですか？それなら <a href="/ja/XPCOM/String_Quick_Reference" title="ja/XPCOM/String_Quick_Reference">String Quick-Reference</a> () を見てください。</p>

<h2 id=".E3.81.AF.E3.81.98.E3.82.81.E3.81.AB" name=".E3.81.AF.E3.81.98.E3.82.81.E3.81.AB">はじめに</h2>

<p>string クラスは、unicode と 1バイト文字の文字列のバッファを扱うために使われる C++ クラスのライブラリです。 これらは <code><a href="https://dxr.mozilla.org/mozilla-central/source/xpcom/string" rel="custom">xpcom/string</a></code> ディレクトリの Mozilla コードベースに属します。</p>

<p>Abstract (interface) クラスは"nsA"で始まり、 具象クラスは"<code>ns</code>"で始まります。 "<code><strong>C</strong>String</code>" を名前に持つクラスは シングルバイト ASCII 文字列もしくは、UTF-8 やその他の文字セットでエンコードされたマルチバイト unicode 文字列を参照する 8 ビット文字を格納します。 名前に単に "<code>String</code>" を持つ他のすべてのクラスは、 主に UTF16 でエンコードされる 2バイト（<code>PRUnichar</code>）文字列を参照します。 例：<code>nsAString</code> は 2バイト文字を蓄えるための抽象クラスで、 <code>nsDependentCString</code> は 1バイト文字を蓄えるための具象クラスです。 どの 2バイト文字列クラスも同等の 1バイト文字列クラスを持ちます。 例：<code>nsCString</code> クラスは 1バイト文字列クラスで、 <code>nsString</code> と対応します。</p>

<p>1バイトと 2バイトの文字列クラスは完全に異なる基底クラスを持ちますが、 同じ API を共有します。 このように、1バイト文字列を 2バイト文字列へ、何らかのヘルパークラスかルーチンによる変換なしに代入することは出来ません。 このドキュメントの目的は、クラスドキュメントの中で 2バイト文字列クラスについて言及することです。 どの 2バイトクラスも同等の 1バイトクラスを持つと仮定しても安全です。</p>

<h2 id="String_ガイドライン">String ガイドライン</h2>

<p>仲間の開発者、レビューワ、ユーザをハッピーにさせるために、コードの中でこれらの単純なルールに従ってください。</p>

<ul>
 <li>是非とも<a href="#Unicode_Conversion"><code><span class="nowiki">*WithConversion</span></code> 関数を避ける</a>： <code>AssignWithConversion</code>, <code>AppendWithConversion</code>, <code>EqualsWithConversion</code>, など</li>
 <li>出来る限りもっとも抽象的なクラスを使う。大抵はこれ：
  <ul>
   <li><a href="#Abstract_Classes"><code>nsAString</code></a> 関数の引数のために</li>
   <li><a href="#Concrete_Classes"><code>nsString</code> メンバ変数のために </a></li>
   <li><a href="#Concrete_Classes"><code>nsAutoString</code> または <code>nsXPIDLString</code></a> ローカル（スタックベース）変数のために</li>
  </ul>
 </li>
 <li><code>nsAString</code> 互換オブジェクトとしてリテラル文字列（例：<code>"foo"</code>）を表現するためには <a href="#Literal_Strings"><code>NS_LITERAL_[C</code></a>STRING/<code>NS_NAMED_LITERAL_[C]STRING</code>] を使う。</li>
 <li>文字列を結合するときには<a href="#Concatenation">string 連結</a>（例： "<code>+</code>" オペレータ）を使う。</li>
 <li><code>nsAString</code>互換文字列を変換する必要のある生の文字ポインタを持つとき、 <a href="#Raw_Pointers"><code>nsDependentString</code></a>を使う。</li>
 <li>既存の文字列から一部を抜き出すためには <a href="#Substring"><code>Substring()</code></a> を使う。</li>
 <li>文字列断片の解析と抜き出しには <a href="#Iterators">iterators</a> を使う。</li>
</ul>

<p> </p>

<h2 id="Abstract.EF.BC.88.E6.8A.BD.E8.B1.A1.EF.BC.89.E3.82.AF.E3.83.A9.E3.82.B9" name="Abstract.EF.BC.88.E6.8A.BD.E8.B1.A1.EF.BC.89.E3.82.AF.E3.83.A9.E3.82.B9">Abstract（抽象）クラス</h2>

<p>どの string クラスも <code>nsAString</code>（もしくは <code>nsACString</code>） から派生しています。 このクラスはアクセスと文字列操作のための基礎インタフェースを提供します。 具象クラスが <code>nsAString</code>から派生する一方、 <code>nsAString</code>自身はインスタンス化できません。</p>

<p>これは、コードベースの他の部分で抽象オブジェクト記述の記述のために Mozilla が使っている "interface" の考え方によく似ています。 インタフェースについて、クラス名は "nsI" で始まり、"I" は "Interface" を意味します。 抽象クラスは "nsA" で始まり、"A" は "Abstract" を意味します。</p>

<p><code>nsAString</code> から派生した抽象クラスがたくさんあります。 これらの抽象サブクラスもまたインスタンス化できません。 しかし、それらは <code>nsAString</code> よりもわずかながらより詳細に string を記述します。 それからは、抽象クラスの背後で下敷きになった実装が <code>nsAString</code> に加えて特定の能力を提供することを保証します。</p>

<p>以下のリストで主な抽象クラスについて記述します。一度それらになじんだら、<a href="#Appendix_WhatToUse">どのクラスをいつ使うか</a>を参照してください。</p>

<ul>
 <li><code class="decl">nsAString</code><span class="nowiki">: すべての文字列のための基底クラスです。 これは、代入／個々の文字へのアクセス／基本的なの文字操作／文字列比較のための API を提供します。このクラスは XPIDL の </span><code>AString</code> 引数型に対応します。</li>
 <li><code class="decl">nsSubstring</code><span class="nowiki">: string クラスのすべてに対する共通の基本クラスです。文字列の内部のデータへ最適化されたアクセスをするためのものです。</span><code>nsSubstring</code> は null 終端文字列である必要はありません（後方互換のために、<code>nsASingleFragmentString</code> は、このクラスを示す typedef がなされています）。</li>
 <li><code class="decl">nsString</code><span class="nowiki">: null 終端の保存を保証した </span><code>nsSubstring</code> によって作られます。このクラスでは、下敷きとなっている文字バッファにアクセスするためのメソッド(<code>.get()</code>) を使うことができます。（後方互換のために、<code>nsAFlatString</code> は、このクラスを示す typedef がなされています）。</li>
</ul>

<p>その他の string クラスは、<code>nsSubstring</code> か <code>nsString</code> かを継承しています。 そのため、どの文字列クラスも <code>nsAString</code> と互換があります。</p>

<p><code>nsSubstring</code> と <code>nsAString</code> は共に null 終端である必要のない一続きの文字の配列を示していることに言及するのは重要なことでしょう。 この似通った二つのクラスが存在する必要があるのは何故なのかと疑問に思う人もいるでしょう。 えぇ、<code>nsSubstring</code> は主として、最適化目的に存在します。それは、<code>nsAString</code> が Mozilla 1.0 とともにリリースされた凍結された <code>nsAString</code> crustバイナリレベルの互換を保たなくてはならないからです。 Mozilla 1.7 のリリースまで、<code>nsAString</code> は複合的な断片に分けられた文字列を表す能力を持っていました。 複合的な断片に分けられた文字列のサポートに関するコストは高く、限られたメリットを提供していました。 文字列クラスの複雑さを減らして、パフォーマンスを改善しようという努力のために、複合的な断片に分けられた文字列のサポートを削減する決定がなされました。詳細は <a class="external" href="http://bugzilla.mozilla.org/show_bug.cgi?id=231995">bug 231995</a> を参照して下さい。</p>

<p><code>nsSubstring</code> は、下敷きとしている <code>nsAString</code> バッファへのより効果的なインタフェースを提供していますが、<code>nsAString</code> は未だにパラメータ渡しのためにもっとも共通して使われています。 それは、XPIDL の <code>AString</code> と対応した文字辣クラスだからです。 そのために、この文字列ガイドは <code>nsAString</code> に重点を置いた文字列クラスについて言及し続けるでしょう。</p>

<p>どの stiring も <code>nsAString</code>(もしくは <code>nsACString</code>) から派生しているため、それらはいくつかの基礎となる機能を共有します。</p>

<p>読取専用の共通メソッド:</p>

<ul>
 <li><code class="decl">.Length()</code> - string 中の文字数。</li>
 <li><code class="decl">.IsEmpty()</code> - string が何らかの値を持っているかどうか決定する最も早い方法。次のコードでテストするよりこれを使ってください：<code><em>string</em>.Length == 0</code></li>
 <li><code class="decl">.Equals(<em>string</em>)</code> - もし引数の string が現在の string と同じ値を持っていれば TRUE。</li>
</ul>

<p>文字列修正の共通メソッド：</p>

<ul>
 <li><code class="decl">.Assign(<em>string</em>)</code> - 新しい値を string に代入する。</li>
 <li><code class="decl">.Append(<em>string</em>)</code> - string に値を追加する。</li>
 <li><code class="decl">.Insert(<em>string</em>, <em>position</em>)</code> - 引数の string を <em>position</em> の文字の後ろに挿入する。</li>
 <li><code class="decl">.Truncate(<em>length</em>)</code> - string を引数の長さに縮める。</li>
</ul>

<p><a href="#Appendix_nsAString">付録</a>に完全なドキュメントがあります。</p>

<p> </p>

<h3 id=".E8.AA.AD.E5.8F.96.E5.B0.82.E7.94.A8_strings" name=".E8.AA.AD.E5.8F.96.E5.B0.82.E7.94.A8_strings">読取専用 strings</h3>

<p>string 上での<code>const</code> 属性は string が書き込み可能かどうかを示します。 もし、string が<code>const nsAString</code> のように定義されていたら、string 内のデータは操作不可です。 もし、<code>const</code> でないメソッドを <code>const</code> string 上で呼び出そうとしても、 コンパイラはビルド時にエラーとしてこれを示します。</p>

<p>例：</p>

<p> </p>

<pre class="eval">void nsFoo::ReverseCharacters(nsAString&amp; str) {
      ...
     str.Assign(reversedStr); // modifies the string
}
</pre>

<p>これはコンパイルできない。なぜなら、<code>const</code> クラスへ代入しているから:</p>

<pre class="eval">void nsFoo::ReverseCharacters(const nsAString&amp; str) {
      ...
     <strong>str.Assign(reversedStr);</strong>
}
</pre>

<p> </p>

<h3 id=".E9.96.A2.E6.95.B0.E3.81.AE.E5.BC.95.E6.95.B0.E3.81.A8.E3.81.97.E3.81.A6.E3.81.AE_Abstract.EF.BC.88.E6.8A.BD.E8.B1.A1.EF.BC.89.E3.82.AF.E3.83.A9.E3.82.B9" name=".E9.96.A2.E6.95.B0.E3.81.AE.E5.BC.95.E6.95.B0.E3.81.A8.E3.81.97.E3.81.A6.E3.81.AE_Abstract.EF.BC.88.E6.8A.BD.E8.B1.A1.EF.BC.89.E3.82.AF.E3.83.A9.E3.82.B9">関数の引数としての Abstract（抽象）クラス</h3>

<p>関数の引数としては、具象クラスの代わりにできる限りもっとも抽象的なインタフェースを使うことが推奨されます。 文字列を参照渡しする場合には、ポインタ('*'文字)ではなく、C++の参照('&amp;' 文字)を用いるのが習慣です。たとえば：</p>

<pre class="eval">// 抽象クラスによる参照
nsFoo::PrintString(<strong>const nsAString&amp;</strong> str) {..}

// 具象クラスを使っている！
nsFoo::PrintString(const <strong>nsString&amp;</strong> str) {..}

// ポインタを使っている！
nsFoo::PrintString(const <strong>nsAString*</strong> str) {..}
</pre>

<p>抽象クラスはまた、ときどきオブジェクトへの一時的な参照を蓄えるのにも使われます。 これらの両方の使い方は、後述の<a href="#Common_Patterns">共通パターン</a>を参照してください。</p>

<p> </p>

<h2 id=".E5.85.B7.E8.B1.A1.E3.82.AF.E3.83.A9.E3.82.B9" name=".E5.85.B7.E8.B1.A1.E3.82.AF.E3.83.A9.E3.82.B9">具象クラス</h2>

<p>具象クラスは string データを実際に蓄える必要があるコードの中で使うためのものです。 具象クラスのもっともありがちな使い方は、ローカル変数もしくはクラスや構造体のメンバとして使うというものです。 抽象クラスはそれぞれデータの格納方式が違うために、大抵は具象クラスの格納方針も異なります。</p>

<p>以下はに、もっとも一般的な具象クラスの一覧を示します。一度それらになじんだら、<a href="#Appendix_WhatToUse">どのクラスをいつ使うか</a>を参照してください。 The following is a list of the most common concrete classes. Once you are familiar with them, see the appendix describing <a href="#Appendix_WhatToUse">What Class to Use When</a>.</p>

<ul>
 <li><code class="decl">nsString / nsCString</code> - バッファがヒープ上に割り当てられている null 終端 string です。 string オブジェクトがなくなったときにそのバッファは破棄されます。</li>
 <li><code class="decl">nsAutoString / nsCAutoString</code> - nsString から派生した、 string 自身と同じ格納スペースに 64文字バッファを持つ string。 もし、文字長が 64より長い string が nsAutoString に代入されると、新しいバッファがヒープ上に割り当てられます。 これはメンバ変数としてはあまり用いられるべきではないでしょう。</li>
 <li><code class="decl">nsXPIDLString / nsXPIDLCString</code>- nsString から派生した文字列で、 このクラスは <code>getter_Copies()</code> 演算子によって、XPIDL の<code>出力 wstring / string</code> パラメータへの簡単なアクセスをサポートしています。</li>
 <li><code class="decl">nsDependentString</code>- nsString から派生した文字列で、 この string は自分自身ではバッファを<strong>持ちません</strong>。 生の文字列（<code>const PRUnichar*</code> や <code>const char*</code>）を <code>nsAString</code> 型に変換するのに有用です。</li>
 <li><code class="decl">nsPrintfCString</code>- nsString から派生した文字列で、 この string は nsCAutoString のように振る舞います。 このクラスのコンストラクタで <code>printf</code> スタイルのフォーマットの string と引数リストから シングルバイトの string を作ることが出来ます。</li>
 <li><code class="decl">NS_LITERAL_STRING/NS_NAMED_LITERAL_STRING</code>- これらは（"abc" のような）リテラル stringを <code>nsAStrings</code> や nsString のサブクラスに変換します。 プラットフォームでサポートしているダブルバイト string リテラルにおいて（例：MSVC++ や -fshort-wchar オプションを付けた GCC）、これらは <code>nsDependentString</code> クラス周辺の単純なマクロです。 これらは <code>nsDependentString</code> による単なるラップより若干速いです。なぜなら、それらの長さの計算にコンパイラを使い、ダブルバイトリテラル string のごちゃごちゃしたクロスプラットフォーム上の細部を隠しもするからです。</li>
</ul>

<p>ヘルパールーチンなどの副産物として作られた具象クラスはたくさんあります。 これらのクラスは<em>直接使うことを避け</em>るべきです。 string ライブラリから自分のためのクラスを作ってください。</p>

<ul>
 <li><code class="decl">nsSubstringTuple</code> - <a href="#Concatenation">文字列連結</a>を通した生成</li>
 <li><code class="decl">nsDependentSubstring</code> - <a href="#Substring">Substring</a> を通した生成</li>
 <li><code class="decl">nsPromiseFlatString</code> - <a href="#Raw_Pointers"><code>PromiseFlatString()</code></a> を通した生成</li>
</ul>

<p>もちろん、あなたのコードの中のこれらの string クラスの参照が必要な時はあります。 しかし、一般的なルールでは、これらは使わない方がよいです。</p>

<h2 id=".E3.82.A4.E3.83.86.E3.83.AC.E3.83.BC.E3.82.BF" name=".E3.82.A4.E3.83.86.E3.83.AC.E3.83.BC.E3.82.BF">イテレータ</h2>

<p>イテレータは string の中の位置への参照を保つオブジェクトです。 ある意味で、これらは配列の中のインデックスを参照する数値や、 文字列の中の位置を参照する文字ポインタのようなものです。 イテレータは、文字列への読み込みと書き込みとを区別する文法的な意味も提供します。</p>

<p>イテレータは文字列の部分文字列の抽出のためにもっともよく用いられるべきです。 これらは文字列の内容の修正のための機能を提供しますが、 たいていはヘルパールーチン、つまり文字列自身のメソッドの方が、複雑な文字列変換より早いでしょう。</p>

<p>イテレータは繰り返している文字列クラスで宣言されます:</p>

<pre class="eval">nsAString::const_iterator start, end; // 読み取り専用イテレータ
    nsAStrings
    nsAFlatString::iterator substr_start, substr_end; // nsString のための書き込み用イテレータ
</pre>

<p>イテレータは string にある４つのメソッドのうちあなたが参照したい一つにより初期化されます:</p>

<pre class="eval">// 'str' から読み込もう
str.BeginReading(start); // 'str' の先頭で 'start' を初期化する
str.EndReading(end); // 'end' は string の終端になるでしょう

// 'url' に書き込みもしたいんです
url.BeginWriting(substr_start);
url.EndWriting(substr_end);
</pre>

<p>ポインタ参照オペレータ * によってイテレータが指す文字へアクセス可能です。</p>

<pre class="eval">if (*start == '[')
     printf("Starts with a bracket\n");
</pre>

<p>上記例では、'end' と 'substr_end' は実際にかつて string の終端だった文字を指すでしょう。 なので、.EndReading() の結果を直接ポインタ内容参照してはいけないことに注意してください。</p>

<p>二つのイテレータが同じ位置を指すかどうかは、== か != で調べることが出来ます。 ++ でイテレータの参照を進めることも出来ます。 ++ はイテレータの前にもってくることが好まれます。そして、それは一時的なイテレータの作成を防ぐことになります。</p>

<p> </p>

<pre class="eval">while (start != end) // string 全体を通して順番に回る
     ++start;
</pre>

<p>（const-iterators とは反対のように）書き込みイテレータにより、効果的に string に書き込むことが出来ます:</p>

<p> </p>

<pre class="eval">// * をすべて ! に変える
while (substr_start != substr_end) {
     if (*substr_start == '*')
          *substr_start = '!';
     ++substr_start;
}
</pre>

<p>With the patch for <a class="external" href="http://bugzilla.mozilla.org/show_bug.cgi?id=231995">bug 231995</a>, this loop is now as efficient as iterating with raw character pointers.</p>

<p> </p>

<h3 id=".E3.82.A4.E3.83.86.E3.83.AC.E3.83.BC.E3.82.BF.E3.81.AB.E3.82.88.E3.82.8B.E3.83.AB.E3.83.BC.E3.83.97" name=".E3.82.A4.E3.83.86.E3.83.AC.E3.83.BC.E3.82.BF.E3.81.AB.E3.82.88.E3.82.8B.E3.83.AB.E3.83.BC.E3.83.97">イテレータによるループ</h3>

<p><span id="comment">原文ではindex部分には残っていますが、見出し、a nameを含めて削除されています。</span></p>

<h2 id=".E3.83.98.E3.83.AB.E3.83.91.E3.83.BC.E3.82.AF.E3.83.A9.E3.82.B9.E3.81.A8.E9.96.A2.E6.95.B0" name=".E3.83.98.E3.83.AB.E3.83.91.E3.83.BC.E3.82.AF.E3.83.A9.E3.82.B9.E3.81.A8.E9.96.A2.E6.95.B0">ヘルパークラスと関数</h2>

<h3 id=".E6.96.87.E5.AD.97.E5.88.97.E6.A4.9C.E7.B4.A2" name=".E6.96.87.E5.AD.97.E5.88.97.E6.A4.9C.E7.B4.A2">文字列検索</h3>

<p><code>FindInReadable()</code> はかつての <code>string.Find(..)</code> の代わりのものです。 構文は:</p>

<pre class="eval">PRBool FindInReadable(const nsAString&amp; pattern,
                      nsAString::const_iterator start, nsAString::const_iterator end,
                      nsStringComparator&amp; aComparator = nsDefaultStringComparator());
</pre>

<p>これを使うために、<code>start</code> と <code>end</code> は検索したい文字列のそれぞれ先頭と終端をさしていなくてはなりません。 もし、探している文字列が見つかったら、<code>start</code> と <code>end</code> は見つかった部分の先頭と終端を指すように調整されます。 戻り値は、PR_TRUE か PR_FALSE で、文字列が見つかったかどうかを示します。</p>

<p>例:</p>

<pre class="eval">const nsAString&amp; str = GetSomeString();
nsAString::const_iterator start, end;

str.BeginReading(start);
str.EndReading(end);

NS_NAMED_LITERAL_STRING(valuePrefix, "value=");

if (FindInReadable(valuePrefix, start, end)) {
    // end は今、検索した文字の後ろを指している
    valueStart = end;
}
</pre>

<h3 id=".E3.83.A1.E3.83.A2.E3.83.AA.E5.89.B2.E5.BD.93" name=".E3.83.A1.E3.83.A2.E3.83.AA.E5.89.B2.E5.BD.93">メモリ割当</h3>

<p>既存の文字列から新しい文字列バッファ（<code>PRUnichar*</code>/<code>char*</code>）を割り当てるために好ましいメソッドは、 以下のメソッドです:</p>

<ul>
 <li><strong><code>PRUnichar* ToNewUnicode(<em>nsAString&amp;</em>)</code></strong> - nsAString から <code>PRUnichar*</code> を割り当てます。</li>
 <li><strong><code>char *ToNewCString(<em>nsACString&amp;</em>)</code></strong> - nsACString から <code>char*</code> バッファを割り当てます。 このメソッドは nsAStrings 上でも働きますが、暗黙の<a href="#Lossy_Conversions">損失の多い変換</a>となるでしょう。 この機能は入力が厳密に ASCII であることが判っている場合にだけ使うべきです。しばしば UTF8 への変換がより適しています。 次項 <code class="decl">ToNewUTF8String</code> も参照のこと。</li>
 <li><strong><code>char* ToNewUTF8String(<em>nsAString&amp;</em>)</code></strong> - 与えられた nsAString の UTF8 エンコードされたバージョンを含む新しい <code>char*</code> バッファを割り当てます。 詳細は<a href="#Unicode_Conversion">Unicode 変換</a>を参照して下さい。</li>
</ul>

<p>これらのメソッドは These methods return a buffer allocated using XPCOM's allocator (<code>nsMemory::Alloc</code>) instead of the traditional allocator (<code>malloc</code>, etc.). You should use <code>nsMemory::Free</code> to deallocate the result when you no longer need it. これらのメソッドは伝統的なアロケータ (<code>malloc</code> など)の代わりに XPCOM のアロケータ (<code>nsMemory::Alloc</code>)で割り当てられたバッファを返すでしょう。 必要としなくなった時、その戻り値を開放するために <code>nsMemory::Free</code> を使うべきです。</p>

<h3 id=".E6.97.A2.E5.AD.98.E3.81.AE.E6.96.87.E5.AD.97.E5.88.97.E3.81.AE.E6.96.AD.E7.89.87" name=".E6.97.A2.E5.AD.98.E3.81.AE.E6.96.87.E5.AD.97.E5.88.97.E3.81.AE.E6.96.AD.E7.89.87">既存の文字列の断片</h3>

<p>実際に新しいスペースを割り当てたり、その文字列の部分文字列の文字をコピーしたりしないで既存の文字列の部分文字列を参照するのはとても簡単です。<code>Substring()</code> はそのような文字列への参照を生成するのにとてもよいメソッドです。</p>

<pre class="eval">void ProcessString(const nsAString&amp; str) {
    const nsAString&amp; firstFive = Substring(str, 0, 5);
    // firstFive は今最初の 5 文字を示す文字列です
}
</pre>

<p> </p>

<h2 id="Unicode_.E5.A4.89.E6.8F.9B" name="Unicode_.E5.A4.89.E6.8F.9B">Unicode 変換</h2>

<p>文字列は二つの基本的な形式で<em>保存</em>することができます。 8 ビット文字（<code>char</code>）文字列もしくは、16 ビット文字（<code>PRUnichar</code>）文字列です。 クラス名に大文字の「C」を持つどの文字列クラスも、8 ビット文字を含みます。 それには、nsCString、nsDependentCString などのクラスが含まれます。 「C」を<em>持たない</em>どの文字列クラスも、16 ビット文字を含みます。</p>

<p>格納構造に加え、文字列はまた、<em>エンコード</em>もされているという側面があります。 文字列のエンコーディングは、8 もしくは 16 ビットの文字列として unicode 文字値の組を保持することを意味します。 大きな文字値を小さな容量の文字列として保存する方法がたくさんあるため、エンコーディングがたくさんあります。 <em>文字セット</em>は、特定のエンコーディング方法の人間が理解できる名称です。 例えば、「ASCII」は 7 ビット値を 8 ビット文字列にマッピングした文字セットです。 「isolatin1」は8 ビット文字列で西欧文字エンコーディングするための共通文字セットです。</p>

<p>文字列の文字セットは、文字列クラスの名前によって定義されて<em>いません</em>。 そのかわり、文字列の適切なエンコーディングを決定することは実装者の責任です。 もっとも一般的なのエンコーディングは:</p>

<ul>
 <li><strong>ASCII</strong> - 基本的な英語のみの文字列のための 8 ビットエンコーディングです。 どの ASCII 値も配列の正確に 1 バイトに格納されます。</li>
 <li><strong>UCS2</strong> - 基本の unicode 格納のためのエンコーディングです。 UCS2 で格納された文字の unicode 値は、文字列クラスの正確に一つの 16 ビット <code>PRUnichar</code> に格納されます。</li>
 <li><strong>UTF8</strong> - unicode 値のための8 ビットエンコーディング。 どの UTF8 値も 1 から 6 バイトの組で保持されます。 UTF8 は unicode 文字セット全体を表現する能力があり、効率よく UTF32 へマップします。</li>
 <li><strong>UTF16</strong> - 拡張 unicode 格納のための 16 ビットエンコーディングです。 UCS2 に対して後方互換性があります。 UTF16で格納された unicode 文字値は、文字列クラスの 1 つもしくは 2 つの 16ビット <code>PRUnichar</code> を必要とします。 このエンコーディングは現在頻繁には使われません。しかし、より新しい unicode 標準が採用されるにつれて、きっと増えるでしょう。 UTF16 は unicode 文字セット全体を表現する能力があり、効率よく UTF32 へマップします。</li>
</ul>

<p>加えて、国際化ライブラリによって提供される文字通り何百のエンコーディングがあります。 これらのライブラリへのアクセスは、アプリケーションの一部であるか（例えば Mozilla の <code>nsICharsetConversionManager</code> のように）、オペレーティングシステムへビルドされている（例えば Unix 系 OS の <code>iconv()</code> のように）でしょう。</p>

<p>既存のコードで作業する時、正しい変換機構を決定するために、操作している文字列の現在の使い方を吟味することは重要です。</p>

<p>新しいコードを書く時、どの格納クラスそしてエンコーディングがもっとも適切かを知ろうとしても混乱するかもしれません。この問題への単純な答えはありません。しかし、少数の重要なガイドラインがあります:</p>

<ul>
 <li><strong>文字列はいつも ASCII ？</strong> 最初の、そして最大のもので、どの種類の値が文字列に格納されているかを決めることが必要です。文字列がいつでも内部の ASCII 文字列、例えば「left」、「true」、「background」などであれば、そのままの C-文字列がたぶん選ぶべきものです。</li>
 <li><strong>文字列が ASCII であれば、ASCII でない文字列と比較・代入・さもなければ相互作用しますか？</strong> 8 ビット ASCII 値を 16 ビット UCS2 文字列と代入もしくは比較するとき、実行時に「膨らませる」必要があります。 もし、文字列が十分に小さい（そう、 64 バイトより小さい）ならば、余計な変換を避けるために 16 ビット unicode クラスにも文字列を格納する、というのも手です。そのかわり、ASCII 文字列が、8 ビット文字列だった場合に比べて 2 倍のスペース、つまり 16 ビット unicode 文字列と同じスペースを占める、という欠点があります。</li>
 <li><strong>文字列はたいてい ASCII であるけれど、unicode をサポートしなくていいのでしょうか？</strong> 文字列はほとんど大抵 ASCII であるけれど、unicode 値も格納する必要があるのなら、UTF8 は正しいエンコーディングだ。 ASCII 値は 8 ビットのまま格納され、拡張 unicode 値は 2 〜 6 バイトで格納されるでしょう。 しかし、もし文字列が unicode 値との比較や代入までも必要とするのなら、実行時変換が必要となるでしょう。</li>
 <li><strong>ASCII でない大きな文字列データを格納しますか？</strong> ここに至るまでは、 UTF8 は理想的な文字列に見えます。 欠点は、西欧以外の文字のほとんど（例えば日本語文字）を使う場合に、UTF8 は「ふくれ気味な」エンコーディングです。 UTF-8 では、日本語文字列は大抵一文字あたり 3 バイト必要です。 UCS2 では、一文字が 2 バイトであるのと比べて、日本語テキストにおいて UTF-8 は相当に多くのサイズを消費します。</li>
 <li><strong>unicode 文字列のコンテントを処理する必要がありますか？</strong> UTF8 やその他の 8 ビット格納形式で unicode 値をエンコーディングすることの一つの問題点は、実際も unicode 値も文字列の中で複数バイトにわたることです。 ほとんどのエンコーディングでは、実際のバイト数は文字から文字へで異なります。 それぞれの文字を通して反復処理する必要があるときには、エンコーディングを考慮する必要があります。 UCS2 文字列で反復処理するなら、これは非常に簡易です。なぜなら、どの 16 ビット PRUnichar も、unicode 値と対応するからです。</li>
</ul>

<p>ASCII、UTF8、UCS2 の変換を助けるため、 いくつかのヘルパーメソッドとヘルパークラスがあります。 これらのクラスのうちいくつかは、スタック上の一時オブジェクトとしてもっともよく使われるため、関数のように見えます。</p>

<p>To assist with ASCII, UT8 and UCS2 conversions, there are some helper methods and classes. Some of these classes look like functions, becuase they are most often used as temporary objects on the stack.</p>

<h4 id="UTF8_.2F_UCS2_.E5.A4.89.E6.8F.9B" name="UTF8_.2F_UCS2_.E5.A4.89.E6.8F.9B">UTF8 / UCS2 変換</h4>

<ul>
 <li><code class="decl">NS_ConvertUTF8toUCS2(<em>const nsACString&amp;</em>)</code> - UTF-8 エンコードされた nsACString もしくは <code>const char*</code> を UCS2 string に変換する nsAutoString のサブクラス。もし、代わりに <code>const PRUnichar*</code> バッファが必要なら、.get() メソッドを使ってください。例:</li>
</ul>

<pre class="eval">/* シグネチャ: void HandleUnicodeString(const nsAString&amp; str); */
object-&gt;HandleUnicodeString(<strong>NS_ConvertUTF8toUCS2</strong>(utf8String));
</pre>

<pre class="eval">/* シグネチャ: void HandleUnicodeBuffer(const PRUnichar* str); */
object-&gt;HandleUnicodeBuffer(<strong>NS_ConvertUTF8toUCS2</strong>(utf8String).get())

</pre>

<ul>
 <li><code class="decl">NS_ConvertUCS2toUTF8(<em>const nsAString&amp;</em>)</code> - UTF8 エンコードされた nsAString を UTF8 された文字列に変換する nsAFlatCString。上記同様に、<code>const char*</code> へアクセスするときは、.get() を使ってください。</li>
 <li><code class="decl">NS_ConvertUCS2toUTF8(<em>const nsAString&amp;</em>)</code> - UCS2 エンコードされた nsAString を UTF-8 エンコードされた string へ変換する nsCAutoString。 上記項目と同様に、<code>const char*</code> にアクセスするために .get() を使うことが出来ます。</li>
</ul>

<pre class="eval">/* シグネチャ: void HandleUTF8String(const nsACString&amp; str); */
object-&gt;HandleUTF8String(NS_ConvertUCS2toUTF8(unicodeString));
</pre>

<pre class="eval">/* シグネチャ: void HandleUTF8Buffer(const char* str); */
object-&gt;HandleUTF8Buffer(NS_ConvertUCS2toUTF8(unicodeString).get())
</pre>

<ul>
 <li><code class="decl">CopyUTF8toUCS2(<em>const nsACString&amp;, const nsAString&amp;</em>)</code> - 変換と割り当てを行う。</li>
</ul>

<pre class="eval">// UCS2 値を返す
void Foo::GetUnicodeValue(nsAString&amp; result) {
    CopyUTF8toUCS2(mLocalUTF8Value, result);
}
</pre>

<ul>
 <li><code class="decl">CopyUCS2toUTF8(<em>const nsAString&amp;, const nsACString&amp;</em>)</code> - 変換と割り当てを行う。</li>
</ul>

<pre class="eval">// UTF8 値を返す
void Foo::GetUTF8Value(nsACString&amp; result) {
    CopyUCS2toUTF8(mLocalUnicodeValue, result);
}
</pre>

<ul>
 <li><code class="decl">ToNewUTF8String(<em>const nsAString&amp;</em>)</code> - 割り当てと変換を行う</li>
</ul>

<pre class="eval">void Foo::GetUTF8Value(const char** result) {
  *result = ToNewUTF8String(mLocalUnicodeValue);
}
</pre>

<p> </p>

<h3 id=".E6.90.8D.E5.A4.B1.E3.81.AE.E5.A4.9A.E3.81.84.E5.A4.89.E6.8F.9B" name=".E6.90.8D.E5.A4.B1.E3.81.AE.E5.A4.9A.E3.81.84.E5.A4.89.E6.8F.9B">損失の多い変換</h3>

<p>以下はオリジナル文字列が ASCII ベースであることが保証できるときだけ使われるべきです。</p>

<h4 id="UCS2_.E3.81.8B.E3.82.89_ASCII_.E3.81.B8.E3.81.AE.E3.82.B3.E3.83.B3.E3.83.90.E3.83.BC.E3.82.BF" name="UCS2_.E3.81.8B.E3.82.89_ASCII_.E3.81.B8.E3.81.AE.E3.82.B3.E3.83.B3.E3.83.90.E3.83.BC.E3.82.BF">UCS2 から ASCII へのコンバータ</h4>

<p>これらのコンバータ（変換機構）は、変換プロセスの中で<em><strong>情報の消失</strong></em>があるため<em><strong>とても危険</strong></em>です。<em><strong>UCS2 から ASCII への変換は、文字列が ASCII であることが保証されない限りさけるべきです</strong></em>。どの UCS2（16 ビット）文字も、8 ビット文字は単に 8 ビット文字にキャストされます。それは、0xFF を超えるすべての文字の値は任意の 8 ビット文字に変換されてしまうということです。</p>

<ul>
 <li><code class="decl">NS_LossyConvertUCS2toASCII(<em>nsAString</em>)</code> - string の圧縮した値を含む一時バッファを持つ nsCAutoString。</li>
 <li><code class="decl">CopyUCS2toASCII(<em>nsAString</em>, <em>nsACString</em>)</code> - UCS2 から ASCII 文字列オブジェクトへコピーの変換をします。</li>
 <li><code class="decl">ToNewCString(<em>nsAString</em>)</code> - 新しい <code>char*</code> 文字列を割り当てます。</li>
</ul>

<p> </p>

<h4 id="ASCII_.E3.81.8B.E3.82.89_UCS2_.E3.81.B8.E3.81.AE.E3.82.B3.E3.83.B3.E3.83.90.E3.83.BC.E3.82.BF" name="ASCII_.E3.81.8B.E3.82.89_UCS2_.E3.81.B8.E3.81.AE.E3.82.B3.E3.83.B3.E3.83.90.E3.83.BC.E3.82.BF">ASCII から UCS2 へのコンバータ</h4>

<p>これらは、<em>ASCII でない文字列を無意味な unicode 文字列に壊してしまう</em>ため、<em><strong>とても危険</strong></em>です。 <em><strong>ASCII から UCS2 への変換は、文字列が ASCII であることが保証されない限りさけるべきです</strong></em>。 つまり、もし複数バイト文字セットの 8 ビット文字列エンコードされたものを持っている場合、文字列のどのバイトもただキャストによって 16 バイト数値に"水増し"されるだけなのです。</p>

<p>例えば、文字列の最初の unicode 文字が 4 バイトの UTF-8 シーケンスで表されているような UTF-8 文字列を想像してください。"水増しされた" unicode 文字列の最初の 4 バイトは最初の文字をあらわす 4 つの値を含んでいます。これらの値は文字列を UCS2 として扱うなら無意味です。</p>

<ul>
 <li><code class="decl">NS_ConvertASCIItoUCS2(<em>nsACString</em>)</code> - string の水増しした値を含む一時バッファを持つ nsCAutoString。</li>
 <li><code class="decl">NS_ConvertASCIItoUCS2(<em>nsACString</em>)</code> - 水増しした文字列の値を含む一時バッファをもつ nsAFlatString。</li>
 <li><code class="decl">CopyASCIItoUCS2(<em>nsACString</em>, <em>nsAString</em>)</code> - ある文字列から unicode 文字列オブジェクトへコピーの変換をします。</li>
 <li><code class="decl">ToNewUnicode(<em>nsACString</em>)</code> - 水増しした値を含む新しい <code>PRUnichar*</code> 文字列を生成します。</li>
</ul>

<p> </p>

<h2 id=".E5.85.B1.E9.80.9A.E3.83.91.E3.82.BF.E3.83.BC.E3.83.B3" name=".E5.85.B1.E9.80.9A.E3.83.91.E3.82.BF.E3.83.BC.E3.83.B3">共通パターン</h2>

<p>多くの API は、呼び出し元に文字列を返すためのバッファを割り当てるメソッドとなります。 バッファを使い終えた時に呼び出し元が文字列を解放することを覚えている必要があるため、これはトリッキーでもあります。 幸運にも、<code>nsXPIDLString</code> クラスでこれを簡単に行えます。</p>

<p><br>
 メソッドはこのような感じです:</p>

<pre class="eval">void GetValue(PRUnichar** aValue)
{
    *aValue = ToNewUnicode(foo);
}
</pre>

<p>文字列クラスなしで、呼び出し元は文字列を解放する必要があるでしょう:</p>

<pre class="eval">{
    PRUnichar* val;
    GetValue(&amp;val);

    if (someCondition) {
        // 値を解放することを忘れてはいけない
        // don't forget to free the value!
        nsMemory::Free(val);
        return NS_ERROR_FAILURE;
    }

    ...
    // 後で、やはり解放を忘れてはいけない!
    // and later, still don't forget to free!
    nsMemory::Free(val);
}
</pre>

<p><code>nsXPIDLString</code> を使えば、このことを心配する必要はありません。 <code>getter_Copies()</code> を使って文字列クラスをラップするだけで、 スコープの外へ出た時にクラスがバッファを解放するでしょう。</p>

<pre class="eval">{
    nsXPIDLString val;
    GetValue(getter_Copies(val));
</pre>

<pre class="eval">    // val はここで自身によって解放されるでしょう
    // val will free itself here
    if (someCondition)
        return NS_ERROR_FAILURE;
    ...
    // 後で、やはり解放する必要がない
    // and later, still nothing to free
}
</pre>

<p>結果としてのコードはとても単純で、読みやすいです。</p>

<p> </p>

<h3 id=".E3.83.AA.E3.83.86.E3.83.A9.E3.83.AB.E6.96.87.E5.AD.97.E5.88.97" name=".E3.83.AA.E3.83.86.E3.83.A9.E3.83.AB.E6.96.87.E5.AD.97.E5.88.97">リテラル文字列</h3>

<p><em>リテラル文字列</em>は C++ コードに書かれた生の文字列の値です。 例えば、<code>printf("Hello World\n");</code> ステートメント中の値 <code>"Hello World\n"</code> はリテラル文字列です。 nsAString や nsACString が必要なとき、リテラル文字列値を挿入する必要がしばしば発生します。 これら 4 つのマクロは必要な変換のために提供されています:</p>

<ul>
 <li><code class="decl">NS_LITERAL_CSTRING(<em>literal string</em>)</code> - 一時的 nsCString</li>
 <li><code class="decl">NS_NAMED_LITERAL_CSTRING(<em>variable</em>,<em>literal string</em>);</code> - <em>variable</em> と名づけられた nsCString 変数を定義します</li>
 <li><code class="decl">NS_LITERAL_STRING(<em>literal string</em>)</code> - Unicode 版<em>literal string</em>（リテラル文字列）を持つ一時 nsString</li>
 <li><code class="decl">NS_NAMED_LITERAL_STRING(<em>variable</em>,<em>literal string</em>);</code> - Unicode 版 <em>literal string</em>（リテラル文字列）を持つ、名称 <em>variable</em> の nsString 変数を宣言する</li>
</ul>

<p>nsDependentCString もまた nsCString の中の文字列の値をラップすることを考えれば、これらのマクロの <code>CSTRING</code> 版は、一見不要に見えます。これらのマクロの長所は、これらの文字列の長さがコンパイル時に計算できるため、実行時に長さを決めるために文字列を読み込む必要がありません。</p>

<p>これらのマクロの <code>STRING</code> 版は、（例えば、MSVC++ や -fshort-wchar オプション付きの GCC のように）リテラル unicode 文字列をサポートするプラットフォーム上での実行時の変換をしないで、unicode 版の固定のリテラル string を宣言する移植性のある方法を提供します。</p>

<pre class="eval">// Init(const PRUnichar*) 呼び出し
Init(L"start value"); // よくない - L"..." は移植性が低い！
Init(NS_ConvertASCIItoUCS2("start value").get()); // よくない - 実行時の ASCII-&gt;UCS2 変換！

// Init(const nsAString&amp;) 呼び出し
Init(nsDependentString(L"start value")); // よくない - 移植性が低い！
Init(NS_ConvertASCIItoUCS2("start value")); // よくない - 実行時の ASCII-&gt;UCS2 変換！

// Init(const nsACString&amp;) 呼び出し
Init(nsDependentCString("start value")); // よくない - 文字列長が実行時に決まる
</pre>

<p>適切な NS_LITERAL_[C]STRING 使用法を以下にいくつか示します。</p>

<pre class="eval">// Init(const PRUnichar*) 呼び出し
Init(NS_LITERAL_STRING("start value").get());

// Init(const nsAString&amp;) 呼び出し
Init(NS_LITERAL_STRING("start value"));

// Init(const nsACString&amp;) 呼び出し
Init(NS_LITERAL_CSTRING("start value"));
</pre>

<p><br>
 これらのマクロを使った問題の追跡に役に立つであろう詳細をいくつか示します：</p>

<p><code>NS_LITERAL_STRING</code> は（Windows や Macintosh などといった）いくつかのプラットフォーム上でコンパイル時に UCS2 への変換をしますが、他のプラットフォームでは実行時に変換されます。NS_LITERAL_STRING を使うことによって、あなたのコードで問題のプラットフォームのために最良の変換が使われることを保証します。</p>

<p>いくつかのプラットフォームで実行時変換が行われるため、<code>NS_LITERAL_STRING/NS_NAMED_LITERAL_STRING</code> マクロ内部でのリテラル文字列連結の使用は、それらのプラットフォームではコンパイルされるでしょうが、コンパイル時変換をサポートするプラットフォーム上ではコンパイルできないでしょう。</p>

<p>以下に例示します：</p>

<p> </p>

<pre class="eval">// Init(nsAString&amp;) 呼び出し
Init(NS_LITERAL_STRING("start "
     "value")); // いくつかのプラットフォームでだけコンパイルされます。
</pre>

<p>その理由は、いくつかのプラットフォームで<code>L"..."</code> 構文が使われますが、これは連結の最初の文字列にだけ適用されるためです（<code>"start "</code>）。コンパイラは unicode でない文字列 <code>"value"</code> との連結を試みると困惑します。</p>

<h3 id=".E6.96.87.E5.AD.97.E5.88.97.E9.80.A3.E7.B5.90" name=".E6.96.87.E5.AD.97.E5.88.97.E9.80.A3.E7.B5.90">文字列連結</h3>

<p>文字列は <code>+</code> 演算子を用いて互いに連結可能です。結果となる文字列は <code>const nsAString</code> オブジェクトとなります。 結果となる文字列は、その他の <code>nsAString</code> のように振る舞いをさせることも参照もできます。 連結は<em>部分文字列のコピーではありません</em>。代わりに、オリジナルの文字列を参照するに過ぎません。 結果としての文字列は、少なくとも連結された文字列と同じだけの生存期間を持つという意味で、その部分文字列のすべてに依存します。</p>

<p>例えば、二つの文字列の値を使うことができ、接続を <code>const nsAString&amp;</code> をとる他の関数に引き渡すことができます：</p>

<pre class="eval">void HandleTwoStrings(const nsAString&amp; one, const nsAString&amp; two) {
    // HandleString(const nsAString&amp;) 呼び出し
    HandleString(one + two);
}
</pre>

<p>注意：このケースでは、二つの文字列は暗黙のうちに一時的な nsString に結びつけられ、 一時的 string は、<code>HandleString</code> に渡されます。 もし、<code>HandleString</code> がその入力を他の nsString へ代入したならば、 いくつかの文字列を連結し、その結果を一時変数に格納することもできます：</p>

<pre class="eval">NS_NAMED_LITERAL_STRING(start, "start ");
NS_NAMED_LITERAL_STRING(middle, "middle ");
NS_NAMED_LITERAL_STRING(end, "end");
// 3つの相互依存した断片を持つ string を生成 - 複雑なコピーではない！
nsString combinedString = start + middle + end;
</pre>

<p> </p>

<pre class="eval">// void HandleString(const nsAString&amp;); 呼び出し
HandleString(combinedString);
</pre>

<p>もし、一度きりだけ使う一時的なものを作るために <code>NS_LITERAL_STRING</code> を使うのなら、 結合の中で定義するのが安全でしょう。なぜなら、文字列バッファは（<code>nsSubstringTuple</code> 型の）一時的結合オブジェクトと同じ生存期間となるからです。</p>

<pre class="eval">// HandlePage(const nsAString&amp;); 呼び出し
// 結合された文字列はその部分文字列と同じ生存期間なので安全
HandlePage(NS_LITERAL_STRING("start ") + NS_LITERAL_STRING("end"));
</pre>

<h3 id=".E3.83.AD.E3.83.BC.E3.82.AB.E3.83.AB.E5.A4.89.E6.95.B0" name=".E3.83.AD.E3.83.BC.E3.82.AB.E3.83.AB.E5.A4.89.E6.95.B0">ローカル変数</h3>

<p>関数内のローカル変数は通常、スタック上に確保されます。 <code>nsAutoString</code>/<code>nsCAutoString</code> クラスは、 <code>nsString</code>/<code>nsCString</code> の派生物です。 これらが、文字列自身と同じ格納領域に割り当てられた 64 文字のバッファを持ちます。 もし、nsAutoString がスタック上に割り当てられていれば、文字列は破棄時に 64 文字スタックバッファ持ちます。 They own a 64-character buffer allocated in the same storage space as the string itself. If the nsAutoString is allocated on the stack, then it has at its disposal a 64-character stack buffer. このことにより、小さな文字列を扱う時、余計なメモリの割り当てをしないで実装することができます。</p>

<pre class="eval">...
nsAutoString value;
GetValue(value); // 結果が 64 文字より少なければ、
                 // 割り当てを省くことができる。
GetValue(value); // if the result is less than 64 characters,
                 // then this just saved us an allocation
...
</pre>

<h3 id=".E3.83.A1.E3.83.B3.E3.83.90.E5.A4.89.E6.95.B0" name=".E3.83.A1.E3.83.B3.E3.83.90.E5.A4.89.E6.95.B0">メンバ変数</h3>

<p>一般に、メンバ変数としては、<code>nsString</code> や <code>nsCString</code> といった具象クラスを使うべきでしょう。</p>

<pre class="eval">class Foo {
    ...
    // これらは UTF8 や unicode 値を各々格納する
    // these store UTF8 and Unicode values respectively
    nsCString mLocalName;
    nsString mTitle;
};
</pre>

<p>文字列は直接クラスの中で宣言され、文字列へのポインタとして宣言されるのではないことに注意してください。 このようにはしないでください:</p>

<p>Note that the strings are declared directly in the class, not as pointers to strings. Don't do this:</p>

<pre class="eval">class Foo {
public:
    Foo() { mLocalName = new nsCString(); }
    ~Foo() { delete mLocalName; }

private:
    // これらは UTF8 や unicode 値を各々格納する
    // these store UTF8 and Unicode values respectively
    nsCString* mLocalName;
};
</pre>

<p>上記のコードは文字列オブジェクトのコストを節約しているように見えるかもしれませんが、 <code>nsString</code>/<code>nsCString</code> は小さなオブジェクトです。 割り当てのオーバーヘッドは、ポインタで節約するよりも数バイト勝っているだけです。</p>

<p><br>
 その他の間違ったパターンとしては、メンバ変数として、 <code>nsAutoString</code>/<code>nsCAutoString</code> を使うというものがあります。 <a href="#Local_Variables">ローカル変数</a>で述べたように、 これらのクラスはとても大きなバッファを中にもって作られます。 もしクラスの中にこれらを持つことは、クラスを 64 バイト（<code>nsCAutoString</code>）もしくは 128 バイト（<code>nsAutoString</code>）膨らませることになります。</p>

<p><br>
 例:</p>

<pre class="eval">class Foo {
    ...

    // Foo クラスが 128 バイト膨らむ！
    // bloats 'Foo' by 128 bytes!
    nsAutoString mLocalName;
};
</pre>

<p> </p>

<h3 id=".E7.94.9F.E3.81.AE.E6.96.87.E5.AD.97.E3.83.9D.E3.82.A4.E3.83.B3.E3.82.BF" name=".E7.94.9F.E3.81.AE.E6.96.87.E5.AD.97.E3.83.9D.E3.82.A4.E3.83.B3.E3.82.BF">生の文字ポインタ</h3>

<p><code>PromiseFlatString()</code> は、元になった文字列と同じ値を含む null 終端のバッファを持つ一時バッファを生成するのに使うことができます。 <code>PromiseFlatString()</code> は必要ならば一時バッファを作ります。 これは多くの場合、nsAString を null 終端文字列を要求する API に通すために使われます。</p>

<p>以下の例では、nsAString はリテラル文字列と一体化されます。そして結果は単純な文字バッファを求める API に通されます。</p>

<pre class="eval">// URL を修正し、AddPage(const PRUnichar* url) へ通す
void AddModifiedPage(const nsAString&amp; url) {
    NS_NAMED_LITERAL_STRING(httpPrefix, "<a class="external" href="http://" rel="freelink">http://</a>");
    const nsAString&amp; modifiedURL = httpPrefix + url;

    // 一時バッファ生成
    AddPage(PromiseFlatString(modifiedURL).get());
}
</pre>

<p>既に null 終端である文字列を扱うとき、<code>PromiseFlatString()</code> は洗練された方法です。 そのようなケースで一時バッファを作らなくてすみます。</p>

<p> </p>

<pre class="eval">// URL を修正し、AddPage(const PRUnichar* url) へ通す
void AddModifiedPage(const nsAString&amp; url, PRBool addPrefix) {
    if (addPrefix) {
        // 一時バッファを作成<strong>なければならない</strong> - 文字列は複数の断片でできている
        NS_NAMED_LITERAL_STRING(httpPrefix, "<a class="external" href="http://" rel="freelink">http://</a>");
        AddPage(PromiseFlatString(httpPrefix + modifiedURL));
    } else {
        // 一時バッファを作成<strong>してもよい</strong>、実行時にチェックする
        AddPage(PromiseFlatString(url).get());
    }
}
</pre>

<p> </p>

<h2 id="IDL" name="IDL">IDL</h2>

<p>文字列ライブラリは IDL を通しても利用できます。 特別に IDL 型を定義することによって属性やメソッドを宣言することで、 string クラスは対応メソッドへの引数として使えます。</p>

<p> </p>

<h3 id="IDL_.E6.96.87.E5.AD.97.E5.88.97.E5.9E.8B" name="IDL_.E6.96.87.E5.AD.97.E5.88.97.E5.9E.8B">IDL 文字列型</h3>

<p>C++ シグネチャにより、メソッドのすべての引数が<a href="#Abstract_Classes">抽象クラス</a>をベースにしているようなのような上述通りの抽象型を定義することができます。 以下のテーブルには IDL のそれぞれの文字列型の目的を記します。</p>

<table class="standard-table">
 <tbody>
  <tr>
   <th class="header">IDL type</th>
   <th class="header">C++ Type</th>
   <th class="header">Purpose</th>
  </tr>
  <tr>
   <td><code>string</code></td>
   <td><code>char*</code></td>
   <td>Raw character pointer to ASCII (7-bit) string, no string classes used. High bit is not guaranteed across XPConnect boundaries</td>
  </tr>
  <tr>
   <td><code>wstring</code></td>
   <td><code>PRUnichar*</code></td>
   <td>Raw character pointer to UTF-16 string, no string classes used</td>
  </tr>
  <tr>
   <td><code>AString</code></td>
   <td><code>nsAString</code></td>
   <td>UTF-16 string</td>
  </tr>
  <tr>
   <td><code>ACString</code></td>
   <td><code>nsACString</code></td>
   <td>8-bit string, all bits are preserved across XPConnect boundaries</td>
  </tr>
  <tr>
   <td><code>AUTF8String</code></td>
   <td><code>nsACString</code></td>
   <td>UTF-8 string - converted to UTF-16 as necessary when value is used across XPConnect boundaries</td>
  </tr>
  <tr>
   <td><code>DOMString</code></td>
   <td><code>nsAString</code></td>
   <td>UTF-16 string used in the DOM. More or less the same as <code>AString</code>, but in JavaScript it has no distinction between whether the string is void or just empty. (not sure on this, looking for corrections.</td>
  </tr>
 </tbody>
</table>

<h3 id="C.2B.2B_.E3.82.B7.E3.82.B0.E3.83.8D.E3.83.81.E3.83.A3" name="C.2B.2B_.E3.82.B7.E3.82.B0.E3.83.8D.E3.83.81.E3.83.A3">C++ シグネチャ</h3>

<p>IDL では、<code>in</code> 引数は読み込み専用で、*String 引数に対する C++ シグネチャにより、それらの引数のための <code>const nsAString&amp;</code> を使った上記ガイドラインが行えます。 <code>out</code> と <code>inout</code> 引数は、呼ばれた側で書き込み可能なよう単純に <code>nsAString</code> として定義されています。</p>

<table class="standard-table">
 <tbody>
  <tr>
   <th class="header">IDL</th>
   <th class="header">C++</th>
  </tr>
  <tr>
   <td>
    <pre class="eval">
interface nsIFoo : nsISupports {

    attribute AString utf16String;




    AUTF8String getValue(in ACString key);

};
</pre>
   </td>
   <td>
    <pre class="eval">
class nsIFoo : public nsISupports {

     NS_IMETHOD GetUtf16String(nsAString&amp;
                               aResult) = 0;
     NS_IMETHOD SetUtf16String(const nsAString&amp;
                              aValue) = 0;

     NS_IMETHOD GetValue(const nsACString&amp; aKey,
                     nsACString&amp; aResult) = 0;
};
</pre>
   </td>
  </tr>
 </tbody>
</table>

<p>上記の例では、<code>unicodeString</code> は Unicode 文字列として扱われています。 <code>GetUnicodeString()</code> のインプリメントでは <code>aResult.Assign</code> を値を返す（"return"する）のに使っています。 <code>SetUnicodeString()</code> では、文字列の値は<a href="#Iterators">イテレータ</a>、<a href="#Raw_Pointers"><code>PromiseFlatString</code></a>、その他の文字列への代入などを含む雑多なメソッドを通して使うことができます。</p>

<p><code>GetValue()</code> では、最初の引数である <code>aKey</code> は、生の 8 ビット 値の連続として扱われます。 <code>aKey</code> 内の ASCII でないどの文字列も、XPConnect 境界を越えた場合も内容が保証されます。 <code>GetValue()</code> のインプリメンテーションは UTF-8 エンコードされた 8 ビット文字列の aResult への代入となっています。 もし、このメソッドがスクリプトからの呼び出しなどによって XPConnect の境界を越えて呼ばれたとき、結果は UTF-8 から UCS2へデコードされ、Unicode 値として利用されます。</p>

<h3 id=".E6.96.87.E5.AD.97.E5.88.97.E5.9E.8B.E3.81.AE.E9.81.B8.E6.8A.9E" name=".E6.96.87.E5.AD.97.E5.88.97.E5.9E.8B.E3.81.AE.E9.81.B8.E6.8A.9E">文字列型の選択</h3>

<p>IDL で使う正しい文字列型を決めるのは難しいかもしれません。 以下の点は適切な文字列型を決める助けになるでしょう。</p>

<ul>
 <li>文字列クラスを用いることは、<code>out</code> 引数へ新規にメモリ割当をすることを防ぐでしょう。 例えば、もし呼び出し側が <code>nsAutoString</code> を <code>out</code> 引数のための値を受け取るのに使っている場合、（C++ 内で単純に <code>nsAString</code> として定義されている）短い（64 文字以下の）値の <code>out</code> 引数への代入は <code>nsAutoString</code> のバッファへの値のコピーに過ぎません。 それ以上に、文字列クラスを使うことで、文字列バッファを共有することができます。 多くの場合、ある文字列オブジェクトから別の文字列オブジェクトへ代入することにより、参照のカウントを単に増やすことを優先してコピーを避けることが出来ます。</li>
 <li>文字列クラスを使った <code>in</code> 文字列は、しばしば長さを事前に計算します。これはパフォーマンス上のメリットとなるでしょう。</li>
 <li>生の文字バッファが必要とされる場所では、<code>string</code> と <code>wstring</code> は <code>PromiseFlatString</code> よりも高速なアクセスを提供します。</li>
 <li><code>AUTF8String</code> で定義された UTF-8 文字列は、XPConnect 境界を越えるとき、デコードされる必要があるでしょう。 これはパフォーマンスに打撃を与えます。一方で、 UTF-8 文字列は共通で用いられる ASCII 文字列では省スペースしか占有しません。</li>
 <li><code>wstring</code> や <code>AString</code> で定義された Unicode 文字列は、Unicode 値が必要とされるときは、速いです。 しかし、もし値によりしばしば ASCII が使われるなら、下敷きとなった文字列の格納スペースの半分は無駄になります。</li>
</ul>

<h2 id=".E4.BB.98.E9.8C.B2_A_.E3.81.A9.E3.81.AE.E3.82.AF.E3.83.A9.E3.82.B9.E3.82.92.E3.81.84.E3.81.A4.E4.BD.BF.E3.81.86.E3.81.8B" name=".E4.BB.98.E9.8C.B2_A:_.E3.81.A9.E3.81.AE.E3.82.AF.E3.83.A9.E3.82.B9.E3.82.92.E3.81.84.E3.81.A4.E4.BD.BF.E3.81.86.E3.81.8B">付録 A: どのクラスをいつ使うか</h2>

<p>この表はどのクラスをいつ使うべきかを示すクィックリファレンスです。</p>

<table class="alternate data">
 <tbody>
  <tr>
   <th>内容</th>
   <th>クラス</th>
   <th>メモ</th>
  </tr>
  <tr class="even">
   <td>ローカル変数</td>
   <td><code>nsAutoString</code><code>nsCAutoString</code></td>
   <td> </td>
  </tr>
  <tr class="odd">
   <td>クラスのメンバ変数</td>
   <td><code>nsString</code><code>nsCString</code></td>
   <td> </td>
  </tr>
  <tr class="even">
   <td>メソッドの引数の型</td>
   <td><code>nsAString</code><code>nsACString</code></td>
   <td>引数に抽象クラスを使う。入力引数には <code>const nsAString&amp;</code> を使い、出力引数には <code>nsAString&amp;</code> を使う。</td>
  </tr>
  <tr class="odd">
   <td>出力文字列を回収するRetrieving "out" string/wstrings</td>
   <td><code>nsXPIDLString</code><code>nsXPIDLCString</code></td>
   <td><code>getter_Copies()</code> を使う。<code>nsString</code> / <code>nsCString</code> と似ている。</td>
  </tr>
  <tr class="even">
   <td>文字バッファをラップするbuffers</td>
   <td><code>nsDependentString</code><code>nsDependentCString</code></td>
   <td><code>const char*</code> / <code>const PRUnichar*</code> バッファをラップする。</td>
  </tr>
  <tr class="odd">
   <td>リテラル文字列</td>
   <td><code>NS_LITERAL_STRING</code><code>NS_LITERAL_CSTRING</code></td>
   <td>nsDependent[C]String と似ているが、ビルド時に長さが事前計算される。</td>
  </tr>
 </tbody>
</table>

<h2 id=".E4.BB.98.E9.8C.B2_B_nsAString_.E3.83.AA.E3.83.95.E3.82.A1.E3.83.AC.E3.83.B3.E3.82.B9.3D" name=".E4.BB.98.E9.8C.B2_B:_nsAString_.E3.83.AA.E3.83.95.E3.82.A1.E3.83.AC.E3.83.B3.E3.82.B9.3D">付録 B: nsAString リファレンス=</h2>

<p>読み込み専用メソッド</p>

<ul>
 <li><strong>Length()</strong></li>
 <li><strong>IsEmpty()</strong></li>
 <li><strong>IsVoid()</strong></li>
 <li><strong>BeginReading(<em>iterator</em>)</strong></li>
 <li><strong>EndReading(<em>iterator</em>)</strong></li>
 <li><strong>Equals(<em>string</em>[,<em>comparator</em>])</strong></li>
 <li><strong>First()</strong></li>
 <li><strong>Last()</strong></li>
 <li><strong>CountChar()</strong></li>
 <li><strong>Left(<em>outstring</em>, <em>length</em>)</strong></li>
 <li><strong>Mid(<em>outstring</em>, <em>position</em>, <em>length</em>)</strong></li>
 <li><strong>Right(<em>outstring</em>, <em>length</em>)</strong></li>
 <li><strong>FindChar(<em>character</em>)</strong></li>
</ul>

<p>文字列を修正するメソッド</p>

<ul>
 <li><strong>Assign(<em>string</em>)</strong></li>
 <li><strong>Append(<em>string</em>)</strong></li>
 <li><strong>Insert(<em>string</em>)</strong></li>
 <li><strong>Cut(<em>start</em>, <em>length</em>)</strong></li>
 <li><strong>Replace(<em>start</em>, <em>length</em>, <em>string</em>)</strong></li>
 <li><strong>Truncate(<em>length</em>)</strong></li>
 <li><strong>SetIsVoid(<em>state</em>)</strong></li>
 <li><strong>BeginWriting(<em>iterator</em>)</strong></li>
 <li><strong>EndWriting(<em>iterator</em>)</strong></li>
 <li><strong>SetCapacity()</strong></li>
</ul>
