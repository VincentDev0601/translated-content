---
title: Special Operators
slug: >-
  conflicting/Web/JavaScript/Guide/Expressions_and_Operators_d9fc22e5ddd08ea82ea5cf8ddb1d9915
translation_of: Web/JavaScript/Guide/Expressions_and_Operators
translation_of_original: Web/JavaScript/Guide/Obsolete_Pages/Operators/Special_Operators
original_slug: >-
  Web/JavaScript/Guide/Obsolete_Pages/Core_JavaScript_1.5_Guide/Operators/Special_Operators
---
<h3 id=".ED.8A.B9.EC.88.98_.EC.97.B0.EC.82.B0.EC.9E.90" name=".ED.8A.B9.EC.88.98_.EC.97.B0.EC.82.B0.EC.9E.90"> 특수 연산자 </h3>
<p>JavaScript 다음과 같은 특별한 연산자를 제공합니다.
</p>
<ul><li> {{ Anch("조건 연산자") }}
</li><li> {{ Anch("쉼표 연산자") }}
</li><li> {{ Anch("delete") }}
</li><li> {{ Anch("in") }}
</li><li> {{ Anch("instanceof") }}
</li><li> {{ Anch("new") }}
</li><li> {{ Anch("this") }}
</li><li> {{ Anch("typeof") }}
</li><li> {{ Anch("void") }}
</li></ul>
<h4 id=".EC.A1.B0.EA.B1.B4_.EC.97.B0.EC.82.B0.EC.9E.90" name=".EC.A1.B0.EA.B1.B4_.EC.97.B0.EC.82.B0.EC.9E.90"> 조건 연산자 </h4>
<p>조건 연산자는 JavaScript에서 유일하게 세 개의 피연산자를 사용하는 연산자입니다. 연산자는 조건에 따라 둘 중에 하나의 값을 가질 수 있습니다. 문법은 이렇습니다.
</p>
<pre>condition ? val1 : val2
</pre>
<p><code>condition</code>이 true이면 연산자는 <code>val1</code>의 값을 갖습니다. 그렇지 않으면 <code>val2</code>의 값을 갖습니다. 다른 표준 연산자를 사용할 수 있는 곳이면 어디든지 조건 연산자를 사용할 수 있습니다.
</p>
<pre>status = (age &gt;= 18) ? "adult" : "minor"
</pre>
<p>이 문장은 <code>age</code>가 18이거나 더 큰 경우에 <code>status</code> 변수에 "adult"라는 값을 할당합니다. 그렇지 않으면 "minor"라는 값을 할당합니다.
</p>
<h4 id=".EC.89.BC.ED.91.9C_.EC.97.B0.EC.82.B0.EC.9E.90" name=".EC.89.BC.ED.91.9C_.EC.97.B0.EC.82.B0.EC.9E.90"> 쉼표 연산자 </h4>
<p>쉼표 연산자(,)는 단순히 피연산자 둘을 모두 평가하고 두 번째 피연산자의 값을 반환하는 연산자입니다. 이 연산자는 주로 <code>for</code> 반복문에서 변수 여러 개가 매번 업데이트 되게 하는데 쓰입니다.
</p><p>예를 들어 <code>a</code>가 각각 10줄의 원소를 가지는 2차원 배열일 때, 다음 코드에서는 변수 두 개를 한 번에 바꾸기 위해서 쉼표 연산자를 사용하고 있습니다. 이 코드는 배열의 대각선 원소를 출력합니다.
</p>
<pre>for (var i=0, j=9; i &lt;= 9; i++, j--)
   document.writeln("a["+i+"]["+j+"]= " + a[i][j])
</pre>
<h4 id="delete" name="delete"> delete </h4>
<p>delete는 개체(object), 개체의 속성(property), 배열의 특정 인덱스에 있는 원소(element)를 지우는 연산자입니다. 문법은 이렇습니다.
</p>
<pre>delete objectName
delete objectName.property
delete objectName[index]
delete property // with 문장 안에서만 유효합니다
</pre>
<p><code>objectName</code>은 개체 이름이고, <code>property</code>는 개체에 존재하는 속성이고, <code>index</code>는 배열의 원소 위치를 나타내는 정수입니다.
</p><p>네 번째 형식은 개체의 속성을 지우는 코드인데, <code>with</code> 문장 안에서만 사용할 수 있습니다.
</p><p>암시적으로 선언된 변수를 지울 때는 <code>delete</code> 연산자를 사용할 수 있지만 <code>var</code> 문장을 이용해서 선언된 변수는 지울 수 없습니다.
</p><p><code>delete</code> 연산자 실행이 성공하면, 속성이나 원소가 <code>undefined</code>로 설정됩니다. <code>delete</code> 연산자는 실행이 가능하면 true를 반환하고, 불가능하면 false를 반환합니다.
</p>
<pre>x=42
var y= 43
myobj=new Number()
myobj.h=4      // h라는 속성을 만듭니다
delete x       // returns true (암시적으로 선언된 변수는 지울 수 있습니다)
delete y       // returns false (var로 선언한 변수는 지울 수 없습니다)
delete Math.PI // returns false (미리 정의된 속성은 지울 수 없습니다)
delete myobj.h // returns true (사용자 정의 속성은 지울 수 있습니다)
delete myobj   // returns true (암시적으로 선언되었으므로 지울 수 있습니다)
</pre>
<p><b>배열의 원소를 지우기</b><br>
배열의 원소를 지울 때, 배열의 길이에는 변화가 없습니다. 예를 들어, a{{ mediawiki.external(3) }}, a{{ mediawiki.external(4) }}를 지우더라도 a{{ mediawiki.external(4) }}와 a{{ mediawiki.external(3) }}은 여전히 정의되지 않습니다.
</p><p><code>delete</code> 연산자가 배열 원소를 제거할 때 원소는 더이상 배열에 존재하지 않습니다. 아래 예제에서 trees{{ mediawiki.external(3) }}은 <code>delete</code>로 제거되었습니다.
</p>
<pre>trees=new Array("redwood","bay","cedar","oak","maple")
delete trees[3]
if (3 in trees) {
   // 이 블록은 실행되지 않습니다.
}
</pre>
<p>배열 원소가 존재하긴 하지만 정의되지 않은 값을 가지도록 하고 싶다면 <code>delete</code> 연산자 대신 <code>undefined</code> 키워드를 사용하십시오. 다음 예제에서 <code>trees{{ mediawiki.external(3) }}</code>에 <code>undefined</code> 값을 할당했지만 배열 요소는 여전히 존재합니다.
</p>
<pre>trees=new Array("redwood","bay","cedar","oak","maple")
trees[3]=undefined
if (3 in trees) {
   // 이 블록은 실행됩니다.
}
</pre>
<h4 id="in" name="in"> in </h4>
<p><code>in</code> 연산자는 지정된 속성이 지정된 개체에 있으면 true를 반환합니다. 문법은 이렇습니다.
</p>
<pre>propNameOrNumber in objectName
</pre>
<p><code>propNameOrNumber</code>은 속성 이름을 나타내는 문자열이나 배열 인덱스를 나타내는 수이고, <code>objectName</code>은 개체 이름입니다.
</p><p>다음 예제는 <code>in</code> 연산자의 몇 가지 사용법을 보여줍니다.
</p>
<pre>// 배열
trees=new Array("redwood","bay","cedar","oak","maple")
0 in trees        // returns true
3 in trees        // returns true
6 in trees        // returns false
"bay" in trees    // returns false (원하는 인덱스를 지정해야 하는데,
                  // 그 인덱스에 있는 값을 지정하면 안됩니다.)
"length" in trees // returns true (length는 배열의 속성입니다.)

// 미리 정의된 개체
"PI" in Math          // returns true
myString=new String("coral")
"length" in myString  // returns true

// 사용자 개체
mycar = {make:"Honda",model:"Accord",year:1998}
"make" in mycar  // returns true
"model" in mycar // returns true
</pre>
<h4 id="instanceof" name="instanceof"> instanceof </h4>
<p><code>instanceof</code>는 지정된 개체가 지정된 개체 형식이면 true를 반환합니다. 문법은 이렇습니다.
</p>
<pre>objectName instanceof objectType
</pre>
<p><code>objectName</code>은 <code>objectType</code>과 비교할 개체의 이름이고, <code>objectType</code>은 개체 형식으로 <code>Date</code>나 <code>Array</code> 같은 것입니다.
</p><p>실행중에 개체의 형식을 알고 싶으면 <code>instanceof</code>를 사용하면 됩니다. 예를 들어 예외를 처리할 때, 발생한 예외의 형식에 따라 서로 다른 예외 처리 코드를 실행할 수 있습니다.
</p><p>다음 코드에서 <code>theDay</code>가 <code>Date</code> 개체인지 결정하기 위해서 <code>instanceof</code>를 사용합니다. <code>theDay</code>는 <code>Date</code> 개체이기 때문에 <code>if</code>문 안에 있는 문장이 실행됩니다.
</p>
<pre>theDay=new Date(1995, 12, 17)
if (theDay instanceof Date) {
   // 실행할 문장
}
</pre>
<h4 id="new" name="new"> new </h4>
<p>사용자 정의 개체 형식이나 <code>Array, Boolean, Date, Function, Image, Number, Object, Option, RegExp, String</code> 같이 미리 정의된 개체 형식의 인스턴스를 만들 때 <code>new</code> 연산자를 사용합니다. 서버에서는 <code>DbPool, Lock, File, SendMail</code> 등을 만들 때 사용할 수 있습니다. <code>new</code>는 다음과 같이 사용합니다.
</p>
<pre>objectName = new objectType ( param1 [,param2] ...[,paramN] )
</pre>
<p><a href="ko/Core_JavaScript_1.5_Guide/Creating_New_Objects/Using_Object_Initializers">개체 초기화 지정자 사용하기</a>에 설명한 것처럼 개체 초기화 지정자를 이용해서 개체를 만들 수도 있습니다.
</p><p>더 많은 정보를 얻으려면 JavaScript 레퍼런스의 <a href="ko/Core_JavaScript_1.5_Reference/Operators/Special_Operators/new_Operator">new 연산자</a> 페이지를 보시기 바랍니다.
</p>
<h4 id="this" name="this"> this </h4>
<p>현재 개체를 참조할 때 <code>this</code> 키워드를 사용합니다. 일반적으로 <code>this</code>는 메소드를 호출하는 개체를 참조합니다. 다음과 같이 사용하면 됩니다.
</p>
<pre>this[.propertyName]
</pre>
<p><b>예제 1.</b><br>
개체의 <code>value</code> 속성이 높거나 낮은 값을 가지는지 검증하는 <code>validate</code>라는 함수가 있다고 가정합시다.
</p>
<pre>function validate(obj, lowval, hival) {
   if ((obj.value &lt; lowval) || (obj.value &gt; hival))
      alert("Invalid Value!")
}
</pre>
<p>이제 우리는 폼의 각 요소의 <code>onChange</code> 이벤트 핸들러에서 <code>validate</code> 함수를 호출하면서, <code>this</code>를 이용하여 스스로를 함수에 전달할 수 있습니다.
</p>
<pre>&lt;B&gt;Enter a number between 18 and 99:&lt;/B&gt;
&lt;INPUT TYPE = "text" NAME = "age" SIZE = 3
   onChange="validate(this, 18, 99)"&gt;
</pre>
<p><b>예제 2.</b><br>
<code>form</code> 속성과 결합되면, <code>this</code>는 현재 개체가 포함된 폼을 참조할 수 있습니다. 다음 예제에서 <code>myForm</code> 폼은 <code>Text</code> 개체와 버튼을 포함하고 있습니다. 사용자가 버튼을 클릭하면 <code>Text</code> 개체의 값이 폼 이름으로 설정됩니다. 버튼의 <code>onClick</code> 이벤트 핸들러는 부모 폼인 <code>myForm</code>을 참조하기 위해서 <code>this.form</code>을 사용하고 있습니다.
</p>
<pre>&lt;FORM NAME="myForm"&gt;
Form name:&lt;INPUT TYPE="text" NAME="text1" VALUE="Beluga"&gt;
&lt;P&gt;
&lt;INPUT NAME="button1" TYPE="button" VALUE="Show Form Name"
   onClick="this.form.text1.value=this.form.name"&gt;
&lt;/FORM&gt;
</pre>
<h4 id="typeof" name="typeof"> typeof </h4>
<p><code>typeof</code> 연산자는 둘 중 한 가지 방법으로 사용할 수 있습니다.
</p>
<pre>1. typeof operand
2. typeof (operand)
</pre>
<p><code>typeof</code> 연산자는 피연산자의 평가되지 않은 형식을 나타내는 문자열을 반환합니다. <code>피연산자</code>는 string, variable, keyword, object 등의 타입을 반환하게 됩니다. 괄호는 선택적입니다.
</p><p>우리가 이런 변수를 정의했다고 해봅시다.
</p>
<pre>var myFun = new Function("5+2")
var shape="round"
var size=1
var today=new Date()
</pre>
<p><code>typeof</code>는 이 변수들에 대해서 다음과 같은 결과를 반환할 것입니다.
</p>
<pre>typeof myFun is function
typeof shape is string
typeof size is number
typeof today is object
typeof dontExist is undefined
</pre>
<p><code>true</code>와 <code>null</code> 키워드에 대해서 <code>typeof</code> 연산자는 다음과 같은 결과를 반환합니다.
</p>
<pre>typeof true is boolean
typeof null is object
</pre>
<p>수와 문자열에 대해서 <code>typeof</code> 연산자는 다음과 같은 결과를 반환합니다.
</p>
<pre>typeof 62 is number
typeof 'Hello world' is string
</pre>
<p>속성 값에 대해서 <code>typeof</code> 연산자는 속성이 포함하고 있는 값의 형식을 반환합니다.
</p>
<pre>typeof document.lastModified is string
typeof window.length is number
typeof Math.LN2 is number
</pre>
<p>메소드와 함수에 사용하면 <code>typeof</code> 연산자는 다음과 같은 결과를 반환합니다.
</p>
<pre>typeof blur is function
typeof eval is function
typeof parseInt is function
typeof shape.split is function
</pre>
<p>미리 정의된 개체들에 대해서 <code>typeof</code> 연산자는 다음과 같은 결과를 반환합니다.
</p>
<pre>typeof Date is function
typeof Function is function
typeof Math is function
typeof Option is function
typeof String is function
</pre>
<h4 id="void" name="void"> void </h4>
<p><code>void</code> 연산자는 다음과 같이 사용할 수 있습니다.
</p>
<pre>1. void (expression)
2. void expression
</pre>
<p><code>void</code> 연산자는 표현식이 값을 반환하지 않으면서 평가되어야 한다고 지정하는데 사용됩니다. <code>expression</code>은 평가하려는 JavaScript 표현식입니다. 표현식을 감싸는 괄호는 선택적이지만 사용하는 쪽이 더 좋은 스타일입니다.
</p><p>표현식을 하이퍼텍스트 링크로 지정하기 위해서 <code>void</code> 연산자를 사용할 수 있습니다. 표현식이 평가되기는 하지만 현재 문서 대신 로드되지는 않습니다.
</p><p>아래 코드는 사용자가 클릭할 때 아무 동작도 하지 않는 하이퍼텍스트 링크를 만듭니다. 사용자가 링크를 클릭하면 <code>void(0)</code>는 정의되지 않은 것(undefined)으로 평가되고 JavaScript에서 아무런 효과가 없습니다.
</p>
<pre>&lt;A HREF="javascript:void(0)"&gt;Click here to do nothing&lt;/A&gt;
</pre>
<p>다음 코드는 클릭하면 폼을 제출하는 하이퍼텍스트 링크를 만듭니다.
</p>
<pre>&lt;A HREF="javascript:void(document.form.submit())"&gt;
Click here to submit&lt;/A&gt;
</pre>
<p>{{ PreviousNext("Core_JavaScript_1.5_Guide:Operators:String_Operators", "Core_JavaScript_1.5_Guide:Creating_a_Regular_Expression") }}
</p>{{ languages( { "en": "en/Core_JavaScript_1.5_Guide/Operators/Special_Operators", "fr": "fr/Guide_JavaScript_1.5/Op\u00e9rateurs/Op\u00e9rateurs_sp\u00e9ciaux", "ja": "ja/Core_JavaScript_1.5_Guide/Operators/Special_Operators", "pl": "pl/Przewodnik_po_j\u0119zyku_JavaScript_1.5/Operatory/Operatory_specjalne" } ) }}
