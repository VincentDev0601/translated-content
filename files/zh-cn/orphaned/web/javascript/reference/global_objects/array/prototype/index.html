---
title: Array.prototype
slug: Web/JavaScript/Reference/Global_Objects/Array/prototype
tags:
  - Array.prototype
translation_of: Web/JavaScript/Reference/Global_Objects/Array/prototype
---
<div>{{JSRef}}</div>

<p><strong><code>Array.prototype</code></strong>  属性表示 {{jsxref("Array")}} 构造函数的原型，并允许您向所有Array对象添加新的属性和方法。</p>

<pre class="brush: js">/*
如果JavaScript本身不提供 first() 方法，
添加一个返回数组的第一个元素的新方法。
*/

if(!Array.prototype.first) {
    Array.prototype.first = function() {
        console.log(`如果JavaScript本身不提供 first() 方法，
添加一个返回数组的第一个元素的新方法。`);
        return this[0];
    }
}
</pre>

<h2 id="Description" name="Description">描述</h2>

<p>{{jsxref("Array")}}实例继承自 <strong>Array.prototype </strong>。与所有构造函数一样，您可以更改构造函数的原型对象，以对所有 {{jsxref("Array")}} 实例进行更改。例如，可以添加新方法和属性以扩展所有Array对象。这用于 {{Glossary("Polyfill", "polyfilling")}}， 例如。</p>

<p>鲜为人知的事实：<code>Array.prototype</code> 本身也是一个 {{jsxref("Array")}}。</p>

<pre class="brush: js">Array.isArray(Array.prototype);
// true
</pre>

<p>{{js_property_attributes(0, 0, 0)}}</p>

<h2 id="Properties" name="Properties">属性</h2>

<dl>
 <dt><code>Array.prototype.constructor</code></dt>
 <dd>所有的数组实例都继承了这个属性，它的值就是 {{jsxref("Array")}}，表明了所有的数组都是由 {{jsxref("Array")}} 构造出来的。</dd>
 <dt>{{jsxref("Array.prototype.length")}}</dt>
 <dd>上面说了，因为 <code>Array.prototype</code> 也是个数组，所以它也有 <code>length</code> 属性，这个值为 <code>0</code>，因为它是个空数组。</dd>
</dl>

<h2 id="Methods" name="Methods">方法</h2>

<h3 id="Mutator_methods" name="Mutator_methods">会改变自身的方法</h3>

<p>下面的这些方法会改变调用它们的对象自身的值：</p>

<dl>
 <dt>{{jsxref("Array.prototype.copyWithin()")}} {{experimental_inline}}</dt>
 <dd>在数组内部，将一段元素序列拷贝到另一段元素序列上，覆盖原有的值。</dd>
 <dt>{{jsxref("Array.prototype.fill()")}} {{experimental_inline}}</dt>
 <dd>将数组中指定区间的所有元素的值，都替换成某个固定的值。</dd>
 <dt>{{jsxref("Array.prototype.pop()")}}</dt>
 <dd>删除数组的最后一个元素，并返回这个元素。</dd>
 <dt>{{jsxref("Array.prototype.push()")}}</dt>
 <dd>在数组的末尾增加一个或多个元素，并返回数组的新长度。</dd>
 <dt>{{jsxref("Array.prototype.reverse()")}}</dt>
 <dd>颠倒数组中元素的排列顺序，即原先的第一个变为最后一个，原先的最后一个变为第一个。</dd>
 <dt>{{jsxref("Array.prototype.shift()")}}</dt>
 <dd>删除数组的第一个元素，并返回这个元素。</dd>
 <dt>{{jsxref("Array.prototype.sort()")}}</dt>
 <dd>对数组元素进行排序，并返回当前数组。</dd>
 <dt>{{jsxref("Array.prototype.splice()")}}</dt>
 <dd>在任意的位置给数组添加或删除任意个元素。</dd>
 <dt>{{jsxref("Array.prototype.unshift()")}}</dt>
 <dd>在数组的开头增加一个或多个元素，并返回数组的新长度。</dd>
</dl>

<h3 id="Accessor_methods" name="Accessor_methods">不会改变自身的方法</h3>

<p>下面的这些方法绝对不会改变调用它们的对象的值，只会返回一个新的数组或者返回一个其它的期望值。</p>

<dl>
 <dt>{{jsxref("Array.prototype.concat()")}}</dt>
 <dd>返回一个由当前数组和其它若干个数组或者若干个非数组值组合而成的新数组。</dd>
 <dt>{{jsxref("Array.prototype.includes()")}} {{experimental_inline}}</dt>
 <dd>判断当前数组是否包含某指定的值，如果是返回 <code>true</code>，否则返回 <code>false</code>。</dd>
 <dt>{{jsxref("Array.prototype.join()")}}</dt>
 <dd>连接所有数组元素组成一个字符串。</dd>
 <dt>{{jsxref("Array.prototype.slice()")}}</dt>
 <dd>抽取当前数组中的一段元素组合成一个新数组。</dd>
 <dt>{{jsxref("Array.prototype.toSource()")}} {{non-standard_inline}}</dt>
 <dd>返回一个表示当前数组字面量的字符串。遮蔽了原型链上的 {{jsxref("Object.prototype.toSource()")}} 方法。</dd>
 <dt>{{jsxref("Array.prototype.toString()")}}</dt>
 <dd>返回一个由所有数组元素组合而成的字符串。遮蔽了原型链上的 {{jsxref("Object.prototype.toString()")}} 方法。</dd>
 <dt>{{jsxref("Array.prototype.toLocaleString()")}}</dt>
 <dd>返回一个由所有数组元素组合而成的本地化后的字符串。遮蔽了原型链上的 {{jsxref("Object.prototype.toLocaleString()")}} 方法。</dd>
 <dt>{{jsxref("Array.prototype.indexOf()")}}</dt>
 <dd>返回数组中第一个与指定值相等的元素的索引，如果找不到这样的元素，则返回 -1。</dd>
 <dt>{{jsxref("Array.prototype.lastIndexOf()")}}</dt>
 <dd>返回数组中最后一个（从右边数第一个）与指定值相等的元素的索引，如果找不到这样的元素，则返回 -1。</dd>
</dl>

<h3 id="Iteration_methods" name="Iteration_methods">遍历方法</h3>

<p>在下面的众多遍历方法中，有很多方法都需要指定一个回调函数作为参数。在每一个数组元素都分别执行完回调函数之前，数组的length属性会被缓存在某个地方，所以，如果你在回调函数中为当前数组添加了新的元素，那么那些新添加的元素是不会被遍历到的。此外，如果在回调函数中对当前数组进行了其它修改，比如改变某个元素的值或者删掉某个元素，那么随后的遍历操作可能会受到未预期的影响。总之，不要尝试在遍历过程中对原数组进行任何修改，虽然规范对这样的操作进行了详细的定义，但为了可读性和可维护性，请不要这样做。</p>

<dl>
 <dt>{{jsxref("Array.prototype.forEach()")}}</dt>
 <dd>为数组中的每个元素执行一次回调函数。</dd>
 <dt>{{jsxref("Array.prototype.entries()")}} {{experimental_inline}}</dt>
 <dd>返回一个数组迭代器对象，该迭代器会包含所有数组元素的键值对。</dd>
 <dt>{{jsxref("Array.prototype.every()")}}</dt>
 <dd>如果数组中的每个元素都满足测试函数，则返回 <code>true</code>，否则返回 <code>false。</code></dd>
 <dt>{{jsxref("Array.prototype.some()")}}</dt>
 <dd>如果数组中至少有一个元素满足测试函数，则返回 true，否则返回 false。</dd>
 <dt>{{jsxref("Array.prototype.filter()")}}</dt>
 <dd>将所有在过滤函数中返回 <code>true</code> 的数组元素放进一个新数组中并返回。</dd>
 <dt>{{jsxref("Array.prototype.find()")}} {{experimental_inline}}</dt>
 <dd>找到第一个满足测试函数的元素并返回那个元素的值，如果找不到，则返回 <code>undefined</code>。</dd>
 <dt>{{jsxref("Array.prototype.findIndex()")}} {{experimental_inline}}</dt>
 <dd>找到第一个满足测试函数的元素并返回那个元素的索引，如果找不到，则返回 <code>-1</code>。</dd>
 <dt>{{jsxref("Array.prototype.keys()")}} {{experimental_inline}}</dt>
 <dd>返回一个数组迭代器对象，该迭代器会包含所有数组元素的键。</dd>
 <dt>{{jsxref("Array.prototype.map()")}}</dt>
 <dd>返回一个由回调函数的返回值组成的新数组。</dd>
 <dt>{{jsxref("Array.prototype.reduce()")}}</dt>
 <dd>从左到右为每个数组元素执行一次回调函数，并把上次回调函数的返回值放在一个暂存器中传给下次回调函数，并返回最后一次回调函数的返回值。</dd>
 <dt>{{jsxref("Array.prototype.reduceRight()")}}</dt>
 <dd>从右到左为每个数组元素执行一次回调函数，并把上次回调函数的返回值放在一个暂存器中传给下次回调函数，并返回最后一次回调函数的返回值。</dd>
 <dt>{{jsxref("Array.prototype.values()")}} {{experimental_inline}}</dt>
 <dd>返回一个数组迭代器对象，该迭代器会包含所有数组元素的值。</dd>
 <dt>{{jsxref("Array.prototype.@@iterator()", "Array.prototype[@@iterator]()")}} {{experimental_inline}}</dt>
 <dd>和上面的 <code>values() 方法是同一个函数。</code></dd>
</dl>

<h3 id="Generic_methods" name="Generic_methods">通用方法</h3>

<p>在 JavaScript 中，很多的数组方法被故意设计成是通用的。也就是说，那些看起来像是数组的对象（类数组对象），即拥有一个 <code>length</code> 属性，以及对应的索引属性（也就是数字类型的属性，比如 <code>obj[5]</code>）的非数组对象也是可以调用那些数组方法的。其中一些数组方法，比如说 {{jsxref("Array.join", "join")}} 方法，它们只会单纯的读取当前对象的 <code>length</code> 属性和索引属性的值，并不会尝试去改变这些属性的值。而另外一些数组方法，比如说 {{jsxref("Array.reverse", "reverse")}} 方法，它们会尝试修改那些属性的值，因此，如果当前对象是个 {{jsxref("String")}} 对象，那么这些方法在执行时就会报错，因为字符串对象的 <code>length</code> 属性和索引属性都是只读的。</p>

<h2 id="Specifications" name="Specifications">规范</h2>

<table class="standard-table">
 <tbody>
  <tr>
   <th scope="col">Specification</th>
   <th scope="col">Status</th>
   <th scope="col">Comment</th>
  </tr>
  <tr>
   <td>{{SpecName('ES1')}}</td>
   <td>{{Spec2('ES1')}}</td>
   <td>Initial definition.</td>
  </tr>
  <tr>
   <td>{{SpecName('ES5.1', '#sec-15.4.3.1', 'Array.prototype')}}</td>
   <td>{{Spec2('ES5.1')}}</td>
   <td></td>
  </tr>
  <tr>
   <td>{{SpecName('ES6', '#sec-array.prototype', 'Array.prototype')}}</td>
   <td>{{Spec2('ES6')}}</td>
   <td></td>
  </tr>
 </tbody>
</table>

<h2 id="Browser_compatibility" name="Browser_compatibility">浏览器兼容性</h2>

<div>
<div>


<p>{{Compat("javascript.builtins.Array.prototype")}}</p>
</div>
</div>

<h2 id="See_also" name="See_also">相关链接</h2>

<ul>
 <li>{{jsxref("Array")}}</li>
 <li>{{jsxref("Function.prototype")}}</li>
</ul>
