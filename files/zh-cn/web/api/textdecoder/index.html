---
title: TextDecoder
slug: Web/API/TextDecoder
tags:
  - API
  - DOM
  - 参考
  - 接口
  - 编码
translation_of: Web/API/TextDecoder
---
<div>{{APIRef("Encoding API")}}</div>

<p><code><strong>TextDecoder</strong></code><font><font> 接口表示一个文本解码器，一个解码器只支持一种特定文本编码，例如 </font></font><code>utf-8</code><font><font>、</font></font><code>iso-8859-2</code><font><font>、</font></font><code>koi8</code><font><font>、</font></font><code>cp1261</code><font><font>，</font></font><code>gbk</code><font><font> 等等。</font></font>解码器将字节流作为输入，并提供代码点流作为输出<font><font>。</font></font></p>

<h2 id="例子"><font><font>例子</font></font></h2>

<h3 id="用类型化数组表示文本"><font><font>用类型化数组表示文本</font></font></h3>

<p><font><font>本示例展示如何解码中文/日语字符</font></font><img alt="" src="https://mdn.mozillademos.org/files/16663/2019-05-21_191907.png" style="height: 32px; width: 41px;"><font><font>，用五个不同的数组类型表示</font></font><font><font>：</font></font> {{jsxref("Uint8Array")}}, {{jsxref("Int8Array")}}, {{jsxref("Uint16Array")}}, {{jsxref("Int16Array")}}, {{jsxref("Int32Array")}}</p>

<pre class="brush: js; line-numbers language-js notranslate"><code class="language-js">let utf8decoder = new TextDecoder(); // default 'utf-8' or 'utf8'

let u8arr = new Uint8Array([240, 160, 174, 183]);
let i8arr = new Int8Array([-16, -96, -82, -73]);
let u16arr = new Uint16Array([41200, 47022]);
let i16arr = new Int16Array([-24336, -18514]);
let i32arr = new Int32Array([-1213292304]);

console.log(utf8decoder.decode(u8arr));
console.log(utf8decoder.decode(i8arr));
console.log(utf8decoder.decode(u16arr));
console.log(utf8decoder.decode(i16arr));
console.log(utf8decoder.decode(i32arr));</code></pre>

<h3 id="处理非UTF8文本"><font><font>处理非UTF8文本</font></font></h3>

<p><font><font>在此示例中，我们对俄语文本“Привет，мир！”(</font></font> "Hello, world."<font><font>)进行解码。</font><font>在我们的</font></font> {{domxref("TextDecoder/TextDecoder", "TextDecoder()")}} <font><font>构造函数中，我们指定Windows-1251字符编码，适用于西里尔字母。</font></font></p>

<pre class="brush: js; line-numbers language-js notranslate"><code class="language-js">let win1251decoder = new TextDecoder('windows-1251');
let bytes = new Uint8Array([207, 240, 232, 226, 229, 242, 44, 32, 236, 232, 240, 33]);
console.log(win1251decoder.decode(bytes)); // Привет, мир!</code></pre>

<h2 id="构造函数">构造函数</h2>

<dl>
 <dt>{{DOMxRef("TextDecoder.TextDecoder", "TextDecoder()")}}</dt>
 <dd><font><font>返回一个新构造的 </font></font><code>TextDecoder</code><font><font>，它使用参数中指定的解码方法生成代码点流。</font></font></dd>
</dl>

<h2 id="属性">属性</h2>

<p><em><code>TextDecoder</code><font><font> 接口不继承任何属性。</font></font></em></p>

<dl>
 <dt>{{DOMxRef("TextDecoder.prototype.encoding")}}{{ReadOnlyInline}}</dt>
 <dd><font><font>{{DOMxRef("DOMString")}}所包含的解码器的名称，表示</font></font><code>TextDecoder</code><font><font>所使用的解码方法的字符串。</font></font></dd>
 <dt><font>{{DOMxRef("TextDecoder.prototype.fatal")}}{{ReadOnlyInline}}</font></dt>
 <dd><font><font><font>布尔值，{{jsxref('Boolean')}}，是否显示致命错误。</font></font></font></dd>
 <dt><font><font><font>{{DOMxRef("TextDecoder.prototype.ignoreBOM")}} {{ReadOnlyInline}}</font></font></font></dt>
 <dd><font><font><font>布尔值，{{jsxref('Boolean')}}，是否忽略 BOM（</font></font></font>byte order marker<font><font><font>）标记。</font></font></font></dd>
</dl>

<h2 id="方法"><font><font><font>方法</font></font></font></h2>

<dl>
</dl>

<p><font><em><em><code>TextDecoder</code><font><font> 接口不继承任何</font></font></em><font><font>方法</font></font></em><font><font>。</font></font></font></p>

<dl>
 <dt><font>{{DOMxRef("TextDecoder.prototype.decode()")}}</font></dt>
 <dd><font><font><font>返回一个{{DOMxRef("DOMString")}}，其中包含使用特定 </font></font><code>TextDecoder</code><font><font> 对象</font><font>的方法解码的文本</font><font>。</font></font></font></dd>
</dl>

<h2 id="规范"><font>规范</font></h2>

<table class="standard-table">
 <tbody>
  <tr>
   <th scope="col"><font><font><font>规格</font></font></font></th>
   <th scope="col"><font><font><font>状态</font></font></font></th>
   <th scope="col"><font><font><font>评论</font></font></font></th>
  </tr>
  <tr>
   <td><font>{{SpecName("Encoding", "#interface-textdecoder", "TextDecoder")}}</font></td>
   <td><font>{{Spec2("Encoding")}}</font></td>
   <td><font><font><font>初始定义。</font></font></font></td>
  </tr>
 </tbody>
</table>

<h2 id="浏览器兼容性"><font><font><font>浏览器兼容性</font></font></font></h2>

<div>


<p><font>{{Compat("api.TextDecoder")}}</font></p>
</div>

<h2 id="相关链接"><font><font><font>相关链接</font></font></font></h2>

<ul>
 <li><font>{{DOMxRef("TextEncoder")}} <font><font>接口描述了逆操作。</font></font></font></li>
 <li><font><a href="/en-US/Add-ons/Code_snippets/StringView"><code>StringView</code></a><font><font> –基于类型数组的字符串的类似C的表示形式</font></font></font></li>
 <li><font><font><font>一个</font></font><a href="http://code.google.com/p/stringencoding/"><font><font>垫片</font></font></a><font><font>，允许在不支持它的浏览器使用这个接口。</font></font></font></li>
 <li><font><code><a href="/en-US/docs/Components.utils.importGlobalProperties">Components.utils.importGlobalProperties</a></code></font></li>
 <li><font><a href="https://nodejs.org/api/util.html#util_class_util_textdecoder"><font><font>Node.js支持从v11.0.0全局导出</font></font></a></font></li>
</ul>
