---
title: Генерирование результатов
slug: Mozilla/Tech/XUL/Руководство_по_шаблонам_XUL/Генерирование_результатов
tags:
  - Руководство_по_шаблонам_XUL
translation_of: Archive/Mozilla/XUL/Template_Guide/Result_Generation
---
<h3 id="RDF" name="RDF"> RDF </h3>
<p>В этом разделе мы рассмотрим, как генерировать контент с помощью шаблонов XUL, используя источник данных RDF. Но вначале нужно познакомиться с основополагающими принципами и идеями.
</p><p>Используя математическое определение, можно сказать, что RDF - это размеченный направленный граф. Иными словами, RDF можно представить в виде графа; граф состоит из узлов и соединён стрелками; все стрелки и узлы имеют метки. Поскольку это граф, стрелки могут указывать на какой-угодно узел, а узлы могут иметь любое количество дуг, входящих или выходящих из него. Также, поскольку это граф, не существует начального (корневого) узла, поэтому вы, в принципе, можете начать с любого из них. На следующем графике видно, что из узла A, находящегося в верхней части рисунка, выходят дуги в узлы B, C и D. Из узла C выходит дуга в узел D. Поскольку стрелки могут указывать на любой узел, дуга из узла D может входит в узел A. Для обхода всех вершин дерева можно начать с узла A и, следуя по дугам, перейти к вершинам B, C и D. Вместе с тем, можно начать с узла B, от него перейти к A, а после - к C и D. Нет никаких ограничений на то, каким образом вы будете переходить по дугам: в том направлении, в которым они указывают, или в обратном. Данный график был создан программой <a class="external" href="http://www.w3.org/RDF/Validator/">RDF validator</a>, разработанной W3C; если вы хотите проверить корректность RDF-файла, воспользуйтесь этим сервисом.
</p><p><img alt="Image:Template-guide-p2.png">
</p><p>Красным цветом выделены метки стрелок, называемые предикатами (predicates). В данном примере все стрелки имеют метки; однако так бывает далеко не всегда. Шаблоны же предоставляют способ обхода только тех дуг, которые имеют определённые метки.
Ниже представлен пример возможной сериализация данного графа RDF в формате XML, хотя возможны и другие варианты.
</p>
<pre>&lt;?xml version="1.0"?&gt;
&lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
  xmlns:rel="http://www.xulplanet.com/rdf/"&gt;

  &lt;rdf:Description rdf:about="http://www.xulplanet.com/rdf/A"&gt;
    &lt;rel:relatedItem rdf:resource="http://www.xulplanet.com/rdf/B"/&gt;
    &lt;rel:relatedItem rdf:resource="http://www.xulplanet.com/rdf/C"/&gt;
    &lt;rel:relatedItem rdf:resource="http://www.xulplanet.com/rdf/D"/&gt;
  &lt;/rdf:Description&gt;

  &lt;rdf:Description rdf:about="http://www.xulplanet.com/rdf/C"&gt;
    &lt;rel:relatedItem rdf:resource="http://www.xulplanet.com/rdf/D"/&gt;
  &lt;/rdf:Description&gt;

&lt;/rdf:RDF&gt;
</pre>
<p>Для запроса в шаблоне XUL прежде всего нужно выбрать начальный узел графа. После этого для определения дальнейшего пути обхода используется множество условий. В конечном счёте, будет получен набор узлов, называемых конечными точками. Они и являются результатами выполнения запроса; именно их использует конструктор для генерирования контента. Допустим, вы начинаете с узла A. От него вы можете перейти к вершинам B, C и D и создать, таким образом, три элемента XUL. Или же вы можете начать с узла D и возвратиться по дугам к исходным вершинам. В данном случае получим всего один результат - вершину A. Убедитесь, что в этом случае получаем лишь один результат.
</p><p>Используя терминологию шаблонов XUL, назовём начальную вершину контейнером (container) или исходной точкой, а конечную вершину назовём элементом или членом (member). Такие названия используются потому, что в наиболее общем случае удобно говорить о списке элементов или дочерних узлов, собранных в контейнере. Тем не менее, выбор контейнера или его элементов зависит от вас; любой узел может выступать в этом качестве.
</p><p>Узлы RDF идентифицируются строкой символов. В RDF можно выделить два типа узлов: ресурсы, соответствующие "сущностям", и литералы, обозначающие имена, даты, размеры и другие свойства этих сущностей. Литералом может быть имя человека, например, "Елисей" или "Гарри Поттер". Значением ресурса является URI, выбранный по вашему усмотрению; мы будем использовать значение URI в шаблонах. На приведённом графике URI ресурсов выделены синим цветом на метках узлов. Хотя в данном примере литералы не используются мы будем использовать их позже.
</p><p>С вашего позволения пусть узел A будет начальным; ему соответствует URI (<span class="nowiki">http://www.xulplanet.com/rdf/A</span>). Используя атрибут 'ref', определим начальную вершину в шаблоне. Например, так:
</p>
<pre>&lt;vbox datasources="http://www.xulplanet.com/ds/sample.rdf"
         ref="http://www.xulplanet.com/rdf/A" flex="1"&gt;
</pre>
<h3 id=".D0.9E.D0.B1.D1.80.D0.B0.D0.B1.D0.BE.D1.82.D0.BA.D0.B0_.D0.B7.D0.B0.D0.BF.D1.80.D0.BE.D1.81.D0.BE.D0.B2" name=".D0.9E.D0.B1.D1.80.D0.B0.D0.B1.D0.BE.D1.82.D0.BA.D0.B0_.D0.B7.D0.B0.D0.BF.D1.80.D0.BE.D1.81.D0.BE.D0.B2">Обработка запросов</h3>
<p>Запрос для источника данных RDF состоит из множества утверждений, оформленных как дочерние узлы элемента <code><a href="/ru/docs/Mozilla/Tech/XUL/query" title="query">query</a></code>. При обработке запроса конструктор собирает информацию о возможных результатах, расположении сгенерированого контента, и информацию о поведении в случае изменения содержимого источника данных. Эта информация сохраняется в течение всего жизненного цикла шаблона, до тех пока он не будет построен заново или разрушен. Для поиска требуемой информации конструктор шаблонов использует метод, основанный на алгоритме <a class="external" href="http://en.wikipedia.org/wiki/Rete_algorithm">RETE</a>. Это позволяет обновлять результаты эффективно при изменении структуры графа RDF. Т.е. вместо того, чтобы строить весь граф с самого начала, алгоритм позволяет добавить только некоторые его фрагменты и обновить вывод инкрементно. Схожий алгоритм используется при удалении утверждений RDF.
</p><p>Не смотря на то, что шаблон хранит множество информации для генерации корректного вывода, нас сейчас интересует информация о возможных результатах. Конструктор начинает, работу, имея всего один возможный начальный результат (seed). После он последовательно обрабатывает условия запроса. Для обработки конкретного условия необходимо рассмотреть все возможные результаты; если результат удовлетворяет условию, то он принимается, в противном случае - отвергается. Для первого условия в качестве возможного результата доступен только начальный (seed). При выполнении последующих шагов могут быть добавлены новые результаты либо иная релевантная информация. Отвергнутые результаты, естественно, будут удалены. После просмотра всех результатов для текущего условия, конструктор переходит к следующему. После обработки всех условий все оставшиеся результаты принимаются в качестве вывода. Они используются для генерации контента. Таким образом, подведём итоги:
</p>
<ol><li>Начать работу с одним возможным результатом (seed)
</li><li>Для всех уже доступных результатов с дополнительными сведениями повторить шаги
</li><li>Добавить все возможные результаты
</li><li>Удалить все отвергнутые результаты
</li><li>Повторить шаги 2-4 для всех условий запроса
</li><li>По окончанию работы все оставшиеся данные становятся выводом
</li></ol>
<p>Все возможные результаты образованы наборами пар переменная-значение. Например, результат будет выглядеть примерно так:
</p>
<pre>(?name = Елисей, ?age = 5)
</pre>
<p>Здесь имеются две переменные, ?name со значением "Елисей" и ?age со значением 5. Переменные начинаются со знака вопроса, значениями являются либо ресурсы RDF, либо литералы. В данном случае используются литералы, поскольку это более удобочитаемо. Если бы у нас было два результата, они выглядели бы примерно так:
</p>
<pre>(?name = Елисей, ?age = 5)
(?name = Забава, ?age = 12)
</pre>
<p>Это обозначение для возможных результатов используется в этом и последующих примерах.
</p><p>Если у нас будет запрос, удаляющий все результаты, относящиеся к мужчинам, то после его применения результат будет примерно следующим:
</p>
<pre>(?name = Забава, ?age = 12, ?gender = Female)
</pre>
<p>Таким образом, условие удалило Елисея из потенциальных результатов и добавило переменную ?gender для Забавы. На самом деле, это пример типичного поведения условия запроса: добавить новую переменную к результатам и отсеять те результаты, которые не удовлетворяют условию. Если данное условие было последним в списке, результат Забавы станет конечным выводом.
</p>
