---
title: Устройство расширения
slug: XUL_School/The_Essentials_of_an_Extension
translation_of: Archive/Add-ons/Overlay_Extensions/XUL_School/The_Essentials_of_an_Extension
---
<p> </p>

<div class="blockIndicator warning">
<p dir="ltr" id="docs-internal-guid-dff3a9fe-7fff-750b-9799-0456f08af0f4">Support for extensions using XUL/XPCOM or the Add-on SDK was removed in Firefox 57, released November 2017. As there is no supported version of Firefox enabling these technologies, this page will be removed by December 2020.</p>
</div>

<p> </p>

<p>{{LegacyAddonsNotice}}{{AddonSidebar}}</p>

<p>{{ PreviousNext("XUL_School/Getting_Started_with_Firefox_Extensions", "XUL_School/Setting_Up_a_Development_Environment") }}</p>

<h2 id="Файл_install.rdf">Файл install.rdf</h2>

<p>В предыдущем разделе мы начали рассматривать содержимое расширения "Hello World". Теперь мы рассмотрим его файлы и код, начиная с файла <em>"install.rdf"</em>. Вы можете его открыть любым текстовым редактором.</p>

<p>Файл подготовлен с применением специальной разновидности XML, под названием <a href="http://ru.wikipedia.org/wiki/Resource_Description_Framework" title="http://ru.wikipedia.org/wiki/Resource_Description_Framework"><span class="external">RDF</span></a>. RDF использовался как основной механизм хранения для Firefox, но сейчас заменяется упрощённой системой баз данных. Далее в учебнике мы рассмотрим обе эти системы хранения данных.</p>

<p>Теперь давайте взглянем на важные части этого файла.</p>

<div class="code panel" style="border-width: 1px;">
<div class="codeContent panelContent">
<pre class="code-java">&lt;em:id&gt;helloworld@xulschool.com&lt;/em:id&gt;</pre>
</div>
</div>

<p>Это уникальный идентификатор расширения. Firefox-у он нужен, чтобы отличать ваши расширения от других расширений, поэтому надо, чтобы у вас был уникальный ID.</p>

<p>Есть два принятых стандарта для идентификаторов дополнений. Одним из них является формат адреса электронной почты, как в примере "Hello World", в котором должно быть что-то вроде <em><span style="color: #0000ff;">&lt;название-программы&gt;@&lt;ваш-домен&gt;</span></em>. Другой обычной практикой является использование порождённой строки <a href="http://ru.wikipedia.org/wiki/UUID" title="http://ru.wikipedia.org/wiki/UUID">UUID</a>, повторение которой крайне маловероятно. В Unix-системах, в командной строке есть инструмент под названием <em>uuidgen</em>, порождающий новые UUID-строки. Для всех других платформ также есть такие загружаемые инструменты, порождающие UUID. Окружающие скобки - это просто обозначение и это обычная практика. Пока ваш идентификатор сколь-нибудь уникален, то можно выбрать любую форму.</p>

<div class="code panel" style="border-width: 1px;">
<div class="codeContent panelContent">
<pre class="code-java">&lt;em:name&gt;XUL School Hello World&lt;/em:name&gt;
&lt;em:description&gt;Welcome to XUL School!&lt;/em:description&gt;
&lt;em:version&gt;0.1&lt;/em:version&gt;
&lt;em:creator&gt;Appcoast&lt;/em:creator&gt;
<span class="code-comment">&lt;em:homepageURL&gt;https://developer.Mozilla.org/en/XUL_School&lt;/em:homepageURL&gt;</span></pre>
</div>
</div>

<p>Это данные, отображаемые до и после установки расширения и которые можно увидеть в панели управления дополнениями. Помощники и переводчики могут добавить много других тегов. Все подробности смотрите в <a href="/en/Install_Manifests" title="/en/Install_Manifests">полной спецификации</a> файла <strong>install.rdf</strong>.</p>

<p>Так как расширения могут быть переведены на несколько языков, часто необходимо перевести описание расширения или, даже, его название. Локализованные описание и название могут быть вписаны с помощью следующего кода:</p>

<div class="code panel" style="border-width: 1px;">
<div class="codeContent panelContent">
<pre class="code-java">&lt;em:localized&gt;
  &lt;Description&gt;
    &lt;em:locale&gt;ru-RU&lt;/em:locale&gt;
    &lt;em:name&gt;Школа XUL Привет мир&lt;/em:name&gt;
    &lt;em:description&gt;Добро пожаловать в школу XUL!&lt;/em:description&gt;
  &lt;/Description&gt;
&lt;/em:localized&gt;</pre>
</div>
</div>

<p>Строчка локали <em>ru-RU</em> указывает, что это русская (ru) локализация для России (RU). Вы можете добавить столько разделов &lt;<em>em:localized</em>&gt;, сколько вам нужно. Для Firefox 2, локализация этого файла <a href="/en/Localizing_extension_descriptions#Localizing_before_Gecko_1.9" title="/en/Localizing_extension_descriptions#Localizing_before_Gecko_1.9">немного сложнее</a>. Мы позже в этом разделе ещё обсудим локализацию.</p>

<div class="code panel" style="border-width: 1px;">
<div class="codeContent panelContent">
<pre class="code-java">&lt;em:type&gt;2&lt;/em:type&gt;</pre>
</div>
</div>

<p>Это указывает, что устанавливаемое добавление является расширением. Вы можете прочитать о различных возможных типах в <a href="https://developer.Mozilla.org/en/Install_Manifests#type" title="https://developer.Mozilla.org/en/Install_Manifests#type">соответствующем разделе спецификации файла install.rdf</a>.</p>

<div class="code panel" style="border-width: 1px;">
<div class="codeContent panelContent">
<pre class="code-java">&lt;em:targetApplication&gt;
  &lt;Description&gt;
    &lt;em:id&gt;{ec8030f7-c20a-464f-9b0e-13a3a9e97384}&lt;/em:id&gt;
    &lt;em:minVersion&gt;4.0&lt;/em:minVersion&gt;
    &lt;em:maxVersion&gt;10.*&lt;/em:maxVersion&gt;
  &lt;/Description&gt;
&lt;/em:targetApplication&gt;
</pre>
</div>
</div>

<p>Этот узел определяет целевое приложение и его целевые версии. В частности здесь указан интернет-обозреватель Firefox, начиная с 4-й и до 10-ых версий. Указанный UUID является уникальным идентификатором Firefox. Другие Mozilla и основанные на Mozilla приложения, такие как Thunderbird и Seamonkey имеют свои собственные UUID. У вас может быть расширение, работающее в нескольких приложениях и версиях.  Например, если вы создаёте расширение к Firefox, то, как правило, достаточно минимума усилий, чтобы перенести его в SeaMonkey, имеющее сходные характеристики и пользовательский интерфейс.</p>

<p>Минимум и максимум определяют диапазон версий, дозволительный для установки расширения. Вот ещё <a href="/en/Toolkit_version_format" title="/en/Toolkit_version_format">ссылка о формате указания версий</a>. Если приложение или диапазон версий не совпадают, то пользователю не будет разрешено установить расширение или расширение будет установлено в отключённом состоянии. Пользователи могут отключить проверку версий в настройках интернет-обозревателя или путём установки дополнений через <a href="https://addons.Mozilla.org/en-US/Firefox/addon/15003" title="https://addons.Mozilla.org/en-US/Firefox/addon/15003">Докладчик о совместимости дополнений (Add-on Compatibility Reporter)</a>. Начиная с Firefox 11, дополнения по умолчанию будут совместимы, и Firefox в основном будет игнорировать диапазон версий. Всё-же рекомендуется всегда проверять дополнения с каждой новой версией Firefox.</p>

<p>Это информация, нужная Firefox и другим приложениям Mozilla для установки дополнения. Любые ошибки или отсутствие информации приведут к сбою процесса установки или установке расширения в выключённом состоянии.</p>

<h2 id="Файл_chrome.manifest">Файл chrome.manifest</h2>

<blockquote>
<p><span style="color: #0000ff;">Хром (Chrome) - это набор элементов пользовательского интерфейса окна приложения, находящихся за пределами области содержимого окна.</span> Панели инструментов, строки меню, индикаторы прогресса выполнения и заголовки окон - всё это примеры элементов, обычно являющихся частью Хрома.</p>
</blockquote>

<p>Взято из <a href="/en/Chrome_Registration" title="en/Chrome Registration">Регистрации Хрома</a>.</p>

<p>В двух словах, хром - это всё, что вы видите в Firefox. Все окна Firefox можно рассматривать как состоящие из двух частей: (1) хром, (2) область возможного содержимого (то, что показывают веб-страницы во вкладках Firefox). Такие окна как "окно загрузок" - это чистый Хром.  Большая часть кода расширения находится в папке "хром", как и в примере "Hello World".</p>

<p>Как мы видели в структуре каталогов распакованного расширения, Хром состоит из 3 разделов: <span style="color: #0000ff;">content (содержание)</span>, <span style="color: #0000ff;">locale (локаль, язык)</span> и <span style="color: #0000ff;">skin (тема)</span>. Эта троица необходима для большинства расширений. Если мы откроем файл <em>chrome.manifest</em> (опять же, сгодится любой текстовый редактор), то увидим, что указаны эти 3 секции:</p>

<div class="code panel" style="border-width: 1px;">
<div class="codeContent panelContent">
<pre class="code-java">content   xulschoolhello              content/
skin      xulschoolhello  classic/1.0 skin/
locale    xulschoolhello  en-US       locale/en-US/
</pre>
</div>
</div>

<p><span style="color: #0000ff;">Файл <em>chrome.manifest</em> говорит Firefox, где искать файлы Хрома.</span> Текст расположен вразрядку, чтобы выглядел как таблица, но это не обязательно. Синтаксический анализатор (парсер, parser) игнорирует повторение пробелов.</p>

<p>Первое слово в строке говорит Firefox, что именно объявляется (содержание, скин, локаль языка или другое, о чём будет рассказано позже).  Второе - это название пакета, о котором мы скоро расскажем.</p>

<p>У скина и языков есть третье значение для указания, какой именно язык или какой именно скин они расширяют. Может быть несколько скинов и языков, касающихся различных других скинов и языков. Обычно указывают одну запись для глобального скина (<em>classic/1.0</em>) и несколько записей для языковых пакетов, по одному для каждого перевода. Наконец, последним указано расположение в файловой системе.</p>

<p>В файл <em>chrome.manifest</em> могут быть внесены некоторые дополнительные параметры. Они описаны на <a href="/en/Chrome_Registration" title="/en/Chrome_Registration">странице Регистрации Chrome</a>. Примечательно, мы может включить записи, особенные для операционных систем. Это важно, потому что внешний вид браузера отличается в разных операционных системах., Если наше расширение должно выглядеть по-разному в разных ОС, то мы можем изменить файл манифеста, например, таким образом:</p>

<div class="code panel" style="border-width: 1px;">
<div class="codeContent panelContent">
<pre class="code-java">content   xulschoolhello              content/
skin      xulschoolhello  classic/1.0 skin/unix/
skin      xulschoolhello  classic/1.0 skin/mac/ os=Darwin
skin      xulschoolhello  classic/1.0 skin/win/ os=WinNT
locale    xulschoolhello  en-US       locale/en-US/
</pre>
</div>
</div>

<p>Так, мы можем задать отдельные темы оформления для Windows, Mac OS X, и Linux (а также других Unix-систем), каждая из которых определена в отдельный каталог. Так как большинство других систем на основе Unix, то тема "Unix" указывается по умолчанию, без флагов.</p>

<h2 id="Хром">Хром</h2>

<p>Как сказано выше, Хром состоит из 3 разделов: содержание (контент), язык (локаль) и тема (скин). <em>Содержание </em>- это важнейший раздел, содержащий в себе пользовательский интерфейс (XUL) и скрипты (JS - JavaScript). Раздел <em>Скин </em>содержит файлы, определяющие большую часть внешнего вида пользовательского интерфейса (с помощью CSS и изображений, как у веб-страниц). Раздел <em>Язык</em> содержит все тексты, используемые в расширении, в DTD и в файлах свойств. Такое разделение позволяет другим разработчикам создавать темы, заменяющие скины, а переводчикам - создавать локализации на разных языках. И всё это - без необходимости изменения кода вашего расширения. Это даёт расширениям Firefox хорошую гибкость.</p>

<p>Файлы Хрома доступны через <code>chrome</code>-протокол. Пример того, как выглядят URI Хрома:</p>

<div class="code panel" style="border-width: 1px;">
<div class="codeContent panelContent">
<pre class="code-java">chrome:<span class="code-comment">//packagename/section/path/to/file</span></pre>
</div>
</div>

<p>Так, например, если бы надо было получить доступ к файлу <em><strong>browserOverlay.xul</strong></em> в расширении, Хром-URI был бы:</p>

<div class="code panel" style="border-width: 1px;">
<div class="codeContent panelContent">
<pre class="code-java">c<span class="external">hrome://xulschoolhello/content/browserOverlay.xul</span></pre>
</div>
</div>

<p>Если у вас слишком много файлов в Содержании, и вы хотите организовать их в подкаталогах, не нужно ничего менять в <strong><em>chrome.manifest</em></strong>, а нужно, лишь добавить в URI правильный путь после <em><strong>content</strong></em>.</p>

<p>Адресация к файлам Скина и Языка работает точно также, и вам не нужно указывать названий Скина или Языка. Так что, для получения доступа к файлу DTD в расширении "Привет мир", <code>chrome</code>-путь выглядит так: <code><em>chrome://xulschoolhello/locale/browserOverlay.dtd</em>. </code>Firefox сам знает какой язык нужно искать.</p>

<p>Вот интересный эксперимент.  Откройте новую вкладку Firefox, вбейте в адресной строке: <em><code>chrome://mozapps/content/downloads/downloads.xul</code></em> и нажмите клавишу Enter. Удивлены? Вы только что открыли окно загрузок во вкладке Firefox! Вы можете получить доступ к любому файлу Хрома, просто введя его URI в адресной строке. Это может пригодиться, если вы захотите проверить файлы скриптов, являющихся частью Firefox, в своих или других расширениях. Большинство этих файлов открываются как текстовые, за исключением файлов XUL, которые выполняются и отображаются точно так как вы обычно видите их в окне.</p>

<h3 id="Content_(Содержание)">Content (Содержание)</h3>

<p>В каталоге "content" есть 2 файла. Давайте сначала посмотрим на файл XUL.</p>

<p><a href="/en/XUL" title="/en/XUL">XUL</a> файлы - это XML-файлы, определяющие элементы пользовательского интерфейса в Firefox и его расширениях. Создание XUL был вдохновлено языком HTML, так что вы увидите много общего между ними. Однако, XUL по сравнению с HTML улучшен - в нём исправлены ошибки, допущенные в ходе эволюции HTML. XUL позволяет создавать интерфейсы намного богаче и интерактивнее, чем те, что можно создать с помощью HTML. Или, по крайней мере, XUL облегчает работу.</p>

<p>Файлы XUL обычно определяют одно из двух: окна или наложения (оверлейные программы, накладки, слои). В файле <strong><em>downloads.xul</em></strong>, который вы до этого открывали, был код, определявший окно загрузок (Downloads). Файл XUL включён в расширение Hello World в качестве наложения. Наложение расширяет существующие окна, заменяя некоторые их элементы или добавляя новые. Строка, которую мы пропустили в файле <strong><em>chrome.manifest</em></strong> говорится, что этот файл XUL - наложение к главному окну интернет-обозревателя:</p>

<div class="code panel" style="border-width: 1px;">
<div class="codeContent panelContent">
<pre class="code-java">overlay chrome:<span class="code-comment">//browser/content/browser.xul  chrome://xulschoolhello/content/browserOverlay.xul</span></pre>
</div>
</div>

<p>С помощью этой строки, Firefox, узнаёт, что ему надо взять содержание <strong><em>browserOverlay.xul</em></strong> и наложить его на главное окно браузера - <strong><em>browser.xul</em></strong>. Вы можете объявлять наложения для любого окна или диалогового окна в Firefox, но наложение на основное окно браузера - самый распространённый случай на сегодняшний день.</p>

<p>Теперь давайте посмотрим на содержимое нашего файла XUL. Мы пропустим первые несколько строк, потому что они связаны с Темой и Языком, и мы их рассмотрим позже.</p>

<div class="code panel" style="border-width: 1px;">
<div class="codeContent panelContent">
<pre class="code-java">&lt;overlay id="xulschoolhello-browser-overlay"
  xmlns="http://www.Mozilla.org/keymaster/gatekeeper/there.is.only.xul"&gt;</pre>
</div>
</div>

<p>Ключевой элемент в файле - наложение (оверлей) - <em>overlay</em>. Другие документы XUL используют тег <em>window</em> (окно) или <em>dialog</em> (диалог). У этого элемента есть уникальный идентификатор (id), который вы должны иметь в большинстве элементов в вашем XUL. Второй атрибут - это пространство имён, которое является тем, что вы всегда должны определять в корневом элементе своего XUL. Он говорит, что этот узел и все дочерние узлы являются XUL. Когда вы в одном документе смешиваете разные типы содержания, такие как XUL с HTML или SVG, вам надо только изменить объявления пространства имён.</p>

<div class="panel" style="border-width: 1px;">
<div class="panelContent">
<div class="note">Вы могли заметить, что мы используем именование в нескольких местах, таких как идентификатор <strong><em>xulschoolhello-browser-overlay</em></strong>. Это стандартные пространства имён, которые мы используем, чтобы избежать конфликтов с Firefox и другими расширениями, а также упростить некоторые задачи разработки. Мы задаём пространство имён для всех идентификаторов и классов стилей в элементах этого наложения, потому что они будут смешаны с другими элементами в главном окне интернет-обозревателя. Если бы мы использовали общие идентификаторы, как <strong>container</strong> (<em>"контейнер"</em>) или <strong>input</strong> (<em>"ввод"</em>), то они, скорее всего, конфликтовали бы с идентификаторами использующимися в Firefox, или идентификаторами из других наложений расширений. Использование пространства имён позволяет минимизировать проблемы совместимости с другими расширениями. Мы используем <a href="http://ru.wikipedia.org/wiki/CamelCase" title="http://ru.wikipedia.org/wiki/CamelCase">ВерблюжийРегистр (CamelCase)</a> для имён файлов, и пишем всё в нижнем регистре с тире для элементов идентификаторов и для имён класса стиля CSS, но вы можете использовать свою собственную систему.</div>
</div>
</div>

<div class="code panel" style="border-width: 1px;">
<div class="codeContent panelContent">
<pre class="code-java">&lt;script type=<span class="code-quote">"application/x-javascript"</span>
  src=<span class="code-quote">"chrome:<span class="code-comment">//xulschoolhello/content/browserOverlay.js"</span> /&gt;</span></pre>
</div>
</div>

<p>Как и в HTML, он включает в себя файл сценария на языке JavaScript. Вы можете вставить столько элементов <strong><em>script</em></strong> (сценарий) в документ XUL, сколько вам нужно. Мы позже рассмотрим его код.</p>

<div class="panel" style="border-width: 1px;">
<div class="panelContent">
<div class="note">Возможно вы заметили как сформатирован наш код, и удивились правилам, которым мы следуем. Наше главное правило - длина строки не более 80 символов. Это кажется чрезмерно строгим, особенно с XML-файлами, но это число было выбрано, чтобы позволить почти любому текстовому редактору легко обрабатывать эти файлы. Даже старые редакторы для командной строки работают с файлами, в которых строки сокращены до 80 символов. Табуляция проста: 2 пробельных отступа. Мы никогда не используем настоящие символы табуляции, за исключением файлов <strong><em>Makefile</em></strong>, которые будут рассмотрены позже. Большинство наших стандартов кодирования основаны на стандартах Mozilla или других известных и используемых стандартах.</div>
</div>
</div>

<p>Мы пропустим код, который рассматривается в разделе Языка (локали), перейдя к наиболее важной части содержания:</p>

<div class="code panel" style="border-width: 1px;">
<div class="codeContent panelContent">
<pre class="code-java">&lt;menubar id="main-menubar"&gt;
  &lt;menu id="xulschoolhello-hello-menu" label="&amp;xulschoolhello.hello.label;"
    accesskey="&amp;xulschoolhello.helloMenu.accesskey;" insertafter="helpMenu"&gt;
    &lt;menupopup&gt;
      &lt;menuitem id="xulschoolhello-hello-menu-item"
        label="&amp;xulschoolhello.hello.label;"
        accesskey="&amp;xulschoolhello.helloItem.accesskey;"
        oncommand="XULSchoolChrome.BrowserOverlay.sayHello(event);" /&gt;
    &lt;/menupopup&gt;
  &lt;/menu&gt;
&lt;/menubar&gt;

&lt;vbox id="appmenuSecondaryPane"&gt;
  &lt;menu id="xulschoolhello-hello-menu-2" label="&amp;xulschoolhello.hello.label;"
    accesskey="&amp;xulschoolhello.helloMenu.accesskey;"
    insertafter="appmenu_addons"&gt;
    &lt;menupopup&gt;
      &lt;menuitem id="xulschoolhello-hello-menu-item-2"
        label="&amp;xulschoolhello.hello.label;"
        accesskey="&amp;xulschoolhello.helloItem.accesskey;"
        oncommand="XULSchoolChrome.BrowserOverlay.sayHello(event);" /&gt;
    &lt;/menupopup&gt;
  &lt;/menu&gt;
&lt;/vbox&gt;
</pre>
</div>
</div>

<p>Это код, добавляющий меню "Привет, Мир!" в окно интернет-обозревателя. Тут два почти одинаковых блока кода из-за того, как Firefox сейчас обрабатывает меню. Раньше было так, что на всех платформах была панель с обширным меню. Это изменилось в последней версии Firefox, в частности, в Windows, где видна одна кнопка Firefox, с единым и упрощённым меню опций. Нажатие на кнопку ALT в Windows переключает между кнопкой меню и классическим меню.  Второй блок кода применяется в случае, кнопки меню, а первый блок кода охватывает все остальные случаи. Так как кнопка меню теперь наиболее распространена, мы сосредоточимся на ней.</p>

<p>Для того, чтобы написать этот код, нам нужны некоторые знания кода XUL в файле <strong><em>browser.xul</em></strong>. Нам нужно знать, что идентификатор (id) правой панели в едином меню - это <strong><em>appmenuSecondaryPane</em></strong>.  Мы добавляем собственное меню, и говорим Firefox, добавить его в ту панель, сразу после  пункта "Add-ons" ("Дополнения"). Пример:</p>

<div class="code panel" style="border-width: 1px;">
<div class="codeContent panelContent">
<pre class="code-java">insertafter=<span class="code-quote">"appmenu_addons"</span>
</pre>
</div>
</div>

<p><strong><em>appmenu_addons</em></strong> -  это идентификатор (id) элемента меню, который соответствует пункту "Дополнения" ("Add-ons") в главном меню. Позже мы увидим, как можно узнать такие штуки, типа идентификаторов элементов браузера, но сейчас давайте посмотрим на те элементы, которые составляют меню "Hello World".</p>

<p>Для классического меню мы добавили меню "Привет мир" прямо в "корень" этого меню, так, чтоб вам было легче его заметить, но так поступать не рекомендуется. Представьте себе, что все расширения станут добавлять пункты меню в главное меню; тогда при установке нескольких расширений этот подход сделает его похожим на приборную панель самолёта, полную ручек и переключателей. В случае единого меню, всё немного сложнее в связи с отсутствием вариантов., Если пункт меню помещается в раздел "Web Developer" ("Веб-разработчик"), то рекомендуется добавить его туда. В противном случае, "Главное меню" может быть единственным выходом.</p>

<p>Одно рекомендуемое место для пунктов меню в классической нише меню - под меню "Инструменты" ("Tools"), так что на самом деле код должен выглядеть так:</p>

<div class="code panel" style="border-width: 1px;">
<div class="codeContent panelContent">
<pre class="code-java">&lt;menupopup id=<span class="code-quote">"menu_ToolsPopup"</span>&gt;
  &lt;menu id=<span class="code-quote">"xulschoolhello-hello-menu"</span> label=<span class="code-quote">"&amp;</span><span class="code-quote">xulschoolhello</span><span class="code-quote">.hello.label;"</span>
    accesskey=<span class="code-quote">"&amp;</span><span class="code-quote">xulschoolhello</span><span class="code-quote">.helloMenu.accesskey;"</span>
    insertbefore=<span class="code-quote">"</span>devToolsEndSeparator<span class="code-quote">"</span>&gt;
    &lt;menupopup&gt;
      &lt;menuitem id=<span class="code-quote">"</span><span class="code-quote">xulschoolhello</span><span class="code-quote">-hello-menu-item"
      </span>  label=<span class="code-quote">"&amp;</span><span class="code-quote">xulschoolhello</span><span class="code-quote">.hello.label;"</span>
        accesskey=<span class="code-quote">"&amp;</span><span class="code-quote">xulschoolhello</span><span class="code-quote">.helloItem.accesskey;"</span>
        oncommand=<span class="code-quote">"XULSchoolChrome.BrowserOverlay.sayHello(event);"</span> /&gt;
    &lt;/menupopup&gt;
  &lt;/menu&gt;
&lt;/menupopup&gt;
</pre>
</div>
</div>

<p>Мы накладываем меню, которое глубже в дереве XUL, но это не важно, потому что всё, что нам нужно - это идентификатор (id) элемента, на который мы хотим наложить свой код. В данном случае это элемент <strong><a href="/en/XUL/menupopup" title="/en/XUL/menupopup">menupopup</a></strong>, находящийся внутри элемента "Инструменты" (<strong>"Tools"</strong>) в <a href="/en/XUL/menu" title="/en/XUL/menu">menu</a> ("меню"). Атрибут <strong><em>"InsertBefore"</em></strong> диктует Firefox добавить меню в нижнюю часть раздела инструментов разработчика, над его конечным разделителем. Далее в учебнике мы поговорим о меню подробнее.</p>

<p>Теперь давайте посмотрим на действительный код:</p>

<div class="code panel" style="border-width: 1px;">
<div class="codeContent panelContent">
<pre class="code-java">oncommand=<span class="code-quote">"XULSchoolChrome.BrowserOverlay.sayHello(event);"</span>
</pre>
</div>
</div>

<p>Этот атрибут определяет обработчик события. Команда <strong><em>"event"</em></strong> (<em>"событие"</em>) - наиболее часто используется в Firefox, так как она соответствует главному действию для большинства элементов пользовательского интерфейса. значение этого атрибута - код на JavaScript, вызывающий функцию. Эта функция определена в JS-файле, включенном ранее тегом <strong><em>"script"</em></strong>. JS-функция будет вызвана, когда пользователь нажмёт на пункт меню <strong><em>"Привет Мир"</em></strong> (<em>"Hello World"</em>). Все обработчики событий, назначают специальный объект под названием <strong><em>"event"</em></strong> (<em>"событие"</em>), который обычно передаётся в качестве аргумента функции. Более подробно обработчики событий описаны ниже.</p>

<p>Теперь давайте взглянем на файл JavaScript и посмотрим, что происходит, когда срабатывает событие.</p>

<div class="code panel" style="border-width: 1px;">
<div class="codeContent panelContent">
<pre class="brush: js">/**
 * XULSchoolChrome namespace.
 */
if ("undefined" == typeof(XULSchoolChrome)) {
  var XULSchoolChrome = {};
};</pre>
</div>
</div>

<p>Определяется пространство имён <strong><em>"XULSchoolChrome"</em></strong>. Все объекты и переменные, которые мы определяем в этом JavaScript носят всеобъемлющий характер, это означает, что скрипты в Firefox и других расширениях могут увидеть их и взаимодействовать с ними. Это также значит, что, если мы определим объект под названием <strong><em>"MenuHandler"</em></strong> (<em>"ОбработчикСобытияМеню"</em>) или с иным типичным названием, то он, скорее всего, будет конфликтовать с существующим объектом. Так что, нам остаётся здесь сделать - это определить единый всеобъемлющий объект: <strong><em>"XULSchoolChrome"</em></strong>. Теперь мы знаем, что все наши объекты находятся внутри этого объекта, который вряд ли будет продублирован или переписан другими расширениями.</p>

<p>Вы можете прочитать больше об <a href="/en/JavaScript/Reference/Operators/typeof" title="/en/JavaScript/Reference/Operators/typeof">операторе "typeof"</a>. Если вы не знакомы с JavaScript или с этим синтаксисом, то вам будет интересно узнать, что инициализация объекта сочетанием фигурных скобок <strong><em>"{}"</em></strong> эквивалентна его инициализации строкой <strong><em>"new Object()"</em></strong>.</p>

<div class="code panel" style="border-width: 1px;">
<div class="codeContent panelContent">
<pre class="brush: js">/**
 * Controls the browser overlay <span class="code-keyword">for</span> the Hello World extension.
 */
XULSchoolChrome.BrowserOverlay = {</pre>
</div>
</div>

<p>Наконец, <strong><em>BrowserOverlay</em></strong> - это наш объект. Именование и обращение к объектам таким длинным и подробным образом могут показаться поначалу некомфортными, но это оправдано.</p>

<div class="panel" style="border-width: 1px;">
<div class="panelContent">
<div class="note">Мы используем стиль описания <a href="http://java.sun.com/j2se/javadoc/writingdoccomments/index.html" title="http://java.sun.com/j2se/javadoc/writingdoccomments/index.html">Javadoc</a> во всех пространствах имён, объектах, а также членах объекта. Это такой же стандарт, как используется в коде Mozilla и некоторых инструментах, могущих автоматически порождать документацию из Javadoc.</div>
</div>
</div>

<div class="code panel" style="border-width: 1px;">
<div class="codeContent panelContent">
<pre class="brush: js">sayHello : function(aEvent) {
  let stringBundle = document.getElementById("xulschoolhello-string-bundle");
  let message = stringBundle.getString("xulschoolhello.greeting.label");

  window.alert(message);
}</pre>
</div>
</div>

<p>Объявление нашей функции. Три строки кода - это всё, что нужно для её работы. Первая строка в теле функции объявляет переменную <strong><em>"stringBundle"</em></strong>, которая будет содержать элемент <strong><a href="/en/XUL/stringbundle" title="/en/XUL/stringbundle">stringbundle</a></strong>, определённый в наложении. Переменная объявляется с помощью оператора <strong><em>"let"</em></strong> ("пусть"), похожего на <strong><em>var</em></strong>, но с более ограниченной областью. <a href="/en/JavaScript/Reference/Statements/let" title="/en/JavaScript/Reference/Statements/let">здесь</a> вы можете подробнее прочитать об <strong>объявлении let</strong>.</p>

<p>Для управления документом XUL, как и в обычном JS, мы можем использовать <a href="/en/DOM" title="/en/DOM"><strong>DOM</strong> <em>(Document Object Model)</em></a>. Сначала мы получаем ссылку на <strong><em><a href="/en/XUL/stringbundle" title="/en/XUL/stringbundle">элемент stringbundle</a></em></strong> в документе. Это специальный элемент, позволяющий динамически получать переведённые на нужный язык (локализованные) строки по предоставлении ему лишь "ключа", идентифицирующего текст. Это как-раз то, что мы делаем во второй строке кода. Мы вызываем <strong><em><a href="/en/XUL/stringbundle#m-getString" title="/en/XUL/stringbundle#m-getString">метод getString</a></em></strong> элемента связки и получаем переведённое на нужный язык сообщение для показа. Затем мы вызываем функцию <a href="/en/DOM/window.alert" title="/en/DOM/window.alert"><strong><em>"window.alert"</em></strong></a> с сообщением - так же, как мы могли бы это сделать в HTML-документе.</p>

<h3 id="Локаль">Локаль</h3>

<p>Есть два типа файлов перевода интерфейса (далее - локализации, на правах устоявшегося термина) на нужные языки: DTD и свойства. В этом примере мы используем оба типа. DTD - наиболее эффективный способ показа текста в XUL, поэтому вы должны по возможности использовать именно его. Он весьма негибкий и поэтому он не может быть использован для динамически создаваемого текста, поэтому нужен альтернативный способ получения локализованных строк.</p>

<p>Оглядываясь на код меню, вы, вероятно, заметили, некоторые атрибуты, вроде этих:</p>

<div class="code panel" style="border-width: 1px;">
<div class="codeContent panelContent">
<pre class="code-java">label=<span class="code-quote">"&amp;xulschoolhello.hello.label;"</span> accesskey=<span class="code-quote">"&amp;xulschoolhello.helloItem.accesskey;"</span></pre>
</div>
</div>

<p>Эти атрибуты определяют текст, который вы видите в меню, и они являются строковыми ключами, определёнными в нашем DTD файле <strong><em>"browserOverlay.dtd"</em></strong>. Файл DTD был вовлечён в файле XUL таким кодом:</p>

<div class="code panel" style="border-width: 1px;">
<div class="codeContent panelContent">
<pre class="code-java">&lt;!DOCTYPE overlay SYSTEM "chrome://xulschoolhello/locale/browserOverlay.dtd" &gt;</pre>
</div>
</div>

<p>И в файле DTD можно увидеть связь между ключами и локализованными строками:</p>

<div class="code panel" style="border-width: 1px;">
<div class="codeContent panelContent">
<pre class="code-java">&lt;!ENTITY xulschoolhello.hello.label            <span class="code-quote">"Hello World!"</span>&gt;
&lt;!ENTITY xulschoolhello.helloMenu.accesskey    <span class="code-quote">"l"</span>&gt;
&lt;!ENTITY xulschoolhello.helloItem.accesskey    <span class="code-quote">"H"</span>&gt;</pre>
</div>
</div>

<p>Обратите внимание, что в файле XUL вы накладываете строковый ключ между амперсандом "<span style="color: #0000ff;"><strong>&amp;</strong></span>" и точкой с запятой "<span style="color: #0000ff;"><strong>;</strong></span>", в то время как в файле DTD вы только указываете ключ. Вы можете получить непредсказуемые ошибки синтаксического разбора (парсинга) или неправильную локализацию, если не укажете это правильно.</p>

<p>Клавиши быстрого доступа (также известны как "горячие клавиши". прим. пер.) - это ссылки, позволяющие вам быстро перемещаться по меню, используя только клавиатуру. Они также являются единственным способом навигации по меню для людей с ограниченными возможностями, такими, как частичная или полная слепота, или физическими недостатками, с которыми трудно или невозможно пользоваться мышью. Вы можете легко узнать горячую клавишу быстрого доступа в Windows, так как буква, соответствующая горячей клавише указывается, как на рисунке ниже (буква подчеркнута):</p>

<div>
<p><img alt="" class="internal" src="https://developer.mozilla.org/@api/deki/files/4226/=accesskeys.png" style="height: 58px; width: 167px;"></p>
</div>

<p>У большинства средств управления пользовательским интерфейсом есть атрибут <strong><em>"accesskey"</em></strong> ("клавиша быстрого доступа"), и его надо использовать. Значение клавиши доступа локализовано - привязано к языковому набору, потому что оно должно соответствовать букве в тексте названия пункта меню. Вам надо также делать всё возможное, чтобы избежать повторения горячей клавиши. Например, они не должны повторяться в пределах меню или подменю. В окне нужно особенно осторожно выбирать клавиши доступа, потому что там обычно ещё больше других средств управления. И особенно внимательно выбирайте клавиши доступа для наложения (Overlay). В нашем случае (в английской версии - прим. пер.) мы не можем использовать английскую букву "H" в качестве горячей клавиши в главном пункте меню, потому что это было бы то же самое как клавиша доступа в Меню "Help" ("помощь"). То же самое с буквой "W" и меню "Window" ("Окно") в Операционной системе "Mac OS". Так что мы остановились на букве "l".</p>

<p>Значения для строк DTD проставляются тогда, когда документ загружается. Если вы запросите значение атрибута <strong><em>"label"</em></strong> у меню "Привет мир!", используя DOM, то вы получите локализованную строку, а не строку ключа. Вы не можете динамически изменять значение атрибута с новым DTD ключом, но можете установить новое значение:</p>

<div class="code panel" style="border-width: 1px;">
<div class="codeContent panelContent">
<pre class="brush: js">let helloItem = document.getElementById(<span class="code-quote">"xulschoolhello-hello-menu-item"</span>);

<span class="code-comment">// The alert will say <span class="code-quote">"Hello World!"</span>
</span>alert(helloItem.getAttribute(<span class="code-quote">"label"</span>));
<span class="code-comment">// Wrong
</span>helloItem.setAttribute(<span class="code-quote">"label"</span>, <span class="code-quote">"&amp;</span><span class="code-quote">xulschoolhello</span><span class="code-quote">.hello2.label;"</span>);
<span class="code-comment">// Better
</span>helloItem.setAttribute(<span class="code-quote">"label"</span>, <span class="code-quote">"Alternate message"</span>);
<span class="code-comment">// Right!
</span>helloItem.setAttribute(<span class="code-quote">"label"</span>, someStringBundle.getString(<span class="code-quote">"</span><span class="code-quote">xulschoolhello</span><span class="code-quote">.hello2.label"</span>));</pre>
</div>
</div>

<p>По этой причине строки DTD - не универсальное решение на все случаи локализации, и по этой причине часто нам нужно включать связки строк в файлы XUL:</p>

<div class="code panel" style="border-width: 1px;">
<div class="codeContent panelContent">
<pre class="code-java">&lt;stringbundleset id="stringbundleset"&gt;
  &lt;stringbundle id="xulschoolhello-string-bundle"
    src="chrome://xulschoolhello/locale/browserOverlay.properties" /&gt;
&lt;/stringbundleset&gt;</pre>
</div>
</div>

<p>Элемент <strong><em><a href="/en/XUL/stringbundleset" title="/en/XUL/stringbundleset">"stringbundleset"</a></em></strong> (<em>"строкСвязкаНабор"</em>) - это просто вместилище для элементов <strong><em><a href="/en/XUL/stringbundle" title="/en/XUL/stringbundle">"stringbundle"</a></em></strong> (строкСвязка). В документе должна быть только одна причина, по которой мы накладываем <strong><em>"stringbundleset"</em></strong>, находящийся в <strong><em>"browser.xul"</em></strong>, отсюда очень общий идентификатор (<strong><em>"id"</em></strong>). Мы не включили атрибуты <strong><em>"insertbefore"</em></strong> ("вставитьПеред") или <strong><em>"insertafter"</em></strong> ("вставитьПосле"), потому что порядок следования связок строк не имеет значения. Элемент абсолютно невидим. Если вы не включите ни одного из атрибутов, задающих очерёдность в элементе накладки, то Firefox просто приложит ваш элемент в качестве последнего потомка родительского элемента.</p>

<p>Всё, что нужно для "связки строк" (string bundle) - это идентификатор (чтобы иметь возможность получить элемент позже) и <code>chrome</code>-путь к файлу свойств. И, конечно, нужен сам файл свойств:</p>

<div class="code panel" style="border-width: 1px;">
<div class="codeContent panelContent">
<pre class="code-java">xulshoolhello.greeting.label = Hi! How are you?</pre>
</div>
</div>

<p>Пробелы около знака равенства игнорируются. Так же, как в <strong><em>install.rdf</em></strong>, комментарии могут быть добавлены с помощью символа "<span style="color: #0000ff;"><strong>#</strong></span>" в начале строки с комментарием.  Пустые строки тоже игнорируются.</p>

<p>Вам пригодится уметь включать динамическое содержание как часть локализованных (переведённых на язык пользователя) строк. например, когда вы захотите информировать пользователя о некотором состоянии, связанном с расширением.  Например: "Найдено 5 слов по поисковому запросу". Первой мыслью, вероятно, будет просто объединять строки, и держать отдельно свойство "Найдено" и отдельно свойство "слов по ...".  Это плохая идея.  Это значительно усложняет работу переводчиков ("локализаторов"), кроме того, в разных языках правила грамматики могут полностью менять порядок слов в предложении. Поэтому в свойствах лучше использовать параметры:</p>

<div class="code panel" style="border-width: 1px;">
<div class="codeContent panelContent">
<pre class="code-java">xulshoolhello.search.label = Found %S words matching the search query!</pre>
</div>
</div>

<p>Затем используйте <strong><em><a href="/en/XUL/stringbundle#m-getFormattedString" title="/en/XUL/stringbundle#m-getFormattedString">"getFormattedString"</a></em></strong> вместо <span id="cke_bm_225S" style="display: none;"> </span><strong><em>"getString"</em></strong><span id="cke_bm_225E" style="display: none;"> </span>, чтобы получить локализованную строку. Благодаря этому нам не нужно держать несколько свойств, и это облегчает жизнь переводчикам. Вы можете прочитать больше об этом в <strong><em><a href="/en/XUL_Tutorial/Property_Files#Text_Formatting" title="/en/XUL_Tutorial/Property_Files#Text_Formatting">разделе "Форматирование текста"</a></em></strong><span id="cke_bm_226E" style="display: none;"> </span> в Учебнике XUL ("XUL Tutorial"). Также обратите внимание на <strong><em><a href="/en/Localization_and_Plurals" title="/en/Localization_and_Plurals">статью "Множественное число и локализация"</a></em></strong>, охватывающую функцию "локализации" в Firefox, которая позволит дополнительно уточнить этот последний пример для обработки различных типов формы множественного числа, также зависящих от языков.</p>

<h3 id="Тема_(скин)">Тема (скин)</h3>

<p>Отделка (styling. создание дизайна, стилизация) XUL очень похожа на отделку HTML. Мы рассмотрим некоторые различия, когда мы коснёмся коробочной модели XUL-а (XUL Box Model), и других более сложных тем. Есть не так много стилей, которые вы можете сделать для минимального меню и простейшего аварийного предупреждения (alert message), так что расширение "Привет, мир!" только включает пустой файл CSS и обязательный глобальный файл Скина:</p>

<div class="code panel" style="border-width: 1px;">
<div class="codeContent panelContent">
<pre class="code-java">&lt;?xml-stylesheet type=<span class="code-quote">"text/css"</span> href=<span class="code-quote">"chrome:<span class="code-comment">//global/skin/"</span>?&gt;
</span>&lt;?xml-stylesheet type=<span class="code-quote">"text/css"</span>
  href=<span class="code-quote">"chrome:<span class="code-comment">//xulschoolhello/skin/browserOverlay.css"</span>?&gt;</span></pre>
</div>
</div>

<p>Файл CSS всеобщей темы содержит стили по умолчанию для всех элементов XUL и окон. Когда забывают вовлечь этот файл в окно XUL, то обычно это приводит к интересным и часто к нежелательным результатам. В нашем случае нам действительно не нужно его вовлекать, так как мы накладываем основной файл XUL нашего браузера, а этот файл уже вовлекает в себя эту всеобщую таблицу стилей CSS. Вообще, лучше бы его всегда вовлекать. Так труднее сделать ошибку, не включив его. Если вам интересно, вы можете ввести <code>chrome</code>-путь в адресную строку и посмотреть файл.</p>

<p>Мы коснулись всех файлов в расширении "Привет мир". Теперь вы должны иметь представление об основах участия в разработке расширений, так что теперь нам придется перейти прямо к настройке среды разработки. Но сначала небольшое упражнение.</p>

<h2 id="Упражнение">Упражнение</h2>

<p>Измените приветственное сообщение, которое отображается в окне предупреждения, и переместите меню "Привет мир" в меню "Инструменты", которому оно принадлежит. Заново упакуйте XPI и переустановите его. Вы можете просто перетащить файл XPI в браузер, и он будет установлен локально. Проверьте его и убедитесь, что изменения работают. Если у вас возникли проблемы при установке, вполне вероятно, что вы не воспроизвели структуру XPI правильно, возможно, добавив ненужные папки.</p>

<div class="note"><strong>Примечание:</strong> упаковка расширения действительно состоит только в создании ZIP архива содержимого главного каталога (папки) и последующем изменении расширения файла на ".XPI". <strong>Не пакуйте</strong> содержащий нужные данные каталог, а строго только его содержимое. Содержимое каталога, файлы <strong><em>chrome.manifest</em></strong>, <strong><em>install.rdf</em></strong> и другие файлы и каталоги должны быть в корневом каталоге архива. Если сжать ещё и содержащий каталог (имеется в виду ещё один уровень вложенности), то ваше расширение не будет загружаться.</div>

<p>Имейте в виду, что в Firefox 4 и выше, в Windows и некоторых дистрибутивах Линукса, меню "Инструменты" по умолчанию скрыто. Оно может быть включено с помощью клавиши &lt;ALT&gt;.</p>

<p>Когда закончите, можете посмотреть по этой ссылке решение: <a href="/@api/deki/files/5141/=xulschoolhello2.xpi" title="https://developer.Mozilla.org/@api/deki/files/5141/=xulschoolhello2.xpi">Hello World 2</a>.</p>

<p>{{ PreviousNext("XUL_School/Getting_Started_with_Firefox_Extensions", "XUL_School/Setting_Up_a_Development_Environment") }}</p>

<p><span style="font-size: small;">Этот учебник сообществу Mozilla был любезно пожертвован фирмой Appcoast.</span></p>

<div id="cke_pastebin" style="position: absolute; top: 2144.83px; width: 1px; height: 1px; overflow: hidden; left: -1000px;"> </div>
