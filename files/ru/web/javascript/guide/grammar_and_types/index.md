---
title: Грамматика и типы
slug: Web/JavaScript/Guide/Grammar_and_types
tags:
  - JavaScript
  - Руководство
translation_of: Web/JavaScript/Guide/Grammar_and_types
---
<p>{{jsSidebar("JavaScript Guide")}} {{PreviousNext("Web/JavaScript/Guide/Introduction", "Web/JavaScript/Guide/Control_flow_and_error_handling")}}</p>

<div class="summary">
<p>В данной главе рассматриваются базовая грамматика, объявление переменных, типы данных и литералы.</p>
</div>

<h2 id="Основы">Основы</h2>

<p>JavaScript заимствует большую часть синтаксиса из Java, но также испытал влияние таких языков, как Awk, Perl и Python.</p>

<p>JavaScript <strong>чувствителен к регистру</strong> и использует кодировку символов <strong>Unicode</strong>. Например, слово Früh ("рано" по-немецки) может использоваться в качестве имени переменной.</p>

<pre class="brush: js">var Früh = "foobar";</pre>

<p>Но, переменная <code>früh</code> не то же самое что <code>Früh</code> потому что JavaScript чувствителен к регистру.</p>

<p>В JavaScript инструкции называются {{Glossary("Statement", "statements")}} и разделяются точкой с запятой (;). Пробел (space), табуляция (tab) и перевод строки (newline) называются пробельными символами (whitespace). Исходный текст скриптов на JavaScript сканируется слева направо и конвертируется в последовательность входных элементов, являющихся токенами (tokens), управляющими символами, символами конца строки, комментариями или пробельными символами. ECMAScript также определяет некоторые ключевые слова и литералы и устанавливает правила для автоматической вставки точек с запятой (<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Lexical_grammar#Automatic_semicolon_insertion">ASI</a>), чтобы обозначить конец инструкций (statements). Однако, рекомендуется всегда ставить точку с запятой в конце каждой инструкции вручную, чтобы избежать побочных эффектов. Чтобы получить более подробную информацию, прочитайте <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Lexical_grammar">Lexical Grammar</a>.</p>

<h2 id="Комментарии">Комментарии</h2>

<p>Синтаксис <strong>комментариев</strong> является таким же, как и в C++ и во многих других языках:</p>

<pre class="brush: js">// Комментарий, занимающий одну строку.

/* Комментарий,
   занимающий несколько строк.
 */

/* Нельзя вкладывать /* комментарий в комментарий */ SyntaxError */</pre>

<h2 id="Объявления">Объявления</h2>

<p>В JavaScript существует три вида объявлений:</p>

<dl>
 <dt><strong>{{jsxref("Statements/var", "var")}}</strong></dt>
 <dd>Объявляет переменную, инициализация переменной значением является необязательной.</dd>
 <dt><strong>{{jsxref("Statements/let", "let")}}</strong></dt>
 <dd>Объявляет локальную переменную в области видимости блока, инициализация переменной значением является необязательной.</dd>
 <dt><strong>{{jsxref("Statements/const", "const")}}</strong></dt>
 <dd>Объявляет именованную константу, доступную только для чтения.</dd>
</dl>

<h3 id="Переменные">Переменные</h3>

<p>Вы можете использовать переменные как символические имена для значений в вашем приложении. Имена переменных называются {{Glossary("Identifier", "identifiers")}} и должны соответствовать определённым правилам.</p>

<p>Идентификатор в JavaScript должен начинаться с буквы, нижнего подчёркивания (_) или знака доллара ($); последующие символы могут также быть цифрами (0-9). Поскольку JavaScript чувствителен к регистру, буквы включают символы от "A" до "Z" (верхний регистр) и символы от "a" до "z" (нижний регистр).</p>

<p>Вы можете использовать в идентификаторах буквы ISO 8859-1 или Unicode, например, å или ü. Вы также можете использовать<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Lexical_grammar#String_literals"> управляющие последовательности Unicode</a> как символы в идентификаторах.</p>

<p>Некоторые примеры корректных имён: <code>Number_hits</code>, <code>temp99</code>,  <code>_name</code>.</p>

<h3 id="Объявление_переменных">Объявление переменных</h3>

<p>Вы можете объявить переменную тремя способами:</p>

<ul>
 <li>Используя ключевое слово {{jsxref("Statements/var", "var")}}. Например, <code>var x = 42</code>. Данный синтаксис может быть использован для объявления как локальных, так и глобальных переменных.</li>
 <li>Просто присвоить переменной значение. Например, <code>x = 42</code>. Переменные, объявленные данным способом, являются глобальными. Такое объявление генерирует <a href="/ru/docs/Web/JavaScript/Reference/Strict_mode">строгое предупреждение</a>  (<a href="/ru/docs/Web/JavaScript/Reference/Strict_mode">strict mode</a>). Не рекомендуется использовать данный способ.</li>
 <li>Используя ключевое слово {{jsxref("Statements/let", "let")}}. Например, <code>let y = 13</code>. Данный синтаксис может быть использован для объявления локальной переменной в области видимости блока.</li>
</ul>

<h3 id="Присваивание_значений">Присваивание значений</h3>

<p>Переменная, объявленная через <code>var</code> или <code>let</code> без присвоения начального значения, имеет значение {{jsxref("undefined")}}.</p>

<p>При попытке доступа к необъявленной переменной или переменной до её объявления будет выброшено исключение {{jsxref("ReferenceError")}}:​</p>

<pre class="brush: js">var a;
console.log("The value of a is " + a); //Значение переменной a undefined

console.log("The value of b is " + b); //Uncaught ReferenceError: b не определена

console.log("The value of c is " + c); //Значение переменной c undefined
var c;

console.log("The value of x is " + x); //Uncaught ReferenceError: x не определена
let x; </pre>

<p>Вы можете использовать <code>undefined</code>, чтобы определить, имеет ли переменная значение. В следующем примере переменной <code>input</code> не присвоено значение, и оператор <code>if</code> будет вычислен как <code>true</code>:</p>

<pre class="brush: js">var input;
if (input === undefined) {
  doThis();
} else {
  doThat();
}</pre>

<p>Значение <code>undefined</code> ведёт себя как <code>false</code>, когда используется в логическом контексте. Например, следующий код выполняет функцию <code>myFunction</code>, т.к. элемент <code>myArray</code> не определён:</p>

<pre class="brush: js">var myArray = [];
if (!myArray[0]) {
  myFunction();
}
</pre>

<p>Значение <code>undefined</code> конвертируется в <code>NaN</code>, когда используется в числовом контексте:</p>

<pre class="brush: js">var a;
a + 2; // NaN</pre>

<p>Значение {{jsxref("null")}} ведёт себя как 0 в числовом контексте и как <code>false</code> в логическом контексте:</p>

<pre class="brush: js">var n = null;
console.log(n * 32); // В консоль выведется 0</pre>

<h3 id="Область_видимости_переменных">Область видимости переменных</h3>

<p>Когда вы объявляете переменную вне функции, то такая переменная называется <em>глобальной</em> переменной, т.к. доступна любому коду в текущем документе. Когда вы объявляете переменную внутри функции, то такая переменная называется <em>локальной</em> переменной, т.к. доступна только внутри данной функции.</p>

<p>До ECMAScript 6 в JavaScript отсутствовала область видимости <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Statements">блока</a>; переменная, объявленная внутри блока, является локальной для <em><strong>функции </strong></em>(или <em>глобальной</em> области видимости), внутри которой находится данный блок. Например, следующий код выведет значение 5, т.к. областью видимости переменной <code>x</code> является функция (или глобальный контекст), внутри которой объявлена переменная <code>x</code>, а <em><strong>не блок</strong>,</em> которым в данном случае является оператор <code>if</code>:</p>

<pre class="brush: js">if (true) {
  var x = 5;
}
console.log(x); // 5</pre>

<p>Такое поведение меняется, если используется оператор <code>let</code>, введённый в ECMAScript 6:</p>

<pre class="brush: js">if (true) {
  let y = 5;
}
console.log(y); // ReferenceError</pre>

<h3 id="Поднятие_переменных">Поднятие переменных</h3>

<p>Другим необычным свойством переменных в JavaScript является то, что можно сослаться на переменную, которая объявляется позже, и не получить при этом исключения. Эта концепция известна как <strong>поднятие</strong> (hoisting) переменных; переменные в JavaScript поднимаются в самое начало функции или выражения. Однако, переменные, которые ещё не были инициализированы, возвратят значение <code>undefined</code>:</p>

<pre class="brush: js">/*
 * Example 1
*/
console.log(x === undefined); // true
var x = 3;

/*
 * Example 2
*/
var myvar = "my value";

(function() {
  console.log(myvar); // undefined
  var myvar = "local value";
})();</pre>

<p>Приведённые выше примеры будут интерпретироваться так же, как:</p>

<pre class="brush: js">/*
 * Example 1
*/
var x;
console.log(x === undefined); // true
x = 3;

/*
 * Example 2
*/
var myvar = "my value";

(function() {
  var myvar;
  console.log(myvar); // undefined
  myvar = "local value";
})();</pre>

<p>Из-за поднятия переменных, все операторы <code>var</code> в функции следует размещать настолько близко к началу функции, насколько это возможно. Следование этому правилу улучшает ясность кода.</p>

<p>В ECMAScript 2015, <code>let (const)</code> <strong>не будет подниматься </strong>вверх блока. Однако, ссылки на переменную в блоке до объявления переменной вызовут  {{jsxref("ReferenceError")}}<code>.</code> Переменная во "временной мёртвой зоне" в начале блока, до объявления.</p>

<pre class="brush: js">function do_something() {
  console.log(foo); // ReferenceError
  let foo = 2;
}</pre>

<h3 id="Поднятие_функций">Поднятие функций</h3>

<p>Для функций: только определения функций поднимаются наверх, но не функции, определённые через выражения.</p>

<pre class="brush: js">/* Определение функции */
foo(); // "bar"

function foo() {
  console.log("bar");
}

/* Определение функции через выражение */
baz(); // TypeError: baz is not a function

var baz = function() {
  console.log("bar2");
};
</pre>

<h3 id="Глобальные_переменные">Глобальные переменные</h3>

<p>Глобальные переменные на самом деле являются свойствами <em>глобального объекта</em>. На веб-страницах глобальным объектом является {{domxref("window")}}, поэтому вы можете устанавливать глобальные переменные и обращаться к ним, используя синтаксис <code>window.<em>variable</em></code>:</p>

<pre class="brush: js">window.foo = 'bar';</pre>

<p>Следовательно, вы можете обращаться к глобальным переменным, объявленным в одном объекте window или frame из другого объекта window или frame, указав имя window или frame. Например, если переменная <code>phoneNumber</code> объявлена в документе, то вы можете сослаться на эту переменную из iframe как <code>parent.phoneNumber</code>.</p>

<h3 id="Константы"><a id="Constants">Константы</a></h3>

<p>Вы можете создать именованную константу, доступную только для чтения, используя ключевое слово {{jsxref("Statements/const", "const")}}. Синтаксис идентификатора константы является таким же, как и у идентификатора переменной: он должен начинаться с буквы, нижнего подчёркивания или знака $ и может содержать буквы, цифры или нижнее подчёркивание.</p>

<pre class="brush: js">const PREFIX = '212';</pre>

<p>Нельзя изменить значение константы через присваивание или повторное объявление во время выполнения скрипта. Значение должно быть указано при инициализации.</p>

<p>Правила, касающиеся области видимости, для констант являются такими же, как и для переменных, объявленных через <code>let</code>. Если ключевое слово <code>const</code> не указано, то идентификатор будет являться переменной.</p>

<p>Нельзя объявить константу с таким же именем, как у функции или переменной в одной области видимости. Следующие примеры выбросят исключение <code>TypeError</code>:</p>

<pre class="brush: js">// Это вызовет ошибку 
function f() {}
const f = 5;

// Это тоже вызовет ошибку 
function f() {
  const g = 5;
  var g;

  // какие-то выражения 
} </pre>

<p>Однако, атрибуты объектов не защищены, так что следующее выражение выполнится без проблем</p>

<pre class="brush: js">const MY_OBJECT = {"key": "value"};
MY_OBJECT.key = "otherValue";</pre>

<h2 id="Структуры_и_типы_данных">Структуры и типы данных</h2>

<h3 id="Типы_данных">Типы данных</h3>

<p>Последний стандарт ECMAScript определяет семь типов данных:</p>

<ul>
 <li>Шесть типов данных,  которые являются {{Glossary("Primitive", "примитивами")}}:
  <ul>
   <li>{{Glossary("Boolean")}}. <code>true</code> и <code>false</code>.</li>
   <li>{{Glossary("null")}}. Специальное ключевое слово, обозначающее нулевое или «пустое» значение. Поскольку JavaScript чувствителен к регистру, <code>null</code> не то же самое, что <code>Null</code>, <code>NULL</code> или любой другой вариант.</li>
   <li>{{Glossary("undefined")}}. Свойство глобального объекта; переменная, не имеющая присвоенного значения, обладает типом <code>undefined</code>.</li>
   <li>{{Glossary("Number")}}. <code>42</code> или <code>3.14159</code>.</li>
   <li>{{Glossary("String")}}. "Howdy".</li>
   <li>{{Glossary("Symbol")}} (ECMAScript 6)</li>
  </ul>
 </li>
 <li>и {{Glossary("Object")}}</li>
</ul>

<p>Хотя типов данных относительно немного, но они позволяют вам выполнять полезные функции в ваших приложениях. {{jsxref("Object", "Объекты")}} и {{jsxref("Function", "функции")}} являются другими фундаментальными элементами языка. Вы можете думать об объектах как об именованных контейнерах для значений и о функциях как о процедурах, которые ваше приложение может исполнять.</p>

<h3 id="Преобразование_типов_данных">Преобразование типов данных</h3>

<p>JavaScript — это динамически типизированный язык. Это означает, что вам не нужно указывать тип данных переменной, когда вы её объявляете, типы данных преобразуются автоматически по мере необходимости во время выполнения скрипта. Так, например, вы можете определить переменную следующим образом:</p>

<pre class="brush: js">var answer = 42;</pre>

<p>А позже вы можете присвоить этой переменной строковое значение, например:</p>

<pre class="brush: js">answer = "Thanks for all the fish...";</pre>

<p>Поскольку JavaScript является динамически типизированным, это присваивание не вызовет сообщения об ошибке.</p>

<p>В выражениях, включающих числовые и строковые значения с оператором <code>+</code>, JavaScript преобразует числовые значения в строковые. Например:</p>

<pre class="brush: js">x = "The answer is " + 42 // "The answer is 42"
y = 42 + " is the answer" // "42 is the answer"</pre>

<p>В выражениях с другими операторами JavaScript не преобразует числовые значения в строковые. Например:</p>

<pre class="brush: js">"37" - 7 // 30
"37" + 7 // "377"</pre>

<h3 id="Преобразование_строк_в_числа">Преобразование строк в числа</h3>

<p>В том случае, если значение, представляющее число, хранится в памяти как строка, можно использовать методы для преобразования строк в числа:</p>

<ul>
 <li id="parseInt()_and_parseFloat()">{{jsxref("parseInt", "parseInt(numString, [radix])")}}</li>
 <li>{{jsxref("parseFloat", "parseFloat(numString)")}}</li>
</ul>

<p><code>parseInt</code> преобразует строку в целочисленное значение. Хорошей практикой является всегда указывать основание системы счисления (параметр <code>radix</code>).</p>

<p>Альтернативным способом для получения числа из строки является использование оператора "унарный плюс":</p>

<pre class="brush: js">"1.1" + "1.1"       // "1.11.1"
(+"1.1") + (+"1.1") // 2.2
// Обратите внимание на то, что скобки не являются обязательными и используются для ясности.</pre>

<h2 id="Литералы">Литералы</h2>

<p>Литералы используются для представления значений в JavaScript. Они являются фиксированными значениями, а не переменными. В данной секции рассматриваются следующие типы литералов:</p>

<ul>
 <li><a href="#литерал_массива">Литерал массива</a></li>
 <li><a href="#логический_литерал">Логический литерал</a></li>
 <li><a href="#литерал_целого_числа">Литерал целого числа</a></li>
 <li><a href="#литерал_числа_с_плавающей_точкой">Литерал числа с плавающей точкой</a></li>
 <li><a href="#литерал_объекта">Литерал объекта</a></li>
 <li><a href="#regexp_литерал">RegExp литерал</a></li>
 <li><a href="#литерал_строки">Литерал строки</a></li>
</ul>

<h3 id="Литерал_массива">Литерал массива</h3>

<p>Литерал массива — это список из нуля или более выражений, каждое из которых представляет элемент массива, заключённый в квадратные скобки ( <code>[]</code> ). Когда вы создаёте массив, используя литерал массива, он инициализируется с помощью переданных значений, которые будут являться его элементами, длина массива будет равна числу переданных аргументов.</p>

<p>В следующем примере создаётся массив <code>coffees</code> с тремя элементам и длиной, равной трём:</p>

<pre class="brush: js">var coffees = ["French Roast", "Colombian", "Kona"];
</pre>

<div class="note">
<p><strong>Замечание :</strong> Обратите внимание на то, что литерал массива является инициализатором объекта. Чтобы получить более подробную информацию, прочитайте <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Working_with_Objects#.D0.98.D1.81.D0.BF.D0.BE.D0.BB.D1.8C.D0.B7.D0.BE.D0.B2.D0.B0.D0.BD.D0.B8.D0.B5_.D0.B8.D0.BD.D0.B8.D1.86.D0.B8.D0.B0.D0.BB.D0.B8.D0.B7.D0.B0.D1.82.D0.BE.D1.80.D0.BE.D0.B2_.D0.BE.D0.B1.D1.8A.D0.B5.D0.BA.D1.82.D0.B0">Использование инициализаторов объекта</a>.</p>
</div>

<p>Если массив создаётся с помощью литерала в скрипте верхнего уровня, то JavaScript интерпретирует массив каждый раз, когда вычисляет выражение, содержащее литерал. Кроме того, литерал, используемый в функции, создаётся каждый раз, когда вызывается функция.</p>

<p>Литералы массива также являются объектами <code>Array</code>. Чтобы получить более подробную информацию, прочитайте {{jsxref("Array")}} и <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Indexed_collections">упорядоченные наборы данных</a>.</p>

<h4 id="Лишние_запятые_в_литералах_array">Лишние запятые в литералах array</h4>

<p>Не обязательно указывать все элементы в литерале array. Если вы поставите две запятые подряд, то пропущенные элементы будут иметь значение <code>undefined</code>. Например:</p>

<pre class="brush: js">var fish = ["Lion", , "Angel"]; // ["Lion", undefined, "Angel"]</pre>

<p>У этого массива есть 2 элемента со значениям и один пустой (<code>fish[0]</code> - "Lion", <code>fish[1]</code> - <code>undefined</code>, а <code>fish[2]</code> - "Angel").</p>

<p>Если вы поставите запятую в конце списка элементов, то она будет проигнорирована. В следующем примере, длина массива равна 3. Нет <code>myList[3]</code>. Все другие запятые в списке говорят о новом элементе.</p>

<div class="note">
<p><strong>Замечание :</strong> Лишние запятые могут вызывать ошибки в старых версиях браузеров, поэтому лучше избегать их использования.</p>
</div>

<pre class="brush: js">var myList = ['home', , 'school', ]; // ["home", undefined, "school"]
</pre>

<p>В следующем примере длина массива равна четырём, элементы <code>myList[0]</code> и <code>myList[2]</code> имеют значение <code>undefined</code>:</p>

<pre class="brush: js">var myList = [ , 'home', , 'school']; // [undefined, "home", undefined, "school"]</pre>

<p>В следующем примере длина массива равна четырём, элементы <code>myList[1]</code> и <code>myList[3]</code> имеют значение <code>undefined</code>. Игнорируется только последняя запятая.</p>

<pre class="brush: js">var myList = ['home', , 'school', , ]; // ["home", undefined, "school", undefined]</pre>

<p>Понимание поведения лишних запятых важно для понимания JavaScript как языка. Однако, когда будете писать свой собственный код, то имейте в виду, что явное объявление отсутствующих элементов как <code>undefined</code> улучшает ясность кода и лёгкость его поддержки.</p>

<h3 id="Логические_литералы">Логические литералы</h3>

<p>Логический (Boolean) тип имеет два литеральных значения: <code>true</code> и <code>false</code>.</p>

<p>Не путайте примитивные логические значения <code>true</code> и <code>false</code> со значениями true и false объекта Boolean. Объект Boolean является объектом-обёрткой над примитивом логического типа. Чтобы получить более подробную информацию, прочитайте {{jsxref("Boolean")}}.</p>

<h3 id="Литерал_целого_числа">Литерал целого числа</h3>

<p>Целые числа могут быть записаны в десятичной, шестнадцатеричной, восьмеричной и двоичной системах счисления.</p>

<ul>
 <li>Десятичный целочисленный литерал состоит из последовательности цифр без ведущего нуля.</li>
 <li>Ведущий ноль в целочисленном литерале указывает на то, что он записан в восьмеричной системе счисления. Восьмеричные целые числа состоят только из цифр 0-7.</li>
 <li>Ведущие символы 0x (или 0X) указывают на то, что число шестнадцатеричное. Шестнадцатеричные целые числа могут состоять из цифр 0-9 и букв a-f и A-F. </li>
 <li>Ведущие символы 0b (или 0B) указывают на то, что число двоичное. Двоичные числа могут включать в себя только цифры 0 и 1.</li>
</ul>

<p>Несколько примеров целочисленных литералов:</p>

<pre>0, 117 и -345 (десятичная система счисления)
015, 0001 и -077 (восьмеричная система счисления)
0x1123, 0x00111 и -0xF1A7 (шестнадцатеричная система счисления)
0b11, 0b0011 и -0b11 (двоичная система счисления)
</pre>

<p>Для дополнительной информации смотрите <a href="/ru/docs/Web/JavaScript/Reference/Lexical_grammar">числовые литералы в лексической грамматике</a>.</p>

<h3 id="Литерал_числа_с_плавающей_точкой">Литерал числа с плавающей точкой</h3>

<p>Числа с плавающей точкой могут состоять из следующих частей:</p>

<ul>
 <li>Десятичное целое число, которое может иметь знак (символ "+" или "-", стоящий перед числом),</li>
 <li>Десятичная точка ("."),</li>
 <li>Дробная часть (другое десятичное число),</li>
 <li>Экспонента.</li>
</ul>

<p>Экспонента состоит из символа "e" или "E", за которым следует целое число, которое может иметь знак. Число с плавающей точкой должно состоять по крайней мере из одной цифры и либо десятичной точки, либо символа "e" (или "E").</p>

<p>В более сжатой форме синтаксис выглядит следующим образом:</p>

<pre>[(+|-)][digits][.digits][(E|e)[(+|-)]digits]</pre>

<p>Примеры:</p>

<pre>3.14
-3.1E+12
-.3333333333333333333
.1e-23
</pre>

<h3 id="Литерал_объекта">Литерал объекта</h3>

<p>Литерал объекта — это список из нуля или более пар, состоящих из имён свойств и связанных с ними значений, заключённый в фигурные скобки ( <code>{}</code> ). Вам не следует использовать литерал объекта в начале выражения, т.к. это приведёт к ошибке или к поведению, которого вы не ожидаете, потому что символ "{" будет интерпретироваться как начало блока.</p>

<p>В следующем примере свойству <code>myCar</code> объекта <code>car</code> присваивается строка <code>"Saturn"</code>, свойству <code>getCar</code> — результат вызова функции <code>CarTypes("Honda")</code>, свойству <code>special</code> — значение переменной <code>Sales</code>:</p>

<pre class="brush: js">var Sales = "Toyota";

function CarTypes(name) {
  if (name == "Honda") {
    return name;
  } else {
    return "Извините, мы не продаём " + name + ".";
  }
}

var car = { myCar: "Saturn", getCar: CarTypes("Honda"), special: Sales };

console.log(car.myCar);   // Saturn
console.log(car.getCar);  // Honda
console.log(car.special); // Toyota</pre>

<p>Кроме того, вы можете использовать числовой или строковой литералы в именах свойств или вкладывать один объект в другой. Например:</p>

<pre class="brush: js">var car = { manyCars: {a: "Saab", "b": "Jeep"}, 7: "Mazda" };

console.log(car.manyCars.b); // Jeep
console.log(car[7]);         // Mazda</pre>

<p>Именем свойства объекта может быть любая строка, в том числе пустая строка. Если имя свойства не является корректным JavaScript идентификатором, то оно должно быть заключено в кавычки. Для обращения к таким именам следует использовать квадратные скобки ( <code>[]</code> ), а не точку ( <code>.</code> ):</p>

<pre class="brush: js">var unusualPropertyNames = {
  "": "An empty string",
  "!": "Bang!"
}
console.log(unusualPropertyNames."");   // SyntaxError: Unexpected string
console.log(unusualPropertyNames[""]);  // "An empty string"
console.log(unusualPropertyNames.!);    // SyntaxError: Unexpected token !
console.log(unusualPropertyNames["!"]); // "Bang!"
</pre>

<p>В ES2015 литералы объектов расширены до поддержки установки прототипа в конструкции короткой записи для <code>foo: </code>задание <code>foo</code>,  определение методов, создание супер вызовов и вычисление имён свойств в выражениях. Вместе, они делают похожими объектные литералы и объявления классов, а также позволяют объектному дизайну получать выгоду одинаковых возможностей.</p>

<pre class="brush: js">var obj = {
    // __proto__
    __proto__: theProtoObj,
    // Короткая запись для ‘handler: handler’
    handler,
    // Методы
    toString() {
     // Супер вызовы
     return "d " + super.toString();
    },
    // Динамическое вычисление имён свойств
    [ 'prop_' + (() =&gt; 42)() ]: 42
};</pre>

<p>Обратите внимание на следующий пример:</p>

<pre class="brush: js">var foo = {a: "alpha", 2: "two"};
console.log(foo.a);               // alpha
console.log(foo[2]);              // two
// console.log(foo.2);            // SyntaxError: Unexpected number
// console.log(foo[a]);           // ReferenceError: a is not defined
console.log(foo["a"]);            // alpha
console.log(foo["2"]);            // two</pre>

<h3 id="RegExp_литерал">RegExp литерал</h3>

<p>Литерал regexp - шаблон между слешами. Следующий пример литерал regex:</p>

<pre class="brush: js">var re = /ab+c/;</pre>

<h3 id="Строковый_литерал">Строковый литерал</h3>

<p>Строковый литерал — это ноль или более символов, заключённых в двойные ( <code>"</code> ) или одинарные ( <code>'</code> ) кавычки. Строка должна быть ограничена кавычками одного типа, т.е. либо обе одинарные, либо обе двойные. Например:</p>

<pre>"foo"
'bar'
"1234"
"one line \n another line"
"John's cat"</pre>

<p><code>​</code>Вы можете вызвать любой из методов объекта <code>String</code> для строкового литерала: JavaScript автоматически преобразует строковой литерал во временный объект <code>String</code>, вызовет метод, а затем уничтожит временный объект <code>String</code>. Вы также можете использовать свойство <code>String.length</code> со строковым литералом:</p>

<pre class="brush: js">console.log("John's cat".length);
// Число символов в строке, включая пробел.
// В данном случае длина строки равна 10.</pre>

<p>В ES2015 также доступны шаблоны строк. Шаблоны строк представляют собой синтаксический сахар для конструирования строк. Это похоже на возможности интерполяции строк в Perl, Python и других. Дополнительно, может быть добавлен тег, позволяющий настраивать конструирование строк, избегая атак внедрения и построения структур данных высокого уровня из содержимого строки.</p>

<pre class="brush: js">// Простое создание строки через литерал string
`In JavaScript '\n' is a line-feed.`

// Мультистроковые строки
`In JavaScript this is
 not legal.`

// Интерполяция строк
var name = "Бобби", time = "сегодня";
`Привет ${name}, как ты ${time}?`

// Строим префикс HTTP запроса, используемый для интерпретации замен и конструирования
POST`http://foo.org/bar?a=${a}&amp;b=${b}
     Content-Type: application/json
     X-Credentials: ${credentials}
     { "foo": ${foo},
       "bar": ${bar}}`(myOnReadyStateChangeHandler);
</pre>

<p>Вам следует использовать строковые литералы до тех пор, пока вам специально не понадобится объект <code>String</code>. Чтобы получить более подробную информацию об объекте <code>String</code>, прочитайте {{jsxref("String")}}.</p>

<h4 id="Использование_специальных_символов_в_строках">Использование специальных символов в строках</h4>

<p>Кроме обычных символов вы также можете включать специальные символы в строки.</p>

<pre class="brush: js">"one line \n another line"</pre>

<p>В следующей таблице перечислены специальные символы, которые вы можете использовать.</p>

<table class="standard-table">
 <caption>Специальные символы в JavaScript</caption>
 <thead>
  <tr>
   <th scope="col">Символ</th>
   <th scope="col">Значение</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><code>\b</code></td>
   <td>Возврат (Backspace)</td>
  </tr>
  <tr>
   <td><code>\f</code></td>
   <td>Перевод или прогон страницы (Form feed)</td>
  </tr>
  <tr>
   <td><code>\n</code></td>
   <td>Перевод строки (New line)</td>
  </tr>
  <tr>
   <td><code>\r</code></td>
   <td>Возврат каретки (Carriage return)</td>
  </tr>
  <tr>
   <td><code>\t</code></td>
   <td>Табуляция (Tab)</td>
  </tr>
  <tr>
   <td><code>\v</code></td>
   <td>Вертикальная табуляция (Vertical tab)</td>
  </tr>
  <tr>
   <td><code>\'</code></td>
   <td>Апостроф или одинарная кавычка</td>
  </tr>
  <tr>
   <td><code>\"</code></td>
   <td>Двойная кавычка</td>
  </tr>
  <tr>
   <td><code>\\</code></td>
   <td>Обратная косая черта (Backslash)</td>
  </tr>
  <tr>
   <td><code>\<em>XXX</em></code></td>
   <td>
    <p>Символ в кодировке Latin-1, представленный тремя восьмеричными числами <em>XXX</em> от 0 до 377. Например, \251 (символ ©).</p>
   </td>
  </tr>
  <tr>
   <td><code>\x<em>XX</em></code></td>
   <td>
    <p>Символ в кодировке Latin-1, представленный двумя шестнадцатеричными числами <em>XX</em> от 00 до FF. Например, \xA9 (символ ©).</p>
   </td>
  </tr>
  <tr>
   <td><code>\u<em>XXXX</em></code></td>
   <td>
    <p>Символ в Unicode, представленный четырьмя шестнадцатеричными числами <em>XXXX</em>. Например, \u00A9 (символ ©).</p>
   </td>
  </tr>
  <tr>
   <td><code>\u<em>{XXXXX}</em></code></td>
   <td>Символ в UTF-32BE. Например, \u{2F804} обозначает то же, что обычная запись \uD87E\uDC04.</td>
  </tr>
 </tbody>
</table>

<h4 id="Экранирующие_символы">Экранирующие символы</h4>

<p>Для символов, не перечисленных в вышеприведённой таблице, предваряющая обратная косая черта игнорируется. Такое использование не является рекомендованным (deprecated) и вам следует избегать его.</p>

<p>Вы можете вставить кавычку в строку, если поставите перед ней обратную косую черту. Это называется экранированием кавычек. Например:</p>

<pre class="brush: js">var quote = "He read \"The Cremation of Sam McGee\" by R.W. Service.";
console.log(quote); // He read "The Cremation of Sam McGee" by R.W. Service.</pre>

<p>Чтобы включить обратную косую черту в строку, перед ней нужно поставить ещё одну обратную косую черту. Например:</p>

<pre class="brush: js">var home = "c:\\temp"; // c:\temp</pre>

<p>Вы также можете экранировать перевод строки. Обратная косая черта и перевод строки будут удалены из содержимого строки. Например:</p>

<pre class="brush: js">var str = "this string \
is broken \
across multiple\
lines."
console.log(str); // this string is broken across multiplelines.</pre>

<p>Хотя JavaScript не поддерживает синтаксис "heredoc" (форматированный текст в одной строковой переменной), но вы можете эмулировать его, добавив перевод строки и обратную косую черту в конец каждой строки:</p>

<pre class="brush: js">var poem =
"Roses are red,\n\
Violets are blue.\n\
I'm schizophrenic,\n\
And so am I."</pre>

<h2 id="Дополнительная_информация">Дополнительная информация</h2>

<p>Данная глава сфокусирована на базовом синтаксисе для объявлений и типов. Чтобы получить более подробную информацию о конструкциях JavaScript, прочитайте:</p>

<ul>
 <li><a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Statements">Порядок выполнения и обработка ошибок</a></li>
 <li><a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Loops_and_iteration">Циклы и итерация</a></li>
 <li><a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Functions">Функции</a></li>
 <li><a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Expressions_and_Operators">Выражения и операторы</a></li>
</ul>

<p>В следующей главе рассматриваются управляющие конструкции и обработка ошибок.</p>

<p>{{PreviousNext("Web/JavaScript/Guide/Introduction", "Web/JavaScript/Guide/Control_flow_and_error_handling")}}</p>
