---
title: Выполняемые на сервере веб-фреймворки
slug: Learn/Server-side/First_steps/Web_frameworks
tags:
  - '-фреймворк'
  - Программирование серверной части
  - Сервер
  - начальный уровень
translation_of: Learn/Server-side/First_steps/Web_frameworks
---
<div>{{LearnSidebar}}</div>

<div>{{PreviousMenuNext("Learn/Server-side/First_steps/Client-Server_overview", "Learn/Server-side/First_steps/Website_security", "Learn/Server-side/First_steps")}}</div>

<p class="summary">В предыдущей статье было показано, как выглядит общение между веб-клиентами и серверами, характер HTTP-запросов и ответов, а также то, что веб-приложение на стороне сервера должно выполнять, чтобы отвечать на запросы из веб-браузера. Благодаря этим знаниям настало время изучить, как веб-интерфейсы могут упростить эти задачи, и дать вам представление о том, как выбрать структуру для своего первого веб-приложения на стороне сервера.</p>

<table>
 <tbody>
  <tr>
   <th scope="row">Необходимые навыки:</th>
   <td>Базовая компьютерная грамотность. Высокое понимание того, как серверный код обрабатывает и отвечает на HTTP-запросы (см. <a href="/en-US/docs/Learn/Server-side/First_steps/Client-Server_overview">Client-Server overview</a>).</td>
  </tr>
  <tr>
   <th scope="row">Цели:</th>
   <td>Понять, как веб-интерфейсы могут упростить разработку / обслуживание кода на стороне сервера и заставить читателей задуматься о выборе структуры для собственной разработки.</td>
  </tr>
 </tbody>
</table>

<p>Следующие разделы иллюстрируют некоторые моменты, используя фрагменты кода, взятые из реальных веб-интерфейсов. Не беспокойтесь, если не всё сразу понятно; мы будем работать над кодом вместе в модулях, посвящённых отдельным фреймворкам.</p>

<h2 id="Обзор">Обзор</h2>

<p>Серверные веб-фреймворки (или «фреймворки веб-приложений») — это программные среды, которые упрощают создание, поддержку и масштабирование веб-приложений. Они предоставляют инструменты и библиотеки, которые упрощают общие задачи веб-разработки, включая маршрутизацию URL-адресов для соответствующих обработчиков, взаимодействие с базами данных, поддержку сеансов и авторизацию пользователей, форматирование вывода (например, HTML, JSON, XML) и улучшение защиты от веб-атак.</p>

<p>В следующем разделе приводится более подробная информация о том, как веб-фреймворки могут облегчить разработку веб-приложений. Затем мы объясним некоторые критерии, которые вы можете использовать для выбора веб-фреймворка, а затем перечислим некоторые из ваших вариантов.</p>

<h2 id="Что_может_сделать_веб-фреймворк_для_вас">Что может сделать веб-фреймворк для вас?</h2>

<p>Веб-фреймворки предоставляют инструменты и библиотеки для упрощения общих операций веб-разработки. Вы не обязаны использовать веб-фреймворк на стороне сервера, но это настоятельно рекомендуется — это сделает вашу жизнь намного проще.</p>

<p>В этом разделе обсуждается различная функциональность, которая часто предоставляется веб-фреймворками (но не каждый фреймворк должен обязательно содержать весь описанный функционал!)</p>

<h3 id="Работайте_напрямую_с_HTTP-запросами_и_ответами">Работайте напрямую с HTTP-запросами и ответами</h3>

<p>Как мы видели в последней статье, веб-серверы и браузеры обмениваются данными по протоколу HTTP — серверы ожидают HTTP-запросы из браузера, а затем возвращают информацию в HTTP-ответах. Веб-фреймворки позволяют писать упрощённый синтаксис, который будет генерировать серверный код для работы с этими запросами и ответами. Это означает, что вам будет легче работать, взаимодействуя с более простым кодом более высокого уровня, а не с сетевыми примитивами более низкого уровня.</p>

<p>Пример ниже показывает, как это работает в веб-фреймворке Django (Python). Каждая функция «view» (обработчик запроса) получает объект <code>HttpRequest</code>, содержащий информацию о запросе, и должна вернуть объект <code>HttpResponse</code> с форматированным выводом (в этом случае строка).</p>

<pre class="brush: python"># Django view function
from django.http import HttpResponse

def index(request):
    # Get an HttpRequest (request)
    # perform operations using information from the request.
    # Return HttpResponse
    return HttpResponse('Output string to return')
</pre>

<h3 id="Запросы_маршрута_к_соответствующему_обработчику">Запросы маршрута к соответствующему обработчику</h3>

<p>Большинство сайтов предоставляют несколько различных ресурсов, доступных через отдельные URL-адреса. Если работать с ними в одной функции, поддерживать будет трудно, поэтому веб-фреймворки предоставляют простые механизмы для сопоставления шаблонов URL-адресов с конкретными функциями обработчика. Этот подход также имеет преимущества с точки зрения обслуживания, потому что вы можете изменить URL-адрес, используемый для доставки определённой функции, без изменения базового кода.</p>

<p>Различные фреймворки используют различные механизмы для сопоставления. Например, веб-фреймворк Flask (Python) добавляет маршруты для просмотра функций используя декораторы.</p>

<pre class="brush: python">@app.route("/")
def hello():
    return "Hello World!"</pre>

<p>Django ожидает, что разработчики определят список сопоставлений URL-адресов между шаблоном URL-адреса и функцией просмотра.</p>

<pre class="brush: python">urlpatterns = [
    url(r'^$', views.index),
    # example: /best/myteamname/5/
    url(r'^best/(?P&lt;team_name&gt;\w.+?)/(?P&lt;team_number&gt;[0-9]+)/$', views.best),
]
</pre>

<h3 id="Упростите_доступ_к_данным_в_запросе">Упростите доступ к данным в запросе</h3>

<p>Данные могут быть закодированы в HTTP-запросе разными способами. Для получения файлов или данных с сервера, HTTP-запрос <code>GET</code> может кодировать, какие данные требуются в URL-параметрах или в структуре URL. HTTP-запрос <code>POST</code> для обновления ресурса на сервере вместо этого будет включать обновлённую информацию как «POST данные» внутри тела запроса. HTTP-запрос может также включать информацию о текущей сессии или пользователе в cookie со стороны клиента.</p>

<p>Веб-фреймворки предоставляют соответствующие языку программирования механизмы доступа к этой информации. Например, объект <code>HttpRequest</code>, который Django передаёт каждой функции «view», содержит методы и свойства для доступа к целевому URL, типу запроса (например, HTTP <code>GET</code>), параметрам <code>GET</code> или <code>POST</code>, файлам cookie и данным сеанса и т. д. Django также может передавать информацию, закодированную в структуре URL, путём определения «шаблонов захвата» в преобразователе URL (см. последний фрагмент кода в разделе выше).</p>

<h3 id="Абстрагируйте_и_упростите_доступ_к_базе_данных">Абстрагируйте и упростите доступ к базе данных</h3>

<p>Веб-сайты используют базы данных для хранения информации как для пользователей, так и о пользователях. Веб-фреймворки часто предоставляют слой базы данных, который абстрагирует операции чтения, записи, запроса и удаления базы данных. Этот уровень абстракции называется Object-Relational Mapper (ORM).</p>

<p>Использование ORM имеет два преимущества:</p>

<ul>
 <li>Вы можете заменить лежащую в основе базу данных без необходимости изменять код, который её использует. Это позволяет разработчикам оптимизировать характеристики различных баз данных в зависимости от их использования.</li>
 <li>Базовая проверка данных может быть реализована. Это позволяет легче и безопаснее проверить, что данные хранятся в правильном поле типа базы данных, имеют правильный формат (например, адрес электронной почты) и не являются вредоносными (взломщики могут использовать определённые шаблоны кода, чтобы сделать такие вещи, как удаление записей базы данных).</li>
</ul>

<p>Например, веб-фреймворк Django предоставляет ORM и ссылается на объект, используемый для определения структуры записи в качестве модели. Модель задаёт типы полей, которые должны быть сохранены, что может обеспечить проверку на уровне поля того, какая информация может быть сохранена (например, поле электронной почты будет разрешать только действительные адреса электронной почты). В определениях полей также можно указать их максимальный размер, значения по умолчанию, параметры списка выбора, текст справки для документации, текст метки для форм и т. д. Модель не содержит никакой информации о базе данных, поскольку это параметр конфигурации, который может быть изменён отдельно от нашего кода.</p>

<p>Первый фрагмент кода ниже показывает очень простую модель Django для объекта <code>Team</code>. Это сохраняет название команды и уровень команды как символьные поля и определяет максимальное количество символов для каждой записи. <code>team_level</code> — это поле выбора, поэтому здесь мы связываем варианты значений на выбор с сохраняемыми данными, а также значение по умолчанию.</p>

<pre class="brush: python">#best/models.py

from django.db import models

class Team(models.Model):
    team_name = models.CharField(max_length=40)

    TEAM_LEVELS = (
        ('U09', 'Under 09s'),
        ('U10', 'Under 10s'),
        ('U11, 'Under 11s'),
        ...  #list our other teams
    )
    team_level = models.CharField(max_length=3,choices=TEAM_LEVELS,default='U11')
</pre>

<p>Модель Django предоставляет простой API запросов для поиска в базе данных. Это может соответствовать нескольким полям одновременно, используя различные критерии (например, exact (точный), case-insensitive (без учёта регистра), greater than (больше чем) и т. п.), а также может поддерживать сложные операторы (например, вы можете указать поиск для команд U11, в которых есть команда имя, которое начинается с «Fr» или заканчивается на «al»).</p>

<p>Второй фрагмент кода показывает функцию представления (обработчик ресурсов) для отображения всех наших команд U09. В этом случае мы указываем, что мы хотим фильтровать для всех записей, где поле <code>team_level</code> имеет в точности текст «U09» (обратите внимание ниже, как этот критерий передаётся функции <code>filter()</code> в качестве аргумента с именем поля и типом соответствия, отделённым двойным подчёркиванием: <strong>team_level__exact</strong>).</p>

<pre class="brush: python">#best/views.py

from django.shortcuts import render
from .models import Team

def youngest(request):
    <strong>list_teams = Team.objects.filter(team_level__exact="U09")</strong>
    context = {'youngest_teams': list_teams}
    return render(request, 'best/index.html', context)
</pre>

<dl>
</dl>

<h3 id="Отрисовка_данных">Отрисовка данных</h3>

<p>Веб-фреймворки часто предоставляют системы шаблонов. Они позволяют вам указать структуру выходного документа, используя заполнители для данных, которые будут добавлены при создании страницы. Шаблоны часто используются для создания HTML, но могут также создавать другие типы документов.</p>

<p>Веб-фреймворки часто предоставляют механизм, позволяющий легко создавать другие форматы из хранимых данных, включая {{glossary ("JSON")}} и {{glossary ("XML")}}.</p>

<p>Например, система шаблонов Django позволяет вам задавать переменные с использованием синтаксиса «двойных велосипедных рулей» (например, <code>{</code><code>{ <em>имя_переменной</em> </code><code>}</code><code>}</code>), которые будут заменены значениями, передаваемыми из функции «view» при отрисовке страницы. Система шаблонов также обеспечивает поддержку выражений (с синтаксисом: <code>{% <em>выражение</em> %}</code>), которые позволяют шаблонам выполнять простые операции, такие как повторение значений списка, передаваемых в шаблон.</p>

<div class="note">
<p><strong>На заметку</strong>. Многие другие системы шаблонов используют аналогичный синтаксис, например: Jinja2 (Python),  handlebars  (JavaScript),  moustache  (JavaScript) и т. п.</p>
</div>

<p>Фрагмент кода ниже показывает, как это работает. Продолжая пример «самой молодой команды» из предыдущего раздела, HTML-шаблон передаёт представлению переменную списка <code>youngest_teams</code>. Внутри скелета HTML у нас есть выражение, которое сначала проверяет, существует ли переменная <code>youngest_teams</code>, а затем повторяет её в цикле <code>for</code>. На каждой итерации шаблон отображает значение <code>team_name</code> команды в элементе списка.</p>

<pre class="brush: html">#best/templates/best/index.html

&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;

 {% if youngest_teams %}
    &lt;ul&gt;
    {% for team in youngest_teams %}
        &lt;li&gt;\{\{ team.team_name \}\}&lt;/li&gt;
    {% endfor %}
    &lt;/ul&gt;
{% else %}
    &lt;p&gt;No teams are available.&lt;/p&gt;
{% endif %}

&lt;/body&gt;
&lt;/html&gt;
</pre>

<h2 id="Как_выбрать_веб-фреймворк">Как выбрать веб-фреймворк</h2>

<p>Многочисленные веб-фреймворки существуют практически для каждого языка программирования, который вы, возможно, захотите использовать (мы перечислим несколько наиболее популярных фреймворков в следующем разделе). При таком большом количестве вариантов может оказаться затруднительным определить, какой фреймворк обеспечивает лучшую отправную точку для вашего нового веб-приложения.</p>

<p>Вот некоторые из факторов, которые могут повлиять на ваше решение:</p>

<ul>
 <li><strong>Усилия для изучения:</strong> усилия по изучению веб-фреймворка зависят от того, насколько вы знакомы с базовым языком программирования, последовательностью его API, качеством документации, а также размером и активностью поддерживающего его сообщества. Если вы начинаете без какого бы то ни было опыта программирования, подумайте о Django (это один из самых простых способов изучения на основе вышеуказанных критериев). Если вы являетесь частью команды разработчиков, которая уже имеет значительный опыт работы с определённым веб-фреймворком или языком программирования, то имеет смысл остановиться на используемом.</li>
 <li><strong>Производительность:</strong> Производительность — это показатель того, насколько быстро вы можете создавать новые функции, когда вы знакомы с платформой, и включает в себя как усилия по написанию, так и по обслуживанию кода (поскольку вы не можете писать новые функции, пока старые не работают). Многие из факторов, влияющих на производительность, аналогичны тем, которые используются для «Усилий по обучению» — например, документация, сообщество, опыт программирования и т. д. — другие факторы включают в себя:
  <ul>
   <li><em>Назначение / происхождение фреймворка: </em>Некоторые веб-фреймворки изначально создавались для решения определённых типов проблем и работают лучше при создании веб-приложений с аналогичными ограничениями. Например, Django был создан для поддержки разработки газетного веб-сайта, поэтому он хорош для блогов и других сайтов, связанных с публикацией материалов. Flask, напротив, является гораздо более лёгкой средой и отлично подходит для создания веб-приложений, работающих на встроенных устройствах.</li>
   <li><em>Основанный на мнении сообщества против не имеющего мнения.</em> Фреймворк, основанный на мнении — это тот, в котором рекомендованы «лучшие» способы решения конкретной проблемы. Такие фреймворки, как правило, более продуктивны, когда вы пытаетесь решить общие проблемы, потому что они ведут вас в правильном направлении, однако иногда они менее гибки.</li>
   <li><em>Всё включено против разбирайтесь сами</em>: некоторые веб-фреймворки включают в себя инструменты / библиотеки, которые решают каждую проблему, которую их разработчики могут считать «по умолчанию», в то время как более лёгкие фреймворки ожидают, что веб-разработчики будут выбирать решение проблем из отдельных библиотек (например, Django из первых, в то время как Flask является примером очень лёгкого каркаса). Начать работу с фреймворками, которые включают в себя всё, часто легче, потому что «из коробки» у вас уже есть всё, что вам нужно, и есть вероятность, что они хорошо интегрированы и хорошо документированы. Однако, если меньший фреймворк имеет всё, что вам (когда-либо) понадобится, он может работать в более стеснённых условиях и будет иметь меньший и более простой набор вещей для изучения.</li>
   <li><em>Поощряет ли платформа хорошие практики разработки или нет: </em>например, фреймворк, который поощряет архитектуру Model-View-Controller, разделяющую код на логические функции, приведёт к более поддерживаемому коду, чем тот, который не ожидает этого от разработчиков. Аналогично дизайн фреймворка может оказать большое влияние на то, насколько легко тестировать и повторно использовать код.</li>
  </ul>
 </li>
 <li><strong>Производительность фреймворка / языка программирования:</strong> Обычно «скорость» не является самым значимым критерием при выборе, потому что даже относительно медленные среды выполнения, такие как Python, более чем «достаточно хороши» для сайтов среднего размера, работающих на умеренном оборудовании. Ожидаемым плюсам скорости другого языка, например C++ или JavaScript, могут быть противопоставлены минусы в виде затрат на его изучение и обслуживание. </li>
 <li><strong>Поддержка кеширования:</strong> По мере того, как ваш сайт становится более успешным, вы можете столкнуться с тем, что он больше не справляется с количеством запросов, которые получает, когда пользователи им пользуются. На этом этапе вы можете рассмотреть возможность добавления поддержки кеширования. Кеширование — это оптимизация, при которой вы сохраняете весь веб-ответ или его часть так, чтобы его не нужно было пересчитывать при последующих запросах. Возврат кешированного ответа гораздо быстрее, чем его вычисление. Кеширование может быть реализовано в вашем коде или на сервере (см. <a href="https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%80%D0%B0%D1%82%D0%BD%D1%8B%D0%B9_%D0%BF%D1%80%D0%BE%D0%BA%D1%81%D0%B8">обратный прокси</a>). Веб-фреймворки будут иметь разные уровни поддержки для определения того, какой контент можно кешировать.</li>
 <li><strong>Масштабируемость.</strong> Как только ваш веб-сайт станет фантастически успешным, вы исчерпаете преимущества кеширования и даже достигнете пределов <em>вертикального масштабирования</em> (запуска веб-приложения на более мощном оборудовании). На этом этапе вам может потребоваться <em>масштабировать горизонтально</em> (разделить нагрузку, распределяя ваш сайт между несколькими веб-серверами и базами данных) или масштабировать «географически», потому что некоторые из ваших клиентов находятся далеко от вашего сервера. Веб-фреймворк, который вы выберете, может существенно повлиять на то, насколько легко масштабировать ваш сайт.</li>
 <li><strong>Веб-безопасность.</strong> Некоторые веб-фреймворки предоставляют лучшую поддержку для обработки распространённых веб-атак. Например, Django очищает весь пользовательский ввод от HTML-шаблонов, чтобы введённый пользователем JavaScript не мог быть запущен. Другие платформы предоставляют аналогичную защиту, но она не всегда включена по умолчанию.</li>
</ul>

<p>Существует также много других возможных влияющих факторов, включая вопросы лицензирования, зависимость от того, находится ли фреймворк в процессе активной разработки и т. д.</p>

<p>Если вы абсолютный новичок в программировании, вы, вероятно, выберете свою среду на основе «простоты обучения». В дополнение к «простоте использования» самого языка, ваши самые ценные ресурсы — это высококачественная документация / учебные пособия и активное сообщество, помогающее новым пользователям. Мы выбрали <a href="https://www.djangoproject.com/">Django</a> (Python) и <a href="http://expressjs.com/">Express</a> (Node/JavaScript) для написания наших примеров далее в курсе, главным образом потому, что они просты в освоении и имеют хорошую поддержку.</p>

<div class="note">
<p><strong>На заметку:</strong> Давайте перейдём к основным веб-сайтам для <a href="https://www.djangoproject.com/">Django</a> (Python) и <a href="http://expressjs.com/">Express</a> (Node/JavaScript) и ознакомимся с их документацией и сообществом.</p>

<ol>
 <li>Перейдите к основным сайтам (ссылки выше)

  <ul>
   <li>Нажмите на ссылки меню «Документация» (такие вещи, как «Документация, Руководство, Справочник по API, Начало работы»).</li>
   <li>Можете ли вы увидеть темы, показывающие, как настроить маршрутизацию URL, шаблоны и базы данных / модели?</li>
   <li>Понятны ли эти документы?</li>
  </ul>
 </li>
 <li>Перейдите к спискам рассылки для каждого сайта (доступно по ссылкам сообщества).
  <ul>
   <li>Сколько вопросов было опубликовано за последние несколько дней?</li>
   <li>У скольких есть ответы?</li>
   <li>Есть ли у них активное сообщество?</li>
  </ul>
 </li>
</ol>
</div>

<h2 id="Несколько_хороших_веб-фреймворков">Несколько хороших веб-фреймворков?</h2>

<p>Давайте продолжим и обсудим несколько конкретных серверных веб-фреймворков.</p>

<p>Фреймворки на стороне сервера, представленные ниже, представляют собой несколько самых популярных из доступных на момент написания. Все они имеют всё, что вам нужно для продуктивной работы — они с открытым исходным кодом, находятся в процессе активной разработки, имеют полные энтузиазма сообщества, создающие документацию и помогающие пользователям на форумах, и используются на большом количестве выдающихся веб-сайтов. Существует также много других замечательных серверных фреймворков, которые вы можете найти с помощью обычного поиска в Интернете.</p>

<div class="note">
<p><strong>На заметку:</strong> Описания взяты (частично) с веб-сайтов фреймворка!</p>
</div>

<h3 id="Django_Python">Django (Python)</h3>

<p><a href="https://www.djangoproject.com/">Django</a> — это веб-фреймворк высокого уровня на языке Python, который способствует быстрой разработке и чистому, прагматичному дизайну. Созданный опытными разработчиками, он берёт на себя большую часть хлопот веб-разработки, поэтому вы можете сосредоточиться на написании своего приложения без необходимости заново изобретать велосипед. Он бесплатен для использования и имеет открытый исходный код.</p>

<p>Django следует философии «Всё включено» и предоставляет практически всё, что большинство разработчиков может пожелать «из коробки». Поскольку всё включено, всё работает вместе, следует последовательным принципам проектирования и имеет обширную и актуальную документацию. Он также быстр, безопасен и очень масштабируем. Основанный на Python, код Django легко читать и поддерживать.</p>

<p>Популярные сайты, использующие Django (с домашней страницы Django), включают в себя: Disqus, Instagram, Knight Foundation, MacArthur Foundation, Mozilla, National Geographic, Open Knowledge Foundation, Pinterest, Open Stack.</p>

<h3 id="Flask_Python">Flask (Python)</h3>

<p><a href="http://flask.pocoo.org/">Flask</a> — это микрофреймворк для Python.</p>

<p>И хотя Flask минималистичен, он может создавать серьёзные веб-сайты из коробки. Он содержит сервер разработки и отладчик, а также поддерживает шаблоны <a href="https://github.com/pallets/jinja">Jinja2</a>, безопасные файлы cookie, <a href="https://ru.wikipedia.org/wiki/%D0%9C%D0%BE%D0%B4%D1%83%D0%BB%D1%8C%D0%BD%D0%BE%D0%B5_%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">модульное тестирование</a> и диспетчеризацию запросов <a href="http://www.restapitutorial.com/lessons/restfulresourcenaming.html">RESTful</a>. У него хорошая документация и активное сообщество.</p>

<p>Flask стал чрезвычайно популярным, особенно для разработчиков, которым необходимо предоставлять веб-сервисы в небольших системах с ограниченными ресурсами (например, запуск веб-сервера на <a href="https://www.raspberrypi.org/">Raspberry Pi</a>, <a href="https://www.raspberrypi.org/">контроллеры Drone</a> и т. п.).</p>

<h3 id="Express_Node.jsJavaScript">Express (Node.js/JavaScript)</h3>

<p><a href="http://expressjs.com/">Express</a> — быстрый, непринуждённый, гибкий и минималистский веб-фреймворк для <a href="https://nodejs.org/en/">Node.js</a> (node — это серверная среда для запуска JavaScript). Он обеспечивает надёжный набор функций для веб и мобильных приложений и предоставляет полезные HTTP-утилиты и <a href="/en-US/docs/Glossary/Middleware">middleware</a> (промежуточные интерфейсы).</p>

<p>Express чрезвычайно популярен, частично потому, что он облегчает миграцию клиентских веб-программистов JavaScript в разработку на стороне сервера, а частично потому, что он ресурсоэффективен (базовая среда узлов использует лёгкую многозадачность в потоке, а не порождает отдельные процессы для каждого новый веб-запроса).</p>

<p>Поскольку Express является минималистским веб-фреймворком, он не включает в себя все компоненты, которые вы, возможно, захотите использовать (например, доступ к базе данных и поддержка пользователей и сеансов предоставляются через независимые библиотеки). Есть много отличных независимых компонентов, но иногда бывает сложно решить, какой из них лучше всего подходит для конкретной цели! </p>

<p>На Express основаны многие популярные серверные фреймворки, а также фреймворки полного цикла (которые включают как серверную, так и клиентскую часть), в числе которых <a href="http://feathersjs.com/">Feathers</a>, <a href="https://www.itemsapi.com/">ItemsAPI</a>, <a href="http://keystonejs.com/">KeystoneJS</a>, <a href="http://krakenjs.com/">Kraken</a>, <a href="http://loopback.io/">LoopBack</a>, <a href="http://mean.io/">MEAN</a> и <a href="http://sailsjs.org/">Sails</a>.</p>

<p>Express используют многие крупные компании, в том числе: Uber, Accenture, IBM и т. д. (список приведён <a href="http://expressjs.com/en/resources/companies-using-express.html">здесь</a>).</p>

<h3 id="Ruby_on_Rails_Ruby">Ruby on Rails (Ruby)</h3>

<p><a href="http://rubyonrails.org/">Rails</a> (обычно именуется «Ruby on Rails») — это веб-фреймворк, написанный для языка программирования Ruby.</p>

<p>Rails следует очень похожей философии дизайна на Django. Как и Django, он предоставляет стандартные механизмы для маршрутизации URL-адресов, доступа к данным из базы данных, генерации HTML из шаблонов и форматирования таких данных как {{glossary ("JSON")}} или {{glossary ("XML")}}. Им точно так же поощряется использование шаблонов проектирования, таких как DRY («не повторяйте себя» — пишите код только один раз, если это возможно), MVC (модель-представление-контроллер) и ряд других.</p>

<p>Конечно, в них существует и много различий, которые связаны с конкретными проектными решениями и природой самих языков.</p>
<p>Rails использовался для крупных сайтов, в том числе: <a href="https://basecamp.com/">Basecamp</a>, <a href="https://github.com/">GitHub</a>, <a href="https://shopify.com/">Shopify</a>, <a href="https://airbnb.com/">Airbnb</a>, <a href="https://twitch.tv/">Twitch</a>, <a href="https://soundcloud.com/">SoundCloud</a>, <a href="https://hulu.com/">Hulu</a>, <a href="https://zendesk.com/">Zendesk</a>, <a href="https://square.com/">Square</a>, <a href="https://highrisehq.com/">Highrise</a>.</p>

<h3 id="ASP.NET">ASP.NET</h3>

<p><a href="http://www.asp.net/">ASP.NET</a> — это веб-фреймворк с открытым исходным кодом, разработанный Microsoft для создания современных веб-приложений и сервисов. С ASP.NET вы можете быстро создавать веб-сайты на основе HTML, CSS и JavaScript, масштабировать их для использования миллионами пользователей и легко добавлять более сложные возможности, такие как веб-API, формы поверх данных или коммуникации в режиме реального времени.</p>

<p>Одним из отличий ASP.NET является то, что он построен на <a href="https://ru.wikipedia.org/wiki/Common_Language_Runtime">Common Language Runtime</a> (CLR, «общеязыковая исполняющая среда»), что позволяет программистам писать код ASP.NET с использованием любого поддерживаемого языка .NET (C#, Visual Basic и т. п.). Как и многие продукты Microsoft, он обладает отличными инструментами (часто бесплатными), активным сообществом разработчиков и хорошо написанной документацией.</p>

<p>ASP.NET используется Microsoft, Xbox.com, Stack Overflow и многими другими.</p>

<h3 id="Mojolicious_Perl">Mojolicious (Perl)</h3>

<p><a href="http://mojolicious.org/">Mojolicious</a> — это веб-фреймворк следующего поколения для языка программирования Perl.</p>

<p>Ещё в первые дни Интернета многие люди изучали Perl из-за замечательной библиотеки Perl под названием <a href="https://metacpan.org/module/CGI">CGI</a>. Язык позволял довольно просто начать, не зная многого о языке, и был достаточно мощным, чтобы вы продолжали работу. Mojolicious реализует эту идею, используя новейшие технологии.</p>

<p>Некоторые из функций, предоставляемых Mojolicious:</p>

<ul>
 <li>веб-инфраструктура в режиме реального времени, позволяющая легко превращать отдельные файловые прототипы в хорошо структурированные веб-приложения MVC.</li>
 <li>RESTful маршруты, плагины, команды, шаблоны Perl-ish, согласование контента, управление сеансами, проверка форм, структура тестирования, статический файловый сервер, обнаружение CGI/<a href="http://plackperl.org/">PSGI</a>, первоклассная поддержка Unicode.</li>
 <li>Реализация полного стека HTTP и WebSocket клиент/сервер с IPv6, TLS, SNI, IDNA, HTTP/SOCKS5 прокси, сокет домена UNIX, Comet (длинный опрос), поддержка активности, пул соединений, тайм-аут, cookie, поддержка нескольких частей и сжатия gzip.</li>
 <li>Парсеры и генераторы JSON и HTML/XML с поддержкой селекторов CSS.</li>
 <li>Очень чистый, портативный и объектно-ориентированный Perl API без скрытой магии.</li>
 <li>Свежий код, основанный на многолетнем опыте, бесплатный и с открытым исходным кодом.</li>
</ul>

<h2 id="Резюме">Резюме</h2>

<p>Эта статья показала, что веб-фреймворки могут упростить разработку и поддержку кода на стороне сервера. Она также предоставила общий обзор нескольких популярных платформ и обсудила критерии выбора платформы веб-приложений. Теперь у вас должно быть хотя бы представление о том, как выбрать веб-фреймворк для собственной разработки на стороне сервера. Если нет, то не беспокойтесь — позже в курсе мы дадим вам подробные учебники по Django и Express, чтобы дать вам некоторый опыт работы с веб-фреймворком. </p>

<p>Для следующей статьи в этом модуле мы немного изменим направление и рассмотрим веб-безопасность.</p>

<p>{{PreviousMenuNext("Learn/Server-side/First_steps/Client-Server_overview", "Learn/Server-side/First_steps/Website_security", "Learn/Server-side/First_steps")}}</p>

<h2 id="В_этом_модуле">В этом модуле</h2>

<ul>
 <li><a href="/ru/docs/Learn/Server-side/First_steps/Introduction">Introduction to the server side</a></li>
 <li><a href="/en-US/docs/Learn/Server-side/First_steps/Client-Server_overview">Client-Server overview</a></li>
 <li><a href="/en-US/docs/Learn/Server-side/First_steps/Web_frameworks">Server-side web frameworks</a></li>
 <li><a href="/en-US/docs/Learn/Server-side/First_steps/Website_security">Website security</a></li>
</ul>
