---
title: Битовые операции
slug: >-
  conflicting/Web/JavaScript/Reference/Operators_7c8eb9475d97a4a734c5991857698560
tags:
  - JavaScript
  - Оператор
translation_of: Web/JavaScript/Reference/Operators
translation_of_original: Web/JavaScript/Reference/Operators/Bitwise_Operators
original_slug: Web/JavaScript/Reference/Operators/Bitwise_Operators
---
<div>{{jsSidebar("Operators")}}</div>

<h2 id="Summary" name="Summary">Сводка</h2>

<p>Битовые операции обращаются со своими операндами как с 32-х разрядными последовательностями нулей и единиц, а не как с десятичными, восьмеричными или шестнадцатиричными числами. К примеру десятичное число 9 в двоичном представлении будет выглядеть как 1001. Битовые операции производят свои преобразования именно с двоичным представлением числа, но возвращают стандартные числовые значения языка JavaScript.</p>

<table class="fullwidth-table">
 <tbody>
  <tr>
   <td class="header" colspan="2">Операторы</td>
  </tr>
  <tr>
   <td>Реализованы в:</td>
   <td>JavaScript 1.0</td>
  </tr>
  <tr>
   <td>Версия ECMA:</td>
   <td>ECMA-262</td>
  </tr>
 </tbody>
</table>

<p>Следующая таблица содержит сводные данные о битовых операциях в JavaScript:</p>

<table class="fullwidth-table">
 <tbody>
  <tr>
   <th>Оператор</th>
   <th>Использование</th>
   <th>Описание</th>
  </tr>
  <tr>
   <td>Побитовое И</td>
   <td style="white-space: nowrap;"><code>a &amp; b</code></td>
   <td>Возвращает 1 в тех разрядах, которые у обоих операндов были равны 1.</td>
  </tr>
  <tr>
   <td>Побитовое ИЛИ</td>
   <td style="white-space: nowrap;"><code>a | b</code></td>
   <td>Возвращает 1 в тех разрядах, которые хотя бы у одного из операндов были равны 1.</td>
  </tr>
  <tr>
   <td>Побитовое исключающее ИЛИ</td>
   <td style="white-space: nowrap;"><code>a ^ b</code></td>
   <td>Возвращает 1 в тех позициях, которые только у одного из операндов были равны 1.</td>
  </tr>
  <tr>
   <td>Побитовое НЕ</td>
   <td style="white-space: nowrap;"><code>~ a</code></td>
   <td>Инвертирует биты операнда.</td>
  </tr>
  <tr>
   <td>Сдвиг влево</td>
   <td style="white-space: nowrap;"><code>a &lt;&lt; b</code></td>
   <td>Сдвигает двоичное представление числа a на b разрядов влево заполняя освободившиеся справа разряды нулями.</td>
  </tr>
  <tr>
   <td>Арифметический сдвиг вправо</td>
   <td style="white-space: nowrap;"><code>a &gt;&gt; b</code></td>
   <td>Сдвигает двоичное представление числа a на b разрядов вправо. Освобождающиеся разряды заполняются  знаковым битом.</td>
  </tr>
  <tr>
   <td>Логический сдвиг вправо</td>
   <td style="white-space: nowrap;"><code>a &gt;&gt;&gt; b</code></td>
   <td>Сдвигает двоичное представление числа a на b разрядов вправо. Освобождающиеся разряды заполняются нулями.</td>
  </tr>
 </tbody>
</table>

<h3 id="Signed_32-bit_integers" name="Signed_32-bit_integers">Представление чисел (Signed 32-bit integers)</h3>

<p>Операнды всех битовых операций конвертируются в 32-х битовые целые со знаком представленные в дополнительном коде и с использованием порядка битов от "старшего к младшему". Порядок битов "от старшего к младшему" означает, что наиболее значимый бит (бит с наибольшим значением) находится слева если 32-х разрядное число представлено в виде горизонтальной линии (шкалы). Представление в дополнительном коде  означает, что отрицательное значение числа (например 5 и -5) получается путем инвертирования числа (операция "побитовое НЕ", также известное как "обратный код") и прибавления к нему единицы.</p>

<p>Возьмем, к примеру, число 314. Представим его в двоичном коде:</p>

<pre class="eval">00000000000000000000000100111010
</pre>

<p>Следующая строка представляет собой его обратный код или ~314:</p>

<pre class="eval">11111111111111111111111011000101
</pre>

<p>Прибавив к нему единицу, мы получаем двоичное представление числа  -314, оно же 314 в дополнительном коде:</p>

<pre class="eval">11111111111111111111111011000110</pre>

<p>Дополнение до 2-х гарантирует нам, что у положительного числа самый левый бит равен 0, в то время как у отрицательного он равен 1. Он зовется <em>знаковым битом</em>.</p>

<p><br>
 Число 0 есть число, у которого во ввсех битовых позициях записаны нули.</p>

<pre class="line-numbers  language-html"><code class="language-html">0 (base 10) = 00000000000000000000000000000000 </code></pre>

<p>Число -1 есть число, у которого во всех битовых позициях записаны единицы.</p>

<pre class="line-numbers  language-html"><code class="language-html">-1 (base 10) = 11111111111111111111111111111111 </code></pre>

<p>Число <code>-2147483648</code> (в шестнадцатиричной системе счисления: <code>-0x80000000</code>) - это вещественное число, которое состоит только из 0, заисключением самого первого слева, который есть 1 (отвечает за знак числа).</p>

<pre class="line-numbers  language-html"><code class="language-html">-2147483648 (base 10) = 10000000000000000000000000000000</code></pre>

<p>Число <code>2147483648</code> (в шестнадцатиричной системе счисления: <code>0x80000000</code>) - это вещественное число, которое состоит только из 1, заисключением самого первого слева, который есть 0 (отвечает за знак числа).</p>

<pre class="line-numbers  language-html"><code class="language-html">2147483647 (base 10) = 01111111111111111111111111111111</code></pre>

<p><code>-2147483648 и 2147483647 - это самое минимальное и самое максимальное числа, которые можно представить в 32 разрядной ячейке памяти.</code></p>

<h2 id="Bitwise_logical_operators" name="Bitwise_logical_operators">Побитовые логические операции</h2>

<p>Побитовые логические операции работают следующим образом:</p>

<ul>
 <li>Операнды конвертируются в 32-х битовые числа отображаемые последовательностью нулей и единиц. Числа более 32-х бит теряют свои старшие биты. Например:</li>
</ul>

<pre class="line-numbers  language-html"><code class="language-html">До:         11100110111110100000000000000110000000000001
После:      10100000000000000110000000000001</code>
</pre>

<ul>
 <li>Каждый бит первого операнда считается парным соотвествующему биту второго операнда. Первый бит - первому, второй второму итд.</li>
 <li>Операция применяется к каждой паре битов, and the result is constructed bitwise.</li>
</ul>

<h3 id="_.28Bitwise_AND.29" name="&amp;_.28Bitwise_AND.29">&amp; (Побитовое AND)</h3>

<p>Производит побитовое И над каждой парой битов. Операция <code>a</code> AND <code>b</code> веренет 1 если только и <code>a</code> и <code>b</code> равны 1. Таблица истинности для этой операции выглядит так:</p>

<table class="standard-table">
 <tbody>
  <tr>
   <td class="header">a</td>
   <td class="header">b</td>
   <td class="header">a AND b</td>
  </tr>
  <tr>
   <td>0</td>
   <td>0</td>
   <td>0</td>
  </tr>
  <tr>
   <td>0</td>
   <td>1</td>
   <td>0</td>
  </tr>
  <tr>
   <td>1</td>
   <td>0</td>
   <td>0</td>
  </tr>
  <tr>
   <td>1</td>
   <td>1</td>
   <td>1</td>
  </tr>
 </tbody>
</table>

<p>Пример:</p>

<pre class="eval">     9 (основание 10) = 00000000000000000000000000001001 (основание 2)
    14 (основание 10) = 00000000000000000000000000001110 (основание 2)
                   --------------------------------
14 &amp; 9 (основание 10) = 00000000000000000000000000001000 (осн. 2) = 8 (осн. 10)
</pre>

<p>Побитовое  AND любого числа x с нулем вернет 0.</p>

<p>Побитовое  AND любого числа x с числом -1 вернет х.</p>

<h3 id="_.28Bitwise_OR.29" name="|_.28Bitwise_OR.29">| (Побитовое OR)</h3>

<p style="margin-top: 0px; margin-right: 0px; margin-bottom: 1.7em; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px;">Производит побитовое ИЛИ над каждой парой битов. Операция <code style="color: rgb(37, 34, 29); font-weight: inherit;">a</code> OR <code style="color: rgb(37, 34, 29); font-weight: inherit;">b</code> веренет 1 если <code style="color: rgb(37, 34, 29); font-weight: inherit;">a</code> или <code style="color: rgb(37, 34, 29); font-weight: inherit;">b</code> равны 1. Таблица истинности для этой операции выглядит так:</p>

<table class="standard-table">
 <tbody>
  <tr>
   <td class="header">a</td>
   <td class="header">b</td>
   <td class="header">a OR b</td>
  </tr>
  <tr>
   <td>0</td>
   <td>0</td>
   <td>0</td>
  </tr>
  <tr>
   <td>0</td>
   <td>1</td>
   <td>1</td>
  </tr>
  <tr>
   <td>1</td>
   <td>0</td>
   <td>1</td>
  </tr>
  <tr>
   <td>1</td>
   <td>1</td>
   <td>1</td>
  </tr>
 </tbody>
</table>

<pre class="eval">Пример:

9 (осн. 10) = 00000000000000000000000000001001 (осн. 2)
14 (осн. 10) = 00000000000000000000000000001110 (осн. 2)
                   --------------------------------
14 | 9 (осн. 10) = 00000000000000000000000000001111 (осн. 2) = 15 (осн. 10)
</pre>

<p>Побитовое OR любого числа x c нулем вернет x.</p>

<p>Побитовое OR любого числа x с числом -1 вернет -1.</p>

<h3 id=".5E_.28Bitwise_XOR.29" name=".5E_.28Bitwise_XOR.29">^ (Побитовое XOR)</h3>

<p>Производит побитовое XOR над каждой парой битов. Операция <code>a</code> XOR <code>b</code> вернет 1 если <code>a</code>  и <code>b</code> различны. Таблица истинности для этой операции выглядит так:</p>

<table class="standard-table">
 <tbody>
  <tr>
   <td class="header">a</td>
   <td class="header">b</td>
   <td class="header">a XOR b</td>
  </tr>
  <tr>
   <td>0</td>
   <td>0</td>
   <td>0</td>
  </tr>
  <tr>
   <td>0</td>
   <td>1</td>
   <td>1</td>
  </tr>
  <tr>
   <td>1</td>
   <td>0</td>
   <td>1</td>
  </tr>
  <tr>
   <td>1</td>
   <td>1</td>
   <td>0</td>
  </tr>
 </tbody>
</table>

<p>Пример:</p>

<pre class="eval">     9 (осн. 10) = 00000000000000000000000000001001 (осн. 2)
    14 (осн. 10) = 00000000000000000000000000001110 (осн. 2)
                   --------------------------------
14 ^ 9 (осн. 10) = 00000000000000000000000000000111 (осн. 2) = 7 (осн. 10)
</pre>

<p>Побитовое XOR любого числа x c нулем вернет x.</p>

<p>Побитовое XOR любого числа x c числом -1 вернет ~x.</p>

<h3 id=".7E_.28Bitwise_NOT.29" name=".7E_.28Bitwise_NOT.29">~ (Побитовое NOT)</h3>

<p>Производит операцию NOT над каждым битом. NOT <code>a</code> вернет побитово инвертированное значение (обратный код) операнда. Таблица истинности для этой операции выглядит так:</p>

<table class="standard-table">
 <tbody>
  <tr>
   <td class="header">a</td>
   <td class="header">NOT a</td>
  </tr>
  <tr>
   <td>0</td>
   <td>1</td>
  </tr>
  <tr>
   <td>1</td>
   <td>0</td>
  </tr>
 </tbody>
</table>

<p>Пример:</p>

<pre class="eval"> 9 (осн. 10) = 00000000000000000000000000001001 (осн. 2)
               --------------------------------
~9 (осн. 10) = 11111111111111111111111111110110 (осн. 2) = -10 (осн. 10)
</pre>

<p>Побитовое NOT любого числа x вернет -(x + 1). Например, ~5 вернет -6.</p>

<h2 id="Bitwise_shift_operators" name="Bitwise_shift_operators">Побитовые операции сдвига</h2>

<p>Оператор побитового сдвига принимает в себя два операнда: первый - величина, которую сдвигают, второй - число позиций, на которое сдвигаются биты первого операнда. Направление сдвига зависит от используемого оператора.</p>

<p>Операторы сдвига конвертируют операнды в 32-ух разрядные числа с порядком байтов от старшего к младшему, а результат возвращает того же типа, что и левый операнд.</p>

<h3 id=".3C.3C_.28Left_shift.29" name=".3C.3C_.28Left_shift.29">&lt;&lt; (Сдвиг влево)</h3>

<p>Оператор побитового сдвига влево сдвигает первый операнд на заданное число битов влево. Лишние биты отбрасываются.</p>

<p>Например, <code>9 &lt;&lt; 2</code> в результате даст 36:</p>

<pre class="eval">     9 (осн. 10): 00000000000000000000000000001001 (осн. 2)
                  --------------------------------
9 &lt;&lt; 2 (осн. 10): 00000000000000000000000000100100 (осн. 2) = 36 (осн. 10)


</pre>

<p>Побитовй сдвиг любого числа <code>x</code> влево на <code>y</code> бит в результате дает  <code>x * 2 ** y</code>.</p>

<h3 id=".3E.3E_.28Sign-propagating_right_shift.29" name=".3E.3E_.28Sign-propagating_right_shift.29">&gt;&gt; (Сдвиг вправо с сохранением знака)</h3>

<p>Оператор побитового сдвига вправо сдвигает первый операнд на заданное число битов вправо. Лишние биты отбрасываются. Слева добавляется заданное число битов равных первому биту исходного числа. Поскольку значение первого бита, определяющего знак числа, останется неизменным, знак получившегося результата будет таким же как у первого аргумента. Отсюда "с сохранением знака" в названи.</p>

<p>Например, <code>9 &gt;&gt; 2</code> в результате даст 2:</p>

<pre class="eval">     9 (осн. 10): 00000000000000000000000000001001 (осн. 2)
                  --------------------------------
9 &gt;&gt; 2 (осн. 10): 00000000000000000000000000000010 (осн. 2) = 2 (осн. 10)
</pre>

<p>Аналогично, <code>-9 &gt;&gt; 2</code> даст в результате  -3, так как знак сохранен:</p>

<pre class="eval">     -9 (осн. 10): 11111111111111111111111111110111 (осн. 2)
                   --------------------------------
-9 &gt;&gt; 2 (осн. 10): 11111111111111111111111111111101 (осн. 2) = -3 (осн. 10)
</pre>

<h3 id=".3E.3E_.28Sign-propagating_right_shift.29" name=".3E.3E_.28Sign-propagating_right_shift.29">&gt;&gt;&gt; (Сдвиг вправо с заполнением нулями)</h3>

<p>Оператор побитового сдвига вправо сдвигает первый операнд на заданное число битов вправо. Лишние биты отбрасываются. Слева добавляется заданное число нулевых битов. Поскольку значение первого бита, определяющего знак числа, становится нулевым, результатом операции всегда будет положительное число.</p>

<p>Для положительных чисел, сдвиг вправо с сохранением знака и сдвиг вправо с заполнением нулями эквивалентны.</p>

<p>Например, <code>9 &gt;&gt;&gt; 2</code> дает в результате 2, как и <code>9 &gt;&gt; 2</code>:</p>

<pre class="eval">      9 (осн. 10): 00000000000000000000000000001001 (осн. 2)
                   --------------------------------
9 &gt;&gt;&gt; 2 (осн. 10): 00000000000000000000000000000010 (осн. 2) = 2 (осн. 10)
</pre>

<p>Важно отметить, что для отрицательных результаты будут разными. Например, <code>-9 &gt;&gt;&gt; 2</code> дает в результате 1073741821, что отличается от результата <code>-9 &gt;&gt; 2</code> (равно -3):</p>

<pre class="eval">      -9 (осн. 10): 11111111111111111111111111110111 (осн. 2)
                    --------------------------------
-9 &gt;&gt;&gt; 2 (осн. 10): 00111111111111111111111111111101 (осн. 2) = 1073741821 (осн. 10)
</pre>

<h3 id="Examples" name="Examples">Примеры</h3>

<h4 id="Example_Flags_and_bitmasks" name="Example:_Flags_and_bitmasks">Пример: флаги и битовые маски</h4>

<p>Побитовые логические операторы часто используются для создания, обработки и чтения последовательности флагов, которые осуществляются также, как и двоичные переменные. Переменные могут быть использованы вместо этих последовательностей, но двоичные флаги занимают гораздо меньше памяти (в 32 разрядной ячейке памяти).</p>

<p>Предположим, существует 4 флага:</p>

<ul>
 <li>флаг A: у нас есть проблема с муравьями</li>
 <li>флаг B: у нас есть летучая мышь</li>
 <li>флаг C: у нас есть кошка</li>
 <li>флаг D: у нас есть утка</li>
</ul>

<p>Эти флаги представлены последовательностью битов: DCBA. Считается, что флаг <em>установлен (the flag is set)</em>, если его значение равно 1. Флаг <em>сброшен (the flag is cleared)</em>, если его значение равно 0. Предположим, что переменная <code>flags</code> содержит двоичное значение 0101:</p>

<pre class="eval">var flags = 0x5;   // двоичное 0101
</pre>

<p>Из этого значения следует:</p>

<ul>
 <li>флаг A установлен (у нас есть проблема с муравьями);</li>
 <li>флаг B сброшен (у нас нет летучей мыши);</li>
 <li>флаг C установлен  (у нас есть кошка);</li>
 <li>флаг D сброшен (у нас нет утки);</li>
</ul>

<p>Так как битовые операторы 32-битные, то 0101 в действительности представлено значением 00000000000000000000000000000101, но ведущие нули могут быть опущены, потому, что не содержат значимой информации.</p>

<p><em>Битовая маска, </em>это последовательность битов, которая позволяет манипулировать и/или считывать значения флагов. Обычно для каждого флага задаётся "примитивная" битовая маска:</p>

<pre class="eval">var FLAG_A = 0x1; // 0001
var FLAG_B = 0x2; // 0010
var FLAG_C = 0x4; // 0100
var FLAG_D = 0x8; // 1000
</pre>

<p>New bitmasks can be created by using the bitwise logical operators on these primitive bitmasks. For example, the bitmask 1011 can be created by ORing FLAG_A, FLAG_B, and FLAG_D:</p>

<pre class="eval">var mask = FLAG_A | FLAG_B | FLAG_D; // 0001 | 0010 | 1000 =&gt; 1011
</pre>

<p>Individual flag values can be extracted by ANDing them with a bitmask, where each bit with the value of one will "extract" the corresponding flag. The bitmask <em>masks</em> out the non-relevant flags by ANDing with zeros (hence the term "bitmask"). For example, the bitmask 0100 can be used to see if flag C is set:</p>

<pre class="eval">// if we own a cat
if (flags &amp; FLAG_C) { // 0101 &amp; 0100 =&gt; 0100 =&gt; true
   // do stuff
}
</pre>

<p>A bitmask with multiple set flags acts like an "either/or". For example, the following two are equivalent:</p>

<pre class="eval">// if we own a bat or we own a cat
if ((flags &amp; FLAG_B) || (flags &amp; FLAG_C)) { // (0101 &amp; 0010) || (0101 &amp; 0100) =&gt; 0000 || 0100 =&gt; true
   // do stuff
}
</pre>

<pre class="eval">// if we own a bat or cat
var mask = FLAG_B | FLAG_C; // 0010 | 0100 =&gt; 0110
if (flags &amp; mask) { // 0101 &amp; 0110 =&gt; 0100 =&gt; true
   // do stuff
}
</pre>

<p>Flags can be set by ORing them with a bitmask, where each bit with the value one will set the corresponding flag, if that flag isn't already set. For example, the bitmask 1010 can be used to set flags C and D:</p>

<pre class="eval">// yes, we own a cat and a duck
var mask = FLAG_C | FLAG_D; // 0100 | 1000 =&gt; 1100
flags |= mask;   // 0101 | 1100 =&gt; 1101
</pre>

<p>Flags can be cleared by ANDing them with a bitmask, where each bit with the value zero will clear the corresponding flag, if it isn't already cleared. This bitmask can be created by NOTing primitive bitmasks. For example, the bitmask 1010 can be used to clear flags A and C:</p>

<pre class="eval">// no, we don't neither have an ant problem nor own a cat
var mask = ~(FLAG_A | FLAG_C); // ~0101 =&gt; 1010
flags &amp;= mask;   // 1101 &amp; 1010 =&gt; 1000
</pre>

<p>The mask could also have been created with <code>~FLAG_A &amp; ~FLAG_C</code> (De Morgan's law):</p>

<pre class="eval">// no, we don't have an ant problem, and we don't own a cat
var mask = ~FLAG_A &amp; ~FLAG_C;
flags &amp;= mask;   // 1101 &amp; 1010 =&gt; 1000
</pre>

<p>Flags can be toggled by XORing them with a bitmask, where each bit with the value one will toggle the corresponding flag. For example, the bitmask 0110 can be used to toggle flags B and C:</p>

<pre class="eval">// if we didn't have a bat, we have one now, and if we did have one, bye-bye bat
// same thing for cats
var mask = FLAG_B | FLAG_C;
flags = flags ^ mask;   // 1100 ^ 0110 =&gt; 1010
</pre>

<p>Finally, the flags can all be flipped with the NOT operator:</p>

<pre class="eval">// entering parallel universe...
flags = ~flags;    // ~1010 =&gt; 0101

</pre>

<h2 id="Совместимость_с_браузерами">Совместимость с браузерами</h2>

<p>{{ CompatibilityTable() }}</p>

<div id="compat-desktop">
<table class="compat-table">
 <tbody>
  <tr>
   <th>Возможность</th>
   <th>Chrome</th>
   <th>Firefox (Gecko)</th>
   <th>Internet Explorer</th>
   <th>Opera</th>
   <th>Safari</th>
  </tr>
  <tr>
   <td><a href="#Bitwise_NOT">Битовый NOT (<code>~</code>)</a></td>
   <td>{{ CompatVersionUnknown() }}</td>
   <td>{{ CompatVersionUnknown() }}</td>
   <td>{{ CompatVersionUnknown() }}</td>
   <td>{{ CompatVersionUnknown() }}</td>
   <td>{{ CompatVersionUnknown() }}</td>
  </tr>
  <tr>
   <td><a href="#Bitwise_AND">Битовый AND (<code>&amp;</code>)</a></td>
   <td>{{ CompatVersionUnknown() }}</td>
   <td>{{ CompatVersionUnknown() }}</td>
   <td>{{ CompatVersionUnknown() }}</td>
   <td>{{ CompatVersionUnknown() }}</td>
   <td>{{ CompatVersionUnknown() }}</td>
  </tr>
  <tr>
   <td><a href="#Bitwise_OR">Битовый OR (<code>|</code>)</a></td>
   <td>{{ CompatVersionUnknown() }}</td>
   <td>{{ CompatVersionUnknown() }}</td>
   <td>{{ CompatVersionUnknown() }}</td>
   <td>{{ CompatVersionUnknown() }}</td>
   <td>{{ CompatVersionUnknown() }}</td>
  </tr>
  <tr>
   <td><a href="#Bitwise_XOR">Битовый XOR (<code>^</code>)</a></td>
   <td>{{ CompatVersionUnknown() }}</td>
   <td>{{ CompatVersionUnknown() }}</td>
   <td>{{ CompatVersionUnknown() }}</td>
   <td>{{ CompatVersionUnknown() }}</td>
   <td>{{ CompatVersionUnknown() }}</td>
  </tr>
  <tr>
   <td><a href="#Left_shift">Сдвиг влево (<code>&lt;&lt;</code>)</a></td>
   <td>{{ CompatVersionUnknown() }}</td>
   <td>{{ CompatVersionUnknown() }}</td>
   <td>{{ CompatVersionUnknown() }}</td>
   <td>{{ CompatVersionUnknown() }}</td>
   <td>{{ CompatVersionUnknown() }}</td>
  </tr>
  <tr>
   <td><a href="#Right_shift">Сдвиг вправо (<code>&gt;&gt;</code>)</a></td>
   <td>{{ CompatVersionUnknown() }}</td>
   <td>{{ CompatVersionUnknown() }}</td>
   <td>{{ CompatVersionUnknown() }}</td>
   <td>{{ CompatVersionUnknown() }}</td>
   <td>{{ CompatVersionUnknown() }}</td>
  </tr>
  <tr>
   <td><a href="#Unsigned_right_shift">Беззнаковый сдвиг вправо (<code>&gt;&gt;&gt;</code>)</a></td>
   <td>{{ CompatVersionUnknown() }}</td>
   <td>{{ CompatVersionUnknown() }}</td>
   <td>{{ CompatVersionUnknown() }}</td>
   <td>{{ CompatVersionUnknown() }}</td>
   <td>{{ CompatVersionUnknown() }}</td>
  </tr>
 </tbody>
</table>
</div>

<div id="compat-mobile">
<table class="compat-table">
 <tbody>
  <tr>
   <th>Возможность</th>
   <th>Android</th>
   <th>Chrome for Android</th>
   <th>Firefox Mobile (Gecko)</th>
   <th>IE Mobile</th>
   <th>Opera Mobile</th>
   <th>Safari Mobile</th>
  </tr>
  <tr>
   <td><a href="#Bitwise_NOT">Битовый NOT (<code>~</code>)</a></td>
   <td>{{ CompatVersionUnknown() }}</td>
   <td>{{ CompatVersionUnknown() }}</td>
   <td>{{ CompatVersionUnknown() }}</td>
   <td>{{ CompatVersionUnknown() }}</td>
   <td>{{ CompatVersionUnknown() }}</td>
   <td>{{ CompatVersionUnknown() }}</td>
  </tr>
  <tr>
   <td><a href="#Bitwise_AND">Битовый AND (<code>&amp;</code>)</a></td>
   <td>{{ CompatVersionUnknown() }}</td>
   <td>{{ CompatVersionUnknown() }}</td>
   <td>{{ CompatVersionUnknown() }}</td>
   <td>{{ CompatVersionUnknown() }}</td>
   <td>{{ CompatVersionUnknown() }}</td>
   <td>{{ CompatVersionUnknown() }}</td>
  </tr>
  <tr>
   <td><a href="#Bitwise_OR">Битовый OR (<code>|</code>)</a></td>
   <td>{{ CompatVersionUnknown() }}</td>
   <td>{{ CompatVersionUnknown() }}</td>
   <td>{{ CompatVersionUnknown() }}</td>
   <td>{{ CompatVersionUnknown() }}</td>
   <td>{{ CompatVersionUnknown() }}</td>
   <td>{{ CompatVersionUnknown() }}</td>
  </tr>
  <tr>
   <td><a href="#Bitwise_XOR">Битовый XOR (<code>^</code>)</a></td>
   <td>{{ CompatVersionUnknown() }}</td>
   <td>{{ CompatVersionUnknown() }}</td>
   <td>{{ CompatVersionUnknown() }}</td>
   <td>{{ CompatVersionUnknown() }}</td>
   <td>{{ CompatVersionUnknown() }}</td>
   <td>{{ CompatVersionUnknown() }}</td>
  </tr>
  <tr>
   <td><a href="#Left_shift">Сдвиг влево (<code>&lt;&lt;</code>)</a></td>
   <td>{{ CompatVersionUnknown() }}</td>
   <td>{{ CompatVersionUnknown() }}</td>
   <td>{{ CompatVersionUnknown() }}</td>
   <td>{{ CompatVersionUnknown() }}</td>
   <td>{{ CompatVersionUnknown() }}</td>
   <td>{{ CompatVersionUnknown() }}</td>
  </tr>
  <tr>
   <td><a href="#Right_shift">Сдвиг вправо (<code>&gt;&gt;</code>)</a></td>
   <td>{{ CompatVersionUnknown() }}</td>
   <td>{{ CompatVersionUnknown() }}</td>
   <td>{{ CompatVersionUnknown() }}</td>
   <td>{{ CompatVersionUnknown() }}</td>
   <td>{{ CompatVersionUnknown() }}</td>
   <td>{{ CompatVersionUnknown() }}</td>
  </tr>
  <tr>
   <td><a href="#Unsigned_right_shift">Беззнаковый сдвиг вправо (<code>&gt;&gt;&gt;</code>)</a></td>
   <td>{{ CompatVersionUnknown() }}</td>
   <td>{{ CompatVersionUnknown() }}</td>
   <td>{{ CompatVersionUnknown() }}</td>
   <td>{{ CompatVersionUnknown() }}</td>
   <td>{{ CompatVersionUnknown() }}</td>
   <td>{{ CompatVersionUnknown() }}</td>
  </tr>
 </tbody>
</table>
</div>

<h2 id="See_also" name="See_also">Смотрите также</h2>

<ul>
 <li><a class="external" href="http://ru.wikipedia.org/wiki/%D0%91%D0%B8%D1%82%D0%BE%D0%B2%D1%8B%D0%B5_%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%B8" title="http://ru.wikipedia.org/wiki/Битовые_операции">Wikipedia Битовые операции</a></li>
 <li><a class="external" href="http://ru.wikipedia.org/wiki/%D0%94%D0%BE%D0%BF%D0%BE%D0%BB%D0%BD%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9_%D0%BA%D0%BE%D0%B4_(%D0%BF%D1%80%D0%B5%D0%B4%D1%81%D1%82%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_%D1%87%D0%B8%D1%81%D0%BB%D0%B0)" title="http://ru.wikipedia.org/wiki/Дополнительный_код_(представление_числа)">Wikipedia Дополнительный код</a></li>
 <li><a class="external" href="http://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%80%D0%B0%D1%82%D0%BD%D1%8B%D0%B9_%D0%BA%D0%BE%D0%B4_(%D0%BF%D1%80%D0%B5%D0%B4%D1%81%D1%82%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_%D1%87%D0%B8%D1%81%D0%BB%D0%B0)" title="http://ru.wikipedia.org/wiki/Обратный_код_(представление_числа)">Wikipedia Обратный код</a></li>
 <li><a href="/ru/docs/Web/JavaScript/Reference/Operators/Logical_Operators">Логические операции</a></li>
</ul>
