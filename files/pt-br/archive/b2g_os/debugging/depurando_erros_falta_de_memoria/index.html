---
title: Depurando erros de falta de memória no Firefox OS
slug: Archive/B2G_OS/Debugging/Depurando_erros_falta_de_memoria
tags:
  - B2G
  - Erros
  - Falta de Memória
  - Firefox OS
translation_of: Archive/B2G_OS/Debugging/Debugging_OOMs
---
<div class="summary">
 <p>Quando um dispositivo Firefox OS fica sem memória, os sistemas low-memory killer e low-memory notifications são executados para encerrar alguns processos e manter o sistema operacional funcionando. Quando o kernel encerra alguns processos que estavam rodando em segundo plano o comportamento assemelha-se a uma finalização inesperada do aplicativo que estava sendo executado. Esse artigo explica como compreender e depurar erros devido a falhas decorrentes de falta de memória.</p>
</div>
<div class="note">
 <p><strong>Nota</strong>: Se você não sabe ainda como situações com baixa memória são gerenciadas no Firefox OS, sugerimos você ler o artigo <a href="https://developer.mozilla.org/pt-BR/Firefox_OS/Platform/Out_of_memory_management_on_Firefox_OS">Gerenciamento de falha de memória no Firefox OS</a> antes de continuar a ler esse documento.</p>
</div>
<h2 id="Depurando_uma_falha_decorrente_de_Falta_de_Memória_(OOM_-_Out_Of_Memory_crash)">Depurando uma falha decorrente de Falta de Memória (OOM - Out Of Memory crash)</h2>
<p>Suponha que você tenha uma falha que possa ser reproduzida e suspeita que seja a causadora de falta de memória. Os passos a seguir farão você entender mais sobre o que está dando errado.</p>
<h3 id="Passo_1_Confirme_se_realmente_a_falha_é_devido_à_falta_de_memória">Passo 1: Confirme se realmente a falha é devido à falta de memória</h3>
<p>Primeiro, devemos garantir que a falha é devido ao fato do telefone estar sem memória disponível. Para fazer isso execute <code>adb shell dmesg</code>.  Se o aplicativo for enecerrado devido a falta de memória, você verá a seguinte resposta:</p>
<pre class="brush: bash">&lt;4&gt;[06-18 07:40:25.291] [2897: Notes+]send sigkill to 2897 (Notes+), adj 2, size 30625</pre>
<p>Essa linha indica que o aplicativo Notes+ (ID do processo 2897) foi encerrado e possuia <code>oom_adj 2</code>. O tamanho reportado aqui é em páginas, com 4kb cada. Dessa forma, nesse caso, o aplicativo Notes+ estava usando 30625 * 4kb = 120mb de memória.</p>
<h4 id="Digressão_se_não_for_falta_de_memória_(OOM)">Digressão: se não for falta de memória (OOM)</h4>
<p>Se a saída do comando <code>dmesg</code> não for a apresentada, provavelmente a falha não é devido à falta de memória.  your crash is likely not an OOM. O próximo passo na depuração da falha é utilizar o <code>gdb</code> ao processo de falha e conseguir um rastreamento, que pode ser feito dessa forma:</p>
<pre class="brush: bash">$ cd path/to/B2G/checkout
$ adb shell b2g-ps
# Note pid of the app that you're going to crash
$ ./run-gdb.sh attach &lt;pid&gt;
(gdb) continue
# crash the app
(gdb) bt</pre>
<p>Quando for reportar o bug, anexe o resultado obtido, bem como o resultado do comando <code>adb logcat</code>. Se a falha for devido a falta de memória, o rastreamento provavelmente não será interessante, poir a falha de falta de memória é disparada por um sinal enviado pelo kernel e não por uma falha de código que o processo executa.</p>
<h3 id="Passo_2_Coletar_relatórios_de_memória">Passo 2: Coletar relatórios de memória</h3>
<p>Depois de você ter se certificado que a falha é devido à falta de memória, o próximo passo é coletar relatório de memória do seu telefone antes da falha. Esse relatório nos ajudará a entender como a memória está sendo usada. Esta etapa é um pouco complicada, porque uma vez que aplicativo falhar, não há nenhuma maneira de coletar um relatório de memória desse processo. Também não há uma forma de disparar um relatório de memória quando o kernel tenta encerrar um processo — quando isso acontece é tarde demais.</p>
<p>Para extrair um relatório de memória do seu telefone, primeiramente atualize sua árvore de compilação a fim de obter a última versão da ferramenta que extrai o relatório. Observe que  <code>repo sync</code> não será suficiente; você deve executar <code>git fetch &amp;&amp; git merge</code> ou <code>git pull</code>:</p>
<pre class="brush: bash">$ cd path/to/B2G/checkout
$ git fetch origin
$ git merge --ff-only origin</pre>
<p>Agora execute a ferramenta para extrair o relatório:</p>
<pre class="brush: bash">$ tools/get_about_memory.py</pre>
<p>Uma vez que você conseguiu o relatório, você pode compactar o diretório (chamado <code>about-memory-N</code>) e anexá-lo a um bug. Mas novamente, isso somente será útil se você executar esse comando enquanto o aplicativo que você está monitorando estiver sendo executado e usando muita memória. Você tem algumas opções aqui:</p>
<h4 id="Passo_2_opção_1_Consiga_um_dispositivo_diferente">Passo 2, opção 1: Consiga um dispositivo diferente</h4>
<p>Geralmente a forma mais fácil é conseguir um dispositivo com mais memória. Você já sabe desde o passo 1 quanta memória o processo estava usando quando falhou, assim você pode simplesmente esperar até o processo utilizar perto desse valor e então pegar um relatório de memória. O aplicativo <code>b2g-info</code> mostrará quanta memória cada um dos diferentes processos B2G estavam usando. Você pode executar esse processo em um loop fazendo o seguinte:</p>
<pre class="brush: bash">$ adb shell 'while true; do b2g-info; sleep 1; done'</pre>
<p>Se <code>b2g-info</code> não está disponível no seu dispositivo, você pode usar <code>b2g-procrank</code>.</p>
<h4 id="Passo_2_opção_2_Dedo_mais_rápido">Passo 2, opção 2: Dedo mais rápido</h4>
<p>Se você não possui um dispositivo com mais memória RAM, você pode tentar executar <code>get_about_memory.py</code> no momento exatamente anterior ao aplicativo falhar. Você pode rodar <code>b2g-info</code> em um loop (como mostrado no item anterior) para descobrir quando executar <code>get_about_memory.py</code>. Executar um relatório de memória congela todos os processos por um pequeno momento, assim não é difícil extrair um relatório de memória antes do processo de falta de memória entrar em ação.</p>
<h4 id="Passo_2_opção_3_Use_um_pequeno_caso_de_teste">Passo 2, opção 3: Use um pequeno caso de teste</h4>
<p>Geralmente falhas de falta de memória ocorrem quando é feito algo como "carregar um arquivo de no mínimo X bytes no aplicativo".</p>
<p>Se o aplicativo falha muito rapidadmente com um caso de teste do tamanho X, você pode tentar executar um teste similar com o tamanho X/2 e capturar um relatório de memória após a execução do teste. O relatório pode nos dar valiosas dicas que definitivamente nos chamarão a atenção.</p>
<h4 id="Passo_2_opção_4_Execute_B2G_no_seu_desktop">Passo 2, opção 4: Execute B2G no seu desktop</h4>
<p>Se o que é ruim se tornar pior, você pode rodar o B2G no seu desktop, o que provavelmente possui muito mais memória que seu telefone FxOS. Isso é complicado porque B2G rodando num desktopo tem um comportamento diferente que quando roda num dispositivo.</p>
<p>Particularmente, B2G num desktop possui o multiprocessamento desabilitado por padrão. Ele realmente não funciona 100% em qualquer lugar, mas funciona de forma mais precisa no Linux e no Mac. (Verifique <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=923961">Bug 923961</a>, <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=914584">Bug 914584</a>, <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=891882">Bug 891882</a>). Você pode testar em seu desktop com o multiprocessamento desabilitado, mas em minha experiência muitos dos problemas relacionados ao uso de memória são causados por códigos de comunicação interprocessos, de modo que não vai necessariamente provocar o erro que você está vendo.</p>
<p>Também não é conveniente extrari relatórios de memória dos processos B2G no desktop. No Linux, você pode enviar o sinal 34 para o processo principal B2G que ele vai escrever relatórios no diretório <code>/tmp</code> com o seguinte nome: <code>memory-report-*.gz</code>.</p>
<p>Uma vantagem de utilizar o B2G desktop é que você pode usar suas ferramentas de depuração favoritas, como o aplicativo Instruments Activities do Mac OSX. Nós já tivemos muito sucesso no passado. Para coletar relatórios de memória usando esse utilitário do OSX, vá em "New -&gt; Mac OS X -&gt; Allocations". Inicie o b2g-desktop e você verá alguns processos "plugin-container" no utilitário Activity Monitor. Você necessitará de duas instâncias do Instruments: um para registrar as alocações no processo principal b2g e outro para registrar as alocações no aplicativo que você deseja analisar. Com os utiltários monitorando os processos execute o seu caso de teste.</p>
<p>Para analisar quanta memório seu aplicativo está utilizando, analise as árvores de chamadas. Marque "Invert Call Tree", o ordene por bytes usados. Isso irá mostrar qual parte do seu aplicativo usa mais memória. Abaixo uma cópia de tela de uma análise simples de uso de memória de uma aplicativo:</p>
<p> </p>
<p><img alt="Screen shot of instruments." src="https://mdn.mozillademos.org/files/6439/instrumentsScreenShot.png" style="width: 800px; height: 492px;"><br>
 Para mais informações de como configurar uma compilação do B2G desktop, leia nossa página <a href="/pt-BR/docs/Mozilla/Firefox_OS/Platform/Gaia/Hacking">Modificando o Gaia</a>.</p>
<h3 id="Passo_3_Analise_o_relatório_de_memória">Passo 3: Analise o relatório de memória</h3>
<p>Quando você executa <code>get_about_memory.py</code>, será apresentado o relatório de memório no Firefox. Esse arquivo contém informações do uso de memório de todos os processos do sistema. A leitura desse relatório pode ser um tanto pesada num primeiro momento, mas não será tão ruim quando você pegar o jeito da coisa. Note que você pode passar o mouse sobre qualquer nó folha para obter uma descrição do que esse nó descreve. O que você estará procurando é algo "estranhamente grande" no processo que ocasionou a falha. Você pode ter uma ideia do que é "estranhamente grande" capturando um relatório de memória do seu aplicativo quando ele não está usando muita memória.</p>
<p>A leitura de um relatório de memória requer alguma prática, assim fique a vontade para pedir ajuda. Os especialistas no assunto costumam ficar no canal #memshrink do IRC.</p>
<h3 id="Passo_4_Recompile_com_DMD_se_necessário">Passo 4: Recompile com DMD, se necessário</h3>
<p>Um item comum presente nos relatórios de memória extraídos antes de uma falha é<code> heap-unclassified</code>.  <code>heap-unclassified</code> mostra a memória alocada pelo processo que não é apresentada por nenhum outro relatório de memória. Se você tem um valor alto no <code>heap-unclassified</code>, o relatório não pode dizer dizer mais nada sobre a quem a memória pertence. Nossa ferramenta para ir mais fundo no <code>heap-unclassified</code> é chamada DMD. Ela funciona no B2G, mas você deve <a href="/pt-BR/docs/Mozilla/Firefox_OS/Building_and_installing_Firefox_OS">compilar seu próprio B2G</a> para que funcione pois DMD exige símbolos locais que são mantidos na máquina que roda a compilacão.</p>
<p>Para saber mais informações sobre o DMD e como interpretar sua saída, leia a <a href="https://wiki.mozilla.org/Performance/MemShrink/DMD">página do DMD na Wiki Mozilla</a>.<br>
  </p>
